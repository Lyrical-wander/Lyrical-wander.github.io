[{"content":"前言 本文同样地是整理和归纳《深入理解计算机系统》这本书的内容，但本文不会继续长篇大论地去将所有内容都总结，而是总结笔者认为容易遗忘或混淆或表述不清的内容。\n字 首先字这个概念对于学习过《计算机体系结构》或《操作系统》的同学都不陌生，但是笔者对于这个概念很容易遗忘，所以笔者还是记录下来。\n总的来说：字长决定了虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器而言，虚拟地址的范围为 0 ～ $2^w-1 $，程序最多访问 $2^w$ 个字节。\n如果一台计算机的字长为32位，这就限定了虚拟地址空间为4GB。也就是说，即使你的主存容量再大，处理器也只能寻址4G的范围，同样的道理，在嵌入式中，8位机的概念就是字长为8位的微型处理器。\n现在市面上有许多32位，64位机器，在不同机器之间程序会遇到数据长度，寻址能力等方面的挑战，一个强大的程序，应该兼容不同的机器。\n数据大小 可以看到，在C语言中，数据类型在不同的字长的机器上占有不同的字节数，程序员应该力图使它们的程序在不同的机器和编译器上是可移植的，可移植性的一个方面就是程序堆不同数据类型的确切大小不敏感。\n布尔代数 布尔代数实际上就是围绕数字0与1建立起来的一种代数体系，以研究逻辑推理和基本原则。\n布尔代数只有0和1两个数，拥有与（\u0026amp;）、或（|）、非（~）、**异或（^）**等运算，且运算间也遵循某种分配律和交换律\n位级运算 在这里我们值得一提的是：在异或（^）运算中，我们需要注意到：a^a=0以及a^b^a=b\n正是由于异或拥有这种神奇的性质，我们可以完成以下脑经急转弯。\n请设计一个程序，在不适用第三个变量的情况下，交换x与y的值\n1 2 3 4 5 6 void inplace_swap(int *x, int *y) { *y = *x ^ *y; // step1 *x = *x ^ *y; // step2 *y = *x ^ *y; // step3 } 从上面这个函数可以看出，在step1时，y现在存储的值时 x ^ y ，在step2时，x 的值变为 x^ x ^ y = y这是根据a^b^a=b的运算规则，step3同学们可以自己算一下。\na^b^a=b这是一个运算规则而非定理，即，这并非人为规定，而是客观规律。我们尝试以下运算\na = 0110 0101\nb = 1100 1011\n根据异或的运算规则，相同则为0，不同则为1\n我们设c = a ^ b = 1010 1110\n此时再用c ^ a 得到\nd = c ^ a = 1100 1011\n你会发现，d = b ，即 a ^ b ^ a = b\n除此之外，还有一个例题非常有意思\nbis(位设置)：输入一个数据字x和一个掩码字m，生成一个结果z，z是由掩码m的位来修改x得到的，这种修改是在m为1的每个位置上，将z对应的位置设为1\nbic(位清除)：输入一个数据字x和一个掩码字m，生成一个结果z，z是由掩码m的位来修改x得到的，这种修改是在m为1的每个位置上，将z对应的位置设为0\n为了清楚因为这些运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 | 和 ^ 运算。填写下列代码中缺失的代码。提示 ：写出 bis 和 bic 运算的 C 语言表达式。\n1 2 3 4 5 6 7 8 9 10 11 12 // 你可以使用的函数 int bis(int x, int m); int bic(int x. int m); // 完善下列函数 int bool_or(int x,int y){ int result = _______; return result; } int bool_xor(int x, int y){ int result = _______; return result; } 我们可以根据说明，模拟一下bis函数的运行输入输出：\n当x = 0110 0101 m = 1100 1011时，\n根据bis的说明，m的某一位为1时，则x对应的位被修改为1，其它不变\n那么，res = bis(x,y) 则 res = 1110 1111\n根据bic的说明，m的某一位为1时，则x对应的位被修改为0，其它不变\n那么， res = bic(x,y) 则 res = 0010 0100\n那么， res = bic(y,x) 则 res = 1000 1010\n根据上面的演算，我们可以发现，当你使用bis时，则x与m两者都是0的位才为0，否则即为1。当你使用bic时，则仅有m为0时且x为1时，才为1。\n那么或运算就好办了，因为或运算的规则就是只要有1则为1，逆命题就是两者为0才为0，即bis运算\n则第一个函数为：\n1 2 3 4 int bool_or(int x,int y){ int result = bis(x,y); return result; } 异或运算的规则为，只要不同则为1，否则为0。根据bic运算，当你使用bic时，则仅有m为0时且x为1时，才为1，可以得到不同的其中一种情况，即m为0且x为1，还要第二种情况，m为1且x为0，那么只需要将m与x的位置调换，在运算以此即可获得，然后将两者进行或预算，也就是bis运算即可。\n1 2 3 4 int bool_xor(int x, int y){ int result = bis(bic(x,y),bic(y,x)); return result; } 掩码 在数据处理中的掩码与计算机网络中的掩码概念有所不同，在这里的掩码你可以理解为是一种滤波器，它可以将特定位的数据通过而屏蔽掉其它位的数据，如\n掩码：0x0000FF 与 a : 0x123456 进行运算，则会得到\nres = 0x000056\n补码编码 跳过了无符号数的编码\n在计算机中，有符号数的表示方式就是补码，将字中最高有效位定义为负权（negative weight），如\n1011 = $-12^3+02^2+12^1+12^0$ = -8 + 0 + 2 + 1 = -5\n在这种编码下，最高位变成了乘了一个-1，因此，在这种情况下，我们要考虑在有有符号数补码编码的情况下的几种特殊情况：\n0000 = 0\n1111 = -1\n0001 = 1\n1000 = -8\n0111 = 7\n在字长未4的情况下，有符号数的补码编码中，取值范围为[-8:7]，1111并非最小值，而是-1，1000才是最小值为-8，0111是最大值7\n在0000，0001，0010，\u0026hellip;，0111，1000，\u0026hellip;，1111以此类推中，实际上的数值变化是，0，1，2，\u0026hellip;，7，-8，-7，\u0026hellip;，-1\n由此我们可以看到，补码的范围是不对成的，即最小值没有与之对应的正数。这导致补码运算的某些特殊的属性，并且容易造成程序中细微的错误。\n以下表格中，*$UMax_w$表示无符号数的最大值，$TMin_w$表示有符号数的最小值，$TMax_w$*表示有符号数的最大值\n数据比较 由于 C 语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但是对于像 \u0026lt; 和 \u0026gt; 这样的关系运算符来说，它会导致非直观的结果。考虑比较式 -1\u0026lt;0U。因为第二个运算数是无符号的，第一个运算数就会被隐式地转换为无符号数，因此表达式就等价于4294967295U\u0026lt;0U，这个答案显然是错的。\n","date":"2024-11-21T13:14:00+08:00","image":"https://Lyrical-wander.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/image_hu18132413772527675279.jpg","permalink":"https://Lyrical-wander.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/","title":"计算机系统中信息数据的处理"},{"content":"前言 首先，想要实现这个功能的小伙伴需要完成几个前置条件：\n有一个GitHub账号 安装了git，并可以通过git推送commit到GitHub上 完成第一篇文章的博客搭建 创建仓库 在GitHub上创建一个仓库，用来存放代码\n如果你不是GitHub重度使用者或高手，建议你的仓库名称就是你自己的用户名 + .github + .io。如图所示：\n这是因为，如果使用这个名字的话，那么在后续使用GitHub pages生成静态网站的域名就直接是你的仓库名，而不需要加其它后缀，可能会导致未知的bug\n仓库必须公有，只有公有仓库才能部署静态页面\n修改配置 还记得上一篇文章提到的，配置文件中有一个参数是讲url重定向到自己的GitHub仓库的吗，现在我们在创建自己的仓库之后，可以开始填写，修改hugo.yaml的`baseurl\n1 baseurl: https://Lyrical-wander.github.io # 这里是我的仓库名称，如果你按照上面的步骤走，输入：https://用户名.github.io 即可 上传代码 上传代码前，首先查看你的站点目录下有没有public目录\n这个public目录是生成的静态网站的代码，还记得我们上一个文章中使用的一条命令吗\n1 hugo server -D 这条命令会启动hugo程序，将源码进行“编译”（当然并不是真正意义上的编译），生成html，scss等前端代码，这些代码构成静态网站。\n如果没有生成public目录，那么就使用hugo server -D命令生成一下。\n值得注意的是，如果你习惯用VScode中的git插件，也许会方便很多。但第一次上传代码也需要手敲命令\n但幸运的是，当你第一次创建仓库，仓库中一无所有时，会提示你如何上传代码\n在站点目录下启用cmd命令，逐条输入命令：\n1 2 3 4 5 6 git init # 初始化git git add . # 通过git上传当前目录下所有的文件 git commit -m \u0026#34;这是我的博客第一次提交\u0026#34; # 这里是给这一次提交写一个记录，说明这个提交是做什么的 git branch -M main # 创建主分支 git remote add origin xxxxxxxxx # 你是什么就填什么，不做修改 git push -u origin main 如果这里出问题，push不到仓库中，不是hugo或者stack的问题，请检查git与GitHub是否正常运行，以下有几个排查的方向：\n网络问题，因为GitHub是全球服务器，因此国内访问可能会有些慢，有条件的同学开个代理 git并没有权限访问GitHub，看你是如何配置GitHub的，建议采用SSH，网上有许多git生成ssh密钥，GitHub绑定密钥的教程，建议跟着走一遍，如果采用HTTPS的话，应该是要登陆的，具体流程笔者很久没用了，也是建议上网搜索，网上教程很多 启用pages功能 如果你成功上传代码，现在可以打开GitHub上自动生成静态网页的pages功能，来帮你生成静态网页，等静态网页生成后，以后通过访问你的仓库域名，即可直接打开你的博客\n进入你的仓库 在仓库菜单栏中找到Settings功能 在侧边菜单栏中找到Pages 在分支Branch中选择主分支main 保存Save 做完以上操作，等待一段时间静态网站部署，可能几分钟，刷新一下出现⑥处，则说明生成成功，访问这个域名即可访问你的博客！\n值得注意的是，这里我是购买了自己的域名，然后解析到我的仓库，所以我的域名是www.lyrical-wander.cn，而不是www.lyrical-wander.github.io，而如果按照上面的步骤走的话，域名应该是：www.usename.github.io\n至此，你的博客已经部署好了！可以开始访问你自己的博客啦\n小结 还有需要注意的是：\n每一次写完博客，都需要重新使用hugo server -D命令，生成新的public目录，push上GitHub 每次生成新的public，都会有大量的文件被改动，push起来非常不方便 因此我们要通过GitHub的Action功能来实现自动化部署\n自动化部署 创建仓库 同样地，按照上面的步骤，我们重新创建一个仓库，这个仓库不会生成pages，且可以设置为私有仓库，因此随意命名，比如：hugo-main\n修改代码 创建.gitignore文件 我们添加一个小文件，来保持我们代码的干净整洁。\n因为每一次hugo server -D都会生成新的public和resources，而这个并不是我们编写的代码，因此这个可以忽略掉。\n在站点目录下增加一个新文件.gitignore\n填写以下内容：\n这个文件顾名思义，可以让git忽略掉它里面填写的这些文件，这些文件git不会再检查它们的修改，也不会让你提交它们。\n生成token并创建yaml配置文件 首先我们先生成一个token，获取该token，以免你以后每次上传代码都需要重新登录一遍\n进入Settings\n移动到最下方找到Developer settings\n然后选择Personal access tokens→Tokens(classic)→Generate new token→Generate new token(classic)\n生成token时可以将Expiration选择No expiration，即这个token永不过期。\n下面Select scopes（作用范围）选择repo与workflow\n后面就生成了token~\n注意！这个token只会出现一次，之后再也不会出现，在你关闭网页前先复制保存！\n回到你刚刚创建的 第二个仓库 上（我们称之为hugo主仓库吧），不是username.github.io那个仓库！\n在仓库中打开Settings→Secrets and Variables→New repository secret 来创建一个存储token的变量\n为什么要这么做呢，因为token这个东西比较重要，如果后续我们直接将它写到文件中，如果文件被窃取，那么token就会暴露，这样你的仓库就不安全了，尤其我们的token还选择了不过期。\n因此，我们将token保存在GitHub中，以变量的形式传给我们的文件，这样token的密封性就很好了\n回到我们的站点目录下，创建一个.github目录，在.github目录下创建一个workflows目录，在该目录下生成一个xxxxx.yaml文件，名字随便取\n在xxxx.yaml文件下写入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} # 刚刚在上面创建的变量名 EXTERNAL_REPOSITORY: 你的github名/你的仓库名 # 如果按照上面的步骤走，则是username/username.github.io第一个仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 上传代码 同样地，我们将站点代码再一次上传到这个仓库上，git操作一模一样，按照上面的上传代码部分来重新操作一遍即可。\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin xxxxxxxxxxx git push -u origin main 至此，你就实现了自动部署，现在，你撰写博文，然后直接push到第二个仓库，不需要本地生成public，就可以啦，第二个仓库会做一系列操作，并生成静态网站所需的资源和public，传到第一个仓库中，然后生成静态网站。\n","date":"2024-11-20T21:48:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BA%8C/stackImage_hu319509881166415343.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BA%8C/","title":"基于Hugo构建一个属于自己的博客（二）"},{"content":"前言 我想有一个地方，能够分享一些个人生活，记录一些技术知识，那么在茫茫大的网络世界中，有许多网站或者应用可以满足我的需求，比如CSDN，比如博客园，比如QQ空间（已经渐渐消失在时间的长河中了\u0026hellip;\u0026hellip;）。但，总感觉差了些什么，它们既不能满足我的个人世界的全部想象，又不够极客主义，谁在小时候没有幻想过拥有一间完全由自己建造的，不受地皮，户型限制的房子呢？\n因此，我决定开始搭建自己的个人博客，它将成为我在网络世界的一座小屋，它的风格，样式由我定义，它将随我漂流，我可以自由地为它添砖加瓦，也可以任性地删除任何我不满意的功能，也许在某天它将因为我的离开而荒废，但这里，有我在网络世界的一部分记忆，一部分独属于我的记忆\u0026hellip;\u0026hellip;\n笔者的个人博客，苏三有春的博客，采用了Hugo框架下的stack主题搭建，非常快速且简单（当然在搭建的过程当中笔者也踩了一些坑），因此写一篇博客来记录自己的搭建心得以及给有想法搭建个人博客的小伙伴们一些参考。\n参考视频：\n【雷】Hugo + Github免费搭建博客，并实现自动化部署_哔哩哔哩_bilibili\nHugo Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署，可以帮助用户快速构建高性能的静态网站，方便个人搭建博客，和个人网站等。Hugo在GitHub（ The world’s fastest framework for building websites.）上拥有超过75K stars，近千名贡献者，拥有活跃的社区，保证了Hugo成为当下最流行的静态网站生成器之一，正如其标题所说：“Hugo是世界上最快的构建网站的框架”。\nHugo下载 Hugo框架的下载有一些注意事项：\nHugo根据操作系统的不同有不同的下载方式\nMacOS\nbrew install hug\nLinux\nsudo snap install hugo\nWindows\nchoco install hugo-extended\n上面的下载方式是官方推荐的，笔者的主要工作环境是Windows，但并不采用上述的下载方式，因为choco是一个包管理器，本身也需要下载（笔者不喜欢因为一个功能而去下载另一个功能，导致整个环境特别臃肿），可以采用以下方法去下载：\n到Hugo的GitHub仓库中，找到Tags\n选择最新的版本（本文创作时最新版本是v0.138.0）\n一直往下滑，可以看到一堆Assets资源，找到Windows，且带有extended版本的，本文是根据Hugo框架下的stack主题来构建的，如果你查看过stack的官方文档，可以发现，其中也强调了是以哦那个extended（拓展）版本，才能完成该主题的全部功能搭建。\n下载完成后，你会得到一个Hugo静态网站生成器的exe执行文件，该执行文件可以帮助你生成一个静态网站的全部内容。此步骤可做可不做：将hugo所在的目录放在系统环境变量path中。笔者是做了这一步的，这一步的作用是，无论你在那个目录下，都能使用hugo命令。如不添加，则当你生成了一个静态网站资源，你需要将hugo.exe文件拖入静态网站资源的目录下，以便你日后在在目录内调用hugo命令。\n在控制台（如果没有添加环境变量，则需要在有hugo.exe的目录下执行）使用hugo version命令测试hugo是否安装成功，如果安装成功，则输出如下\n1 2 3 4 D:\\HugoBlog\\dev\u0026gt;hugo version hugo v0.136.5-46cccb021bc6425455f4eec093f5cc4a32f1d12c+extended windows/amd64 BuildDate=2024-10-24T12:26:27Z VendorInfo=gohugoio D:\\HugoBlog\\dev\u0026gt; 创建新的站点 在cmd中（如果没有配置全局路径，在hugo.exe目录下使用该命令）使用命令\n1 hugo new site yoursitename #yoursitename 是你的站点文件夹名称， 可以使用dev或自己起个名字 上面截图显示了创建新的站点成功，并且会给你一些提示，按照提示走就可以花很少的时间搭建出一个静态网站\nHugo会在这个D:\\HugoBlog目录下自动新建一个名为AHugoBlogSite的目录，如下图所示：\n进入AHugoBlogSite目录\n1 cd AHugoBlogSite 挑选主题 Hugo下载好后，就可以开始挑选自己喜欢的主题，可以在Hugo官网下挑选（Complete List | Hugo Themes），每个主题都可以点进去查看详细信息与下载地址，笔者这里使用了stack主题，特别适合用于搭建个人博客网站。可以通过Hugo Themes中选中stack主题，进去Download，也可以在GitHub上直接搜索CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers，仿照上面下载hugo的方法找到对应位置下载源码（source code）压缩包即可。\n如果有兴趣为该主题添砖加瓦的同学，也可以给这个主题作者提交Issues！\nStack 解压主题 将stack主题的源码解压到AHugoBlogSite\\themes目录下（接下来为了方便，AHugoBlogSite统称为站点目录）。\n将解压的目录名称中的版本号删除，改成像我一样hugo-theme-stack\n值得注意的是，如果你想换其它主题，或者你一开始便不打算下载stack主题，操作也是一样的，同样将版本号删除，并将yaml配置文件中的主题改成对应的主题目录名称即可（后面会提及）\n从主题文件中复制两个重要文件 在解压的目录（hugo-theme-stack）下，有一个样例目录名为：exampleSite，里面有两个非常重要的东西，一个是content目录，一个是hugo.yaml配置文件，将这两个文件复制出来\n放到站点目录下 将原本的默认配置文件hugo.toml删除，用我们复制过来的hugo.yaml做配置文件\n注意：在content\\post\\目录下，有一个rich-content的目录==删掉==，post目录下存放的就是你的博客内容，这个rich-content博客中做了一些引用Youtube的样例操作，可能会导致你运行失败，这些国外网站可能会导致你访问超时\n修改配置 打开刚才复制过来的hugo.yaml\n更换主题 可以看到，这里主题选择的是hugo-theme-stack，如果你想更换其它的主题，只需下载其它主题的源码到themes\\目录下，并将配置文件中的主题换掉即可\n以下笔者就不截图了，以代码段形式展现笔者修改了的部分:\n笔者将url的重定向到自己的GitHub仓库，下一篇讲部署到GitHub上时会提及\n1 baseurl: https://Lyrical-wander.github.io 修改了著作权，当然，这个著作权是指本博客的著作权，而非hugo也非该主题\n1 copyright: Lyrical Wander 将默认语言修改为中文\n1 DefaultContentLanguage: zh-cn 修改以下配置，据说可以更精确的计算读文章的时长\n1 hasCJKLanguage: true 这里修改的是博客左上方的标题，有中英两个版本，但笔者的博客全是中文博客，还没有做国际化的打算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 languages: en: languageName: English title: LyricalWander\u0026#39;s Blog weight: 1 params: sidebar: subtitle: We have a long life,but just own death and love zh-cn: languageName: 中文 title: 苏三有春的博客 weight: 2 params: sidebar: subtitle: 人生茫茫，唯死亡与爱而已 这个参数是指一页展示多少篇文章\n1 2 pagination: pagerSize: 5 你可以在static目录下存放你博客的图标，将名称改为favicon.ico 1 2 favicon: /favicon.ico # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) 以下参数是修改你的头像以及添加emoji（头像右下角的表情），首先将图片名称改为avatar.png，并添加到assets\\img\\目录下，如果没有img目录可自行创建，然后将参数修改：\n1 2 3 4 5 6 7 sidebar: emoji: 🧐 subtitle: Lorem ipsum dolor sit amet, consectetur adipiscing elit. avatar: enabled: true local: true src: img/avatar.png 修改下面的参数，可以添加或修改头像下面的快捷链接小图标，笔者增加了链接进入笔者B站主页和进入笔者CSDN主页的快捷链接，图标以SVG格式存放在assets\\icons\\目录下，值得注意的是，下面参数icon是图标的文件名去掉.svg，比如brand-bilibili.svg去掉.svg，如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 social: - identifier: github name: GitHub url: https://github.com/Lyrical-wander params: icon: brand-github - identifier: bilibili name: Bilibili url: https://space.bilibili.com/28788259 params: icon: brand-bilibili - identifier: csdn name: CSDN url: https://blog.csdn.net/whale_cat params: icon: brand-coinbase 现在我们创建我们的博客看看\n命令：\n1 hugo server -D 注意：\n必须是在站点目录下使用该命令。（上面我们通过cd AHugoBlogSite进入了目录） 必须是D而不是d 运行命令后会出现以下信息\n可以看见，通过访问http://localhost:1313即可访问博客\n开始编写文章 文章目录结构 首先看一下文章目录结构，文章都保存在content目录下：\n看看对应的网站结构：\n其实无论是page，categories，post，都可以看作一个一级目录，然后每一篇文章，每一个分类，亦或者每一个侧边栏的选项，都是二级目录，二级目录下才是真正的内容，比如，在categories目录下：\n有这么四个二级目录，分别代表了四个我已经创建并附带说明的分类\n值得注意的是，你看我的博客分类有许多，比如网络爬虫，操作系统等，都没有在categories目录下创建，但在分类中依然存在，这是因为，我将某篇文章归类为网络爬虫，但是还没有创建这个分类，因此Hugo自动地帮我创建一个默认分类，把带有网络爬虫的文章收录在一起，但是这分类没有初始图片，没有说明，如下图所示：\n这个分类中没有默认图片，也没有简介，技术杂谈这个分类就有，如下图所示\n如何写博文 我写博文采用的是markdown格式，这个格式我非常熟悉，写起来也特别舒服，使用Typora工具，写markdown手感特别好。\nmakrdown格式没什么好说的，学起来也很快，在写博文的时候需要注意的是开头携带的信息，如下图所示：\n这是文章开头的内容，这里我打开了typora的源码模式。如果是普通的编写模式，则是下面这个样子的：\n可以看到，Typore自动的把---这个识别成分割线，把源码中用---包起来的内容用分割线与下面内容隔开。\n在这里面，你需要注意的是：\ntitle：文章标题 description：副标题，简介 date：编写日期 image：文章最上方的图片 categories：分类 tags：标签 分类和标签的内容可以是中文，可以多个，但需要采用[\u0026ldquo;xx\u0026rdquo;,\u0026ldquo;xx\u0026rdquo;]的格式 :后需要加一个空格，再输入内容 后面的就按照正常markdown创作即可\n值得注意的是：\n博文采用markdown格式，命名规则为：index.语言.md，这里因为我的默认语言是中文，就不用携带语言，即：‘zh-cn’，因此只需要命名为index.md即可。\n总结 至此，你已经搭建了你的个人博客，并且可以开始写文章啦，更多关于stack主题的美化或修改可以看stack文档Stack | Card-style Hugo theme designed for bloggers\n同时，下面一篇文章会介绍如何将博客部署到GitHub上，可以通过GitHub的pages功能，创建一个可以在公网访问的博客网站，很感谢你读到这里，祝你变得更强！\n","date":"2024-11-19T21:47:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%80/stackImage_hu319509881166415343.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%80/","title":"基于Hugo构建一个属于自己的博客（一）"},{"content":"前言 前段时间，笔者因工作需要，尝试搭建了一个Wiki.js，将笔者的学习经历以及踩坑过程通过这篇文章分享给各位读者。\nWiki是一种允许多人共同编辑和管理内容的平台，可以让被授权过的用户在上面创建，修改和更新页面，实现协作和信息共享，广泛应用于教育，公司文档管理，项目合作等多个领域。\n笔者选择采用Wiki.js，一个开源且美观的Wiki程序，在网上照猫画虎地用了docker技术下载安装在Ubuntu22.04系统中，如果你采用的配置和我一样，那么可能会遇到我遇到的这些坑。\n参考文档：\nWiki.js\n【实用的开源项目】使用服务器部署Wiki.js，一个美观且强大的开源Wiki程序-腾讯云开发者社区-腾讯云\n华为开源镜像站_软件开发服务_华为云\nWarning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead (see apt-key(8))-CSDN博客\ndocker pull 报错Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for c-CSDN博客\n首先，笔者在本地虚拟机以及阿里云服务器（免费试用的）都尝试过部署Wiki.js。本地部署于云服务器部署都相同\n请注意，接下来的内容中，如果是笔者强调注意的地方（笔者踩过坑的地方），都会以下方式呈现，注意：\n这里是笔者踩过的坑：\u0026hellip;\u0026hellip;\n安装Docker 如果你需要在云服务器上部署，那么第一步是选择并购买服务器，现在在市面上的服务器有很多，笔者不做推荐。笔者使用的是阿里云的服务器，2核4G，Ubuntu22.04系统，预装LNMP应用。但是笔者看的看的笔记是腾讯云的，【实用的开源项目】使用服务器部署Wiki.js，一个美观且强大的开源Wiki程序-腾讯云开发者社区-腾讯云，但感觉大部分内容大差不差，在阿里云上业跑起来了，只不过没有做反向代理的那一步，因为自己使用，直接用IP:端口访问。\n1.更新apt-get 因为笔者采用的是阿里云的云服务器，系统没有预装docker，所以我们要自己下载并安装docker。\n首先更新一下包管理器，并安装必要的软件包curl\n1 2 apt-get -y update apt-get -y install curl 2.下载安装Docker-ce 接下来注意了：\n笔者曾在这里踩过坑：根据上面腾讯云的内容，笔者是无法直接安装并docker的，笔者怀疑是镜像源的问题，现在许多国内镜像源在pull的时候都会出现报错，因此，笔者做了以下修改：华为开源镜像站_软件开发服务_华为云\n笔者按照这篇文章下载的docker-ce\n==但是！！！！！！！！！！！==\n注意，笔者在服务器上下载完了几天后，开始写文章时重复操作，发现无法下载了！\n发现没有，在华为云的文章中，使用了apt-key命令来添加GPG密钥，但现在，apt-key命令被弃用了！！\n无法通过该命令来添加GPG密钥，因此笔者又上网冲浪了许久，在茫茫多的文章中终于找到了可以解决困境的办法\nDocker：如何解决安装 docker 时 ubuntu 中的公钥错误 - Stack Overflow\n【docker安装】由于没有公钥，无法验证下列签名： NO_PUBKEY 7EA0A9C3F273FCD8-CSDN博客\n以上文章笔者实测，是可以解决添加GPG密钥时出现的apt-key is deprecated的问题。\n具体命令是：\n1 2 3 4 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg sudo chmod a+r /usr/share/keyrings/docker-archive-keyring.gpg apt-get update apt-get install docker-ce 3.启动Docker 执行以下命令启动docker\n1 systemctl start docker 检查docker的运行状态\n1 systemctl status docker 设置为开机自启动docker\n1 systemctl enable docker 新版的docker自带了compose命令，即，你无需下载docker-compose，即可使用docker compose命令（注意中间是空格）\n部署Wiki.js 1.新建目录 新建Wiki.js的存放目录，且移动到目录下\n1 mkdir -p /opt/docker/wikijs \u0026amp;\u0026amp; cd /opt/docker/wikijs \u0026amp;\u0026amp; mkdir -p /opt/docker/docker_data/postgresql/data 这里新建了两个目录，一个是docker目录下的wikijs，一个是数据库的目录，数据库采用postgresql，具体数据库的差异笔者也需要去学习一下。\n2.新建docker-compose.yaml文件 docker-compose.yaml文件是用来等会自动化下载的，按照这个文件中的配置下载Wiki.js并配好数据库。我们这使用nano命令来配置，因为在新安装的系统中，没有vim命令，如果想使用vim命令需要apt-get install vim先下载。\n创建并编辑docker-compose.yaml文件\n1 nano docker-compose.yaml 输入以下配置内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --- version: \u0026#34;3\u0026#34; services: db: image: postgres:11-alpine environment: POSTGRES_DB: YourDatabaseName #设置一个自定义的数据库名以替换 smalljunwikijs 需与下方的 DB_NAME 一致！ POSTGRES_PASSWORD: YourDatabasePassword #设置一个自定义的数据库密码以替换 wikijssmalljunpw 需与下方的 DB_PASS 一致！ POSTGRES_USER: YourDatabaseUserName #设置一个自定义的数据库用户名以替换 smalljunwiki 需与下方的 DB_USER 一致！ logging: driver: none restart: unless-stopped volumes: - /opt/docker/docker_data/postgresql/data:/var/lib/postgresql/data wiki: image: ghcr.io/requarks/wiki:2 depends_on: - db environment: DB_TYPE: postgres DB_HOST: db DB_PORT: 5432 DB_USER: YourDatabaseUserName DB_PASS: YourDatabasePassword DB_NAME: YourDatabaseName restart: unless-stopped ports: - 2078:3000 可以看到，这里我们需要下载两个东西，一个是db即database，一个是wiki即Wiki.js，端口开放为2078，即如果你想访问Wiki.js，则需要通过IP地址:端口号（2078）的形式访问，如果不做方向代理的话\n编写完成后，按Ctrl + x退出，按y确认保存，按enter回车键退出\n3.更改镜像源 原本到这里，按照文章的内容应该是开始运行命令下载\n1 docker compose up -d 但是，因为没有使用国内镜像源，因此在下载的时候会：\n笔者踩过的坑：\n如果没有镜像源下载，那么将会出现：Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for c\n网上大多数的镜像源都无法解决这个问题，以下两篇文章是笔者实践过可以的\n彻底解决docker：docker: Get https://registry-1.docker.io/v2/: net/http: request canceled 报错-CSDN博客\ndocker pull 报错Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for c-CSDN博客\n笔者综合了一下他们的镜像源，以下是笔者采用的镜像源，实践可以下载：\n1 2 3 4 5 6 7 8 9 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.1panel.live\u0026#34;, \u0026#34;https://0dj0t5fb.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://6kx4zyno.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34; ] } https://docker.1panel.live是第二篇文章博主提供的，这个镜像源可以让我成功地下载yaml配置中的db，即下载数据库，后面的镜像源采用的是第一篇博主的。它无法正常下载db，会报出上面的错误，但是可以下载wiki。\n下载时间较长，根据笔者多次失败经历以及更换镜像源的经历，在下载过程中60s内没有爆出上述错误，且db于wiki的下载项都出现，即开始正常下载\n什么叫“db于wiki的下载项都出现呢”，当你运行docker compose up -d命令后，会先出现 db与wiki两项在转圈圈，但是这两项下有许多文件需要下载，需要全部文件都展示出并显示等待下载，才算是开始正常下载。\n访问Wiki.js 通过浏览器访问IP地址:2078即可访问你自己的Wiki.js。\n在访问过程中，笔者也遇到了一些坑，首先介绍一下笔者的环境：\n一台台式机，开着虚拟机运行Ubuntu环境下载了Wiki.js，想通过另一台计算机（笔记本）访问这个Wiki.js\n笔者在网上查阅了大量文章，发现很多文章都是用的是NAT模式，然后通过与虚拟机与宿主机协同暴露指定端口供外接访问，因为虚拟机与宿主机是同一IP地址，因此必须要两者配合，但是宿主机又是Windows系统，因此协调起来比较麻烦，所以笔者采用了桥接模式，虚拟机拥有自己的IP地址，虚拟机可以直接访问外部网络。\n获取IP地址 首先使用以下命令查看虚拟机的IP地址\n1 ip addr show 或者使用\n1 ifconfig 查看防火墙状态 使用以下命令查看防火墙状态，确保防火墙关闭\n如果使用的是ufw\n查看防火墙状态：\n1 ufw status 关闭防火墙\n1 ufw disable 小结 值得注意的是：\n笔者踩过的坑：\n通过这样的方式访问，需要虚拟机与访问虚拟机的机器在同一局域网下，否则的话是无法访问的，因为虚拟机并没有暴露在公网中\n总结 在本次搭建的过程中，笔者也学到了很多东西：\n安装Docker时出现大大小小各种错误，包括镜像源不行，下载过慢，GPG无法使用，apt-key命令被弃用等 在部署Wiki.js时，遇到的最重要的问题就是镜像源问题，虽然在最后笔者采用的镜像源帮助了笔者完整下载，但是在这之前，笔者浏览了许多文章（大多数都相似，使用阿里云的镜像源），都无法正常下载，真的很崩溃。 在最后写这篇文章时，笔者打算重新找回那些资料，发现自己浏览记录过多，许多资料和网站已经找不到了！这也是缺失之一，以后在解决某项问题的时候，希望保持良好习惯，点赞收藏，并及时开始写博客。 ","date":"2024-11-18T19:31:00+08:00","image":"https://Lyrical-wander.github.io/p/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84wiki%E7%9F%A5%E8%AF%86%E5%BA%93/WikijsAndDocker_hu12145976411144345130.png","permalink":"https://Lyrical-wander.github.io/p/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84wiki%E7%9F%A5%E8%AF%86%E5%BA%93/","title":"搭建自己的Wiki知识库"},{"content":"前言 今天来读一下《深入理解计算机系统》，在这篇文章中，笔者将这本书的内容做一些大概的总结与归纳，如果你希望学习：\n如何避免由计算机表示数字的方式导致的奇怪的数字错误 怎样通过一些小聪明小窍门来优化你的C代码，以充分利用现代处理器和存储器系统的设计 编译器是如何实现过程调用的 如何避免缓冲区溢出错误带来的安全漏洞 如何识别和避免链接时那些令人讨厌的错误 如何编写自己的Unix shell，自己的动态存储分配包，甚至是自己的Web服务器 了解并发带来的希望与陷阱 强烈推荐去看一下原书。本文只能是对书本中笔者认为重要或者难以理解与记忆的地方做总结与推导，甚至部分内容加入了笔者自己的理解，理解不一定正确，仅供大家参考。\n最后，再一次推荐大家去看一遍原书，我们要直接对原著围观，尽可能不围观他人的围观，这中间难免有信息的减损甚至误导。\n我们将通过跟踪hello程序的生命周期，来开始对系统的学习。\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello world!\u0026#34;); } 当然，首先我们要对要出现的关键概念，专业术语与组成部分做一下介绍。\n信息就是位+上下文 hello程序的生命周期是从一个源程序（源文件）开始的，源程序实际上就是一个值由0和1组成的位序列。大部分的现代系统都使用ASCII标准来表示文本。像hello.c这种只由ASCII字符构成的文件称为文本文件，其它的则称之为二进制文件，如：如经过汇编器后将汇编语言（文本）翻译成机器语言（二进制）后的可重定位目标程序。\n编译系统 GNU GNU（GNU\u0026rsquo;s Not Unix），是1984年由Richard Stallman发起的免税慈善项目，旨在开发一个完整的类Unix的系统，其源代码可不受限制地传播与修改。GNU已经开发出了一个包含出Unix所有的主要部件，出了内核（由Linux项目独立发展）。GCC便是其中一个有用的工具之一。\nGCC编译器可以编译包括C语言，C++，Objective-C，Python等多种语言。到现在也是Linux下非常重要的C语言编译工具。\n编译过程 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：\n1 gcc -o hello hello.c 这个编译系统由四个阶段组成：预处理器、编译器、汇编器、链接器。\n预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，比如hello程序中的#include\u0026lt;stdio.h\u0026gt;会告诉预处理器读取系统头文件stdio.h的内容，并直接插入到程序文本中，结果就得到了另一个C程序，通常以.i作为文件扩展名 编译阶段：编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。 汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。 ==从此时开始，文件内容格式便从ASCII字符文本转换成二进制== 链接阶段：hello 程序调用了 printf 函数，它是每个 C 编译器都会提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。 处理器读并解释存储在存储器中的指令 了解系统的硬件组成 总线：贯穿整个系统的是一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，在各个系统中的情况都不尽相同。现在的大多数机器字长有的是 4 个字节（32 位），有的是 8 个字节（64 位）。 I/O设备：输入 / 输出（I/O）设备是系统与外部世界的联系通道。 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引），这些地址是从零开始的。 处理器：中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个字长的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。 运行hello程序 初始时，外壳程序（shell）执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串“./hello”后，外壳程序将字符逐一读入寄存器，再把它存放到存储器中，如下图所示。 当我们在键盘上敲回车键时，外壳程序就知道我们已经结束了命令的输入。然后外壳执行一系列指令来加载可执行的 hello 文件，将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello, world\\n”。利用直接存储器存取（DMA）的技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示。 一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的main 程序中的机器语言指令。这些指令将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如下图 所示。 从这张图中可以看到，当CPU的工作需要使用到某些资源或数据时，从主存调取往往需要费一番周折，从主存出发，经过存储器总线，系统总线，总线接口，才堪堪到达寄存器，而这段时间CPU是无法进行下一步工作的，CPU的算力被白白浪费了。\n高速缓存 高速缓存就是CPU与主存（我们经常口头说的内存）之间的一个缓冲区，因为主存的读写速度要比CPU的运行速度低几个数量级，因此，每当CPU开始需要从主存中读写数据时，都需要停下来等待主存完成读写，这样CPU的算力被白白浪费了。因此高速缓存诞生了，它的存储空间没有主存大，但是运行速度比主存快，它的运行速度没有CPU内的寄存器快，但是存储空间比寄存器大，如下所示：\n存储空间 读写速度 寄存器 小 快 高速缓存 中 中 主存 大 慢 从数学的角度来讲，在寄存器与主存中间插入了以及高速缓存，使读写速度的曲线更为平稳光滑，虽然高速缓存的速度依然没有寄存器快，但是介于成本（毕竟运行速度与存储空间在当下的物理材料与技术特性中依然属于不可兼得的）与运行效率的考量，高速缓存是最具性价比的。\n首先了解什么叫局部性原理\n局部性原理的概念：\n局部性原理是计算机科学中的一个重要概念，它描述了一个现象：==在一段时间内，程序倾向于仅使用一部分代码或数据。==这种倾向性分为两类：时间局部性和空间局部性。时间局部性指的是如果某个数据项被访问，那么它不久后可能会被再次访问。空间局部性则是指如果访问了某个存储单元，那么其附近的存储单元也很可能不久后会被访问\n利用局部性原理，可能经常访问的数据提前调入高速缓存中，如此CPU在访问下一次访问时，大概率可以直接从高速缓存中进行访问，这样运行速度将大大提升。\n在编程实践中，理解局部性原理可以帮助开发者优化代码性能。例如，在处理数组或循环结构时，考虑数据的存储和访问模式可以显著影响程序的执行效率。数组通常在内存中顺序存储，因此按行访问数组元素通常比按列访问更高效，因为这符合空间局部性原理。\n存储设备的层次模型 这个模型比较熟悉了\n操作系统管理硬件 应用程序并不直接接触硬件，操作系统介于软件与硬件之间。\n操作系统为程序与硬件之间提供了一个虚拟接口，操作系统有两个基本功能：\n防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂又大相径庭的硬件设备 操作系统通过将复杂的硬件接口抽象成几个基本概念（进程，虚拟存储器，文件）供应用程序使用，以此来完成上面两个功能。\n​\t操作系统将I/O设备抽象成文件，将主存+I/O设备抽象成虚拟存储器，将处理器+主存+I/O设备抽象成进程。\n文件 文件就是字节序列，每一个I/O设备，磁盘，键盘，甚至是网络，都可以看作是一个文件，I/O设备的输入输出，其实就可以看作是对文件的读写操作。这样对程序员来说是方便的，你无需了解磁盘的各种技术，就可以使用磁盘的数据，因此，同一个程序可以在使用了不同磁盘技术的不同系统上运行。\n虚拟存储器 虚拟存储器是一个抽象概念，它为每一个进程提供了一种抽象，让进程以为自己独占内存，让每一个进程看到的是一致的内存，这对程序员是方便的，假设如果没有虚拟内存储器技术，程序员在编写程序时，需要提前对内存进行操作，因为你不知道你现在使用的内存地址是否被其它进程占用了。现在，对内存的操作交给了虚拟存储器，程序员只需编写相对地址，由操作系统自动分配实际的内存地址。以下是Linux进程的虚拟地址空间\n程序代码和数据：对于所有进程来说，代码是从同一固定地址开始的，然后是全局变量与相对的数据位置。代码和数据是按照可执行目标文件的内容开始初始化的，当然还用这里还有链接与加载的事。 堆：下一块是运行时堆，与代码与数据区不同，代码与数据区在进程一开始时就确定好了大小，而堆的空间会随着程序调用malloc或free等操作，而增大或缩小空间。 共享库：大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别是每次我们调用一个函数时，栈就会增长 ；从一个函数返回时，栈就会收缩。 内核虚拟存储器：内核总是驻留在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。 进程 当程序在操作系统上运行时，操作系统会提供一个假象，即系统上好像只有这一个程序在运行，它可以调用处理器，主存和I/O设备。\n进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在系统中，正在运行的进程往往是比CPU的个数还要多的，因此，无论是单核处理器还是多核处理器，都具备并发运行的能力。而并发运行是通过处理器在进程之间切换来实现的，操作系统实现这种交错机制称之为“上下文切换”。\n操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，它包括许多信息，例如 PC 和寄存器文件的当前值，以及主存的内容。\n当操作系统决定将处理器的控制权交给另外一个进程时，就会进行上下文切换，保存当前进程的上下文，恢复新进程的上下文，将处理器控制权交给新进程。\n值得注意的是，在Linux中，上下文切换的读写数据在内核空间发生，“内核空间”与“用户空间”是Linux类系统的重要概念。\n小结 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。\n处理器读取并解释存放在主存里的二进制指令。因为计算机把大量的时间用于存储器、I/O设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构—CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特开销也更高。层次结构中较高层次存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C 程序的性能。\n操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象 ：1）文件是对 I/O设备的抽象 ；2）虚拟存储器是对主存和磁盘的抽象 ；3）进程是对处理器、主存和 I/O 设备的抽象。\n","date":"2024-11-12T14:20:00+08:00","image":"https://Lyrical-wander.github.io/p/%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/image_hu1867866105620835933.jpg","permalink":"https://Lyrical-wander.github.io/p/%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/","title":"程序在系统中是如何运行的"},{"content":"前言 本文笔者吸取了第一次爬取微软翻译的经验，发现在对微软翻译进行请求的时候，URL会随着会话结束而重新生成，这一点是本文需要解决的内容，且除了URL中出现的IG和IID两个数据外，在请求的表单数据中，还有key和token两个数据也在动态变化。本文旨在追踪这几个数据在何时被发送，如何被获取。\n分析 首先，重新打开浏览器自带的开发者工具，随便翻译一词，让客户端发送一次翻译请求ttranslatev3，可以发现，这次URL与前一篇文章基于PyQt开发的脚本集合包（八）的又不一致\nhttps://cn.bing.com/ttranslatev3?isVertical=1\u0026\u0026IG=DFFF2F46AAE0482491F67EEEB26C249C\u0026IID=translator.5025\n笔者借助开发者工具自带的搜索框进行搜索，看看我们需要的数据在哪里出现过\n除了上一篇文章中提到的IG和IID两个数据外，我们还需要找到token和key两个数据，在ttranslatev3响应请求中，可以看到我们发送请求时，请求表单除了携带需要翻译的文本，翻译前的语种，翻译后的语种外，还需携带两个特殊的信息\n至于tryFetchingGenderDebiasedTranslations一直为true，因此直接填写即可\nIG 找到IG所在 首先看看IG在哪里出现过，将IG的数据DFFF2F46AAE0482491F67EEEB26C249C复制进搜索框查询，得到以下信息\n可以发现，搜索出来的大部分请求中，这一串数据都是出现在URL与path中的，也就是说，这些请求中，IG数据也是被使用的，并不是出自于这些请求，继续向下滑动，找到了一个translator的包\n如果你点击进去，就会发现，这其实就是访问该页面的第一个请求响应，它的html数据构建了整个页面\n现在我们查看IG数据在这个响应的哪里，点击刚刚搜索的地方，会自动跳转到response出现了相同信息的地方，如下图所示：\n因此，现在重新确认一下目标：目标从“找到IG数据的出处”变更为“获取IG数据”。\n请求获取IG数据 来观察一下这个请求响应，回顾一下上一篇文章，我们在请求时需要些什么数据：\nURL、User-Agent、表单数据\n那我们依次来找这个请求所需要的数据，首先看标头：\nURL\n这个URL携带的信息很好猜，https://cn.bing.com/translator是访问的主机，即微软搜索引擎bing的翻译页面，?表示后面携带了多个参数，ref=TThis这通常表示一个参考信息或来源标识符。可能是用来跟踪用户从哪个链接访问了翻译工具，text表示默认的翻译文本，from表示翻译前的语种，to表示目标语种。可以看到，这里后面携带的三个信息，正好是打开网页时的默认信息\n“输入文本”是背景，实际上并没有东西在这里。\n可以猜测，每次访问这个页面，URL大概率是不会发生变化的，没有携带什么特殊的信息。经过反复的刷新和测试，验证了这个猜想。\nUser-Agent\n为什么User-Agent会是一样的？需不需要担心它会不会变化？来看一下User-Agent的定义：\n在进行网页爬虫时，User-Agent 是一个非常重要的 HTTP 请求头字段，它的主要作用是向服务器提供有关请求者（通常是浏览器或爬虫）的一些信息。具体来说，它会告诉服务器，发出请求的客户端是什么类型的设备，操作系统，浏览器等。不同的服务器和网站可能根据 User-Agent 来决定如何响应请求，比如返回不同的内容、样式，或者限制对某些类型客户端的访问。\nUser-Agent 的作用总结： 识别客户端： User-Agent 向服务器表明请求是由哪个客户端发出的。对于不同的浏览器、操作系统或设备，User-Agent 会有所不同。例如，Chrome、Firefox、Safari、IE 等不同浏览器会有不同的 User-Agent 字符串。 避免被识别为爬虫： 网站可能会根据 User-Agent 来识别是否是爬虫程序。很多爬虫程序没有设置真实的 User-Agent，或者 User-Agent 字符串看起来像是一个自动化脚本（比如 Python 的 requests 库默认 User-Agent 是一个简单的字符串）。一些网站会使用这一点来检测并阻止爬虫请求。因此，为了模拟浏览器，爬虫通常会伪装成浏览器的 User-Agent，避免被网站识别为爬虫。 返回适配的内容： 根据 User-Agent，服务器可以返回特定格式的内容。比如，移动设备和桌面设备通常会看到不同版本的网页，甚至不同的图片大小和样式。通过查看 User-Agent，服务器可以判断请求来自于手机、平板、桌面或其他设备，并返回不同的页面样式或功能。 分辨设备和浏览器版本： User-Agent 可以帮助服务器确定访问者的设备类型、操作系统及浏览器版本，从而优化响应内容。比如，某些页面可能会针对不同的操作系统（如 Windows、macOS、Linux）或不同版本的浏览器提供特定的网页布局或 JavaScript 功能。 可以看出，一些服务器会根据User-Agent来判断访问请求是不是来自人类或自动化脚本，可做一些反爬虫操作。我们从浏览器获取的请求信息中包含的User-Agent，表明了这段请求时来自浏览器，而非自动化脚本，因此，我们可以回答上面的问题：1.User-Agent一样是因为我们今天与昨天用的都是同一个浏览器访问，它代表了“该请求来自Edge浏览器”。2.无需担心它会发生变化，除非浏览器更新会更改这项数据，而这大概率是不会发生的。\n代码实现 首先，先获取整个response的html数据，把它写在一个单独的文件里，（数据量太大，操作台无法查找相应的数据），有些导入的模块会在后面的代码中用到，这仅是完整代码的一部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 import requests import re from bs4 import BeautifulSoup from urllib import response import urllib.request import json url = \u0026#34;https://cn.bing.com/translator?ref=TThis\u0026amp;text=\u0026amp;from=zh-Hans\u0026amp;to=en\u0026#34; header = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} response = requests.get(url,headers=header,data={}) response.raise_for_status() html = response.text with open(\u0026#34;translator.html\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(html) 获取到相应的HTML，直接搜索IG\n现在，我们找到了这个数据，用正则表达式将数据获取，其中re.search方法是调用第三方库re\n1 ig = re.search(r\u0026#39;IG:\u0026#34;(\\w+)\u0026#34;\u0026#39;,html).group(1) # 使用正则表达式在html文件中查找IG数据并获取 IID 我们用同样地办法查找IID的所在地并获取它\n找到IID的所在 找到IID数据的所在，依然在translator请求响应中，这就好办了，因为该请求的完整相应已经被我们获取了，只要找到相应的位置即可。\n刚刚获取的HTML文件中，你可以找到多个带有data-iid属性的\u0026lt;div\u0026gt;，因此，我们需要更加详细的信息来确认其位置，比如利用前面的id=\u0026quot; tta_outGDCont\u0026quot;，\n代码实现 可以使用第三方库BeautifulSoup，获取html格式数据中特定的属性，比如data-iid\n1 2 3 4 soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) dev_element = soup.find(\u0026#34;div\u0026#34;, id = \u0026#34;tta_outGDCont\u0026#34;) data_iid = dev_element.attrs[\u0026#34;data-iid\u0026#34;] print(\u0026#34;data_iid:\u0026#34;+data_iid) 我们来解释一下soup = BeautifulSoup(html, \u0026quot;html.parser\u0026quot;)这一段代码\n1. BeautifulSoup BeautifulSoup 是一个 Python 库，主要用于从 HTML 或 XML 文档中提取数据。它提供了许多方法来帮助你遍历、搜索和修改 HTML/XML 文档的内容。\n2. html html 是传入 BeautifulSoup 构造函数的参数，通常是一个包含 HTML 内容的字符串。它代表了待解析的 HTML 文档。可以是从文件读取的内容，或者是通过网络请求获取的 HTML 页面。\n3. \u0026ldquo;html.parser\u0026rdquo; \u0026quot;html.parser\u0026quot; 是 BeautifulSoup 的一个解析器（parser）。它告诉 BeautifulSoup 使用 Python 内建的 HTML 解析器来解析传入的 HTML 文档。这个解析器是一个快速且有效的解析工具，但对于一些特殊的 HTML，可能处理得不如其他第三方解析器（如 lxml 或 html5lib）精准。\n\u0026quot;html.parser\u0026quot; 选项是 Python 默认的解析器，但如果你安装了 lxml 或 html5lib 等库，也可以指定其他解析器。例如：\n\u0026quot;lxml\u0026quot;：使用 lxml 库的 HTML 解析器。 \u0026quot;html5lib\u0026quot;：使用 html5lib 库，它更宽容于不规范的 HTML 代码。 4. 最终效果 这行代码的作用是：通过 BeautifulSoup 库，将传入的 HTML 字符串 html 解析成一个 BeautifulSoup 对象，并指定使用内建的 html.parser 解析器。解析后的 soup 对象可以用来方便地操作和提取 HTML 内容。\n剩下的代码看方法名称也很好理解它是做什么的\ntoken与key 找到token与key的所在 我们用相同的办法，通过搜索框查找token的所在地，发现，这个信息同样存在于translator请求响应中：\n如果你仔细一点，你会发现，token前面那串数字，就是我们下一个要找的key！真是得来全不费工夫，剩下的两个数据被我们一次性找到了，接下来就是获取它们。\n代码实现 1 2 3 4 pattern = r\u0026#39;var params_AbusePreventionHelper = \\[(\\d+),\u0026#34;([^\u0026#34;]+)\u0026#34;,\\d+\\];\u0026#39; token = re.findall(pattern, html) print(\u0026#34;key:\u0026#34;+token[0][0]) print(\u0026#34;token:\u0026#34;+token[0][1]) 同样地，我们使用正则表达式，查找var params_AbusePreventionHelper后面的两个数据，放在token列表中。\n小结 至此，我们找到了我们所需的全部数据，接下来只需要将IG与IID填进URL中，将token与key填进表单中，就可发送完整的请求，伪装成正常的浏览器请求了。\n请求与获取相应 代码实现 1 2 3 4 5 6 7 8 9 10 11 url = \u0026#34;https://cn.bing.com/ttranslatev3?isVertical=1\u0026amp;\u0026amp;IG=\u0026#34;+ig+\u0026#34;\u0026amp;IID=\u0026#34;+data_iid print(url) header = {\u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} data = {\u0026#34;fromLang\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;en\u0026#34;,\u0026#34;token\u0026#34;:token[0][1],\u0026#34;key\u0026#34;:token[0][0],\u0026#34;text\u0026#34;:\u0026#34;今天的天气\u0026#34;,\u0026#34;tryFetchingGenderDebiasedTranslations\u0026#34;:\u0026#34;true\u0026#34;} print(data) data = urllib.parse.urlencode(data).encode(\u0026#34;utf-8\u0026#34;) req = urllib.request.Request(url, data, headers=header) response = urllib.request.urlopen(req) html = response.read().decode(\u0026#34;utf-8\u0026#34;) target = json.loads(html) print(target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;]) 根据上一篇文章的经验，以及本文上述的分析：\nURL需要根据上文所获取的IG与IID进行动态变换 data数据，将我们上面获取的token与key分别放入字典中 对数据进行UTF-8编码转换格式 发送请求 获取响应并进行UTF-8解码 转换JSON格式 获取数据 如果将进行UTF-8解码后的数据完整打印出来，将会是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [ { \u0026#34;translations\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Today\u0026#39;s weather\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;en\u0026#34;, \u0026#34;sentLen\u0026#34;:{ \u0026#34;srcSentLen\u0026#34;:[ 5 ], \u0026#34;transSentLen\u0026#34;:[ 15 ] } } ], \u0026#34;detectedLanguage\u0026#34;:{ \u0026#34;language\u0026#34;:\u0026#34;zh-Hans\u0026#34; } }, { \u0026#34;inputTransliteration\u0026#34;:\u0026#34;jīntiān de tiānqì\u0026#34; } ] 我们要的就是translations列表下的第一个字典中text对应的value\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from csv import Error from email.policy import HTTP from tkinter import E from urllib.error import URLError import requests import re from bs4 import BeautifulSoup from urllib import response import urllib.request import json class Translation: def __init__(self,content): self.translating(content) def translating(content,lfrom,lto): if content == \u0026#34;\u0026#34;: return \u0026#34;请输入内容\u0026#34; langfrom = {\u0026#34;自动检测\u0026#34;:\u0026#34;auto-detect\u0026#34;,\u0026#34;中文\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;English\u0026#34;:\u0026#34;en\u0026#34;} langto = {\u0026#34;中文\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;English\u0026#34;:\u0026#34;en\u0026#34;} url = \u0026#34;https://cn.bing.com/translator?ref=TThis\u0026amp;text=\u0026amp;from=zh-Hans\u0026amp;to=en\u0026#34; header = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} try: response = requests.get(url,headers=header,data={},timeout=5) except Exception as e: print(f\u0026#34;There are something wrong with the network: {e}\u0026#34;) return \u0026#34;website is not reachable\u0026#34; html = response.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) dev_element = soup.find(\u0026#34;div\u0026#34;, id = \u0026#34;tta_outGDCont\u0026#34;) data_iid = dev_element.attrs[\u0026#34;data-iid\u0026#34;] print(\u0026#34;data_iid:\u0026#34;+data_iid) ig = re.search(r\u0026#39;IG:\u0026#34;(\\w+)\u0026#34;\u0026#39;,html).group(1) print(\u0026#34;IG:\u0026#34;+ig) pattern = r\u0026#39;var params_AbusePreventionHelper = \\[(\\d+),\u0026#34;([^\u0026#34;]+)\u0026#34;,\\d+\\];\u0026#39; token = re.findall(pattern, html) print(\u0026#34;key:\u0026#34;+token[0][0]) print(\u0026#34;token:\u0026#34;+token[0][1]) url = \u0026#34;https://cn.bing.com/ttranslatev3?isVertical=1\u0026amp;\u0026amp;IG=\u0026#34;+ig+\u0026#34;\u0026amp;IID=\u0026#34;+data_iid print(url) header = {\u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} data = {\u0026#34;fromLang\u0026#34;:langfrom[lfrom],\u0026#34;to\u0026#34;:langto[lto],\u0026#34;token\u0026#34;:token[0][1],\u0026#34;key\u0026#34;:token[0][0],\u0026#34;text\u0026#34;:content,\u0026#34;tryFetchingGenderDebiasedTranslations\u0026#34;:\u0026#34;true\u0026#34;} print(data) data = urllib.parse.urlencode(data).encode(\u0026#34;utf-8\u0026#34;) try: req = urllib.request.Request(url, data, headers=header) response = urllib.request.urlopen(req) html = response.read().decode(\u0026#34;utf-8\u0026#34;) target = json.loads(html) except Exception as e: print(f\u0026#39;There are something wrong with the network: {e}\u0026#39;) return \u0026#34;website is not reachable\u0026#34; try: print(\u0026#34;translations:\u0026#34;+target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;]) except KeyError: print(target) return \u0026#34;something was wrong\u0026#34; return target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;] 结语 这次，我们完成了对微软翻译的完整爬虫，且可以完美多次长时间地运行，这个脚本功能已经完善，只是还没有嵌入到GUI程序中，下一篇文章，我们将会把这个脚本整理一下，放到脚本工具包中供翻译器调用，且会加装一些网络状况的判断。\n如果你看到这里，说明你又变强了！希望你变得更强，感谢你的观看，共同进步！\n","date":"2024-11-08T12:02:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B9%9D/webspider_hu11857342585609557978.jpg","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B9%9D/","title":"基于PyQt开发的脚本集合包（九）"},{"content":"前言 本文虽然被归类于PyQt开发实战，但实际上并没有关于PyQt的相关知识，这篇文章着重基于上篇文章，讲述笔者在开发翻译器时如何做爬取微软翻译网站时的分析，如何获取到网站所需要的信息。这其中也是夹杂了许多笔者个人的猜想与运气才碰出来的，笔者对爬虫也没有做更深的学习，只有一些粗浅的理解，并结合这个项目一点一点摸出来的，可能有更专业的工具与更成体系的知识架构，笔者也要去学习，希望这篇文章对读者能起到一些帮助和启发。\n本文从笔者第一次爬取开始讲起，第一次失败了，总结了失败的经验，第二次才爬取成功。\n第一次爬取微软翻译 分析 在笔者进行爬虫的时候，首先先打开了浏览器自带的开发者工具查看网络数据，看看在翻译时客户端与服务器之间做了哪些交流\n在排查的过程中，发现有一个名称叫做ttranslate...的包引起了笔者的注意，点进去发现这其中确实携带了笔者要翻译的信息\n从上图中可以看到，包的负载中的表单数据中有一项Text，携带的数据刚好是我们输入的翻译内容你好。\n打开预览可以看到更详细的信息\n在这里可以发现：\n这里有我们翻译之前的语种，即：zh-Hans，简体中文 翻译后的文本，保存在一个名为translations的数据中，text:Hello，这个数据就是我们要获取的数据，其实这就是对于翻译请求的响应，打开响应界面也是这一串信息 响应界面如下：\n所以，本质上，笔者就是想要获得对于这个请求的响应，因此笔者的方法是模仿这个包的请求，读取它的响应，从而获得对应的翻译数据。\n实践 因此根据爬虫的流程，笔者先获取了ttranslate的请求URL，即：\nhttps://cn.bing.com/ttranslatev3?isVertical=1\u0026\u0026IG=94BF74DDDBA34ECB8B2CFB8D7960E4F9\u0026IID=translator.5025\n再获取了请求标头中的User-Agent，即：\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0\n如下图所示：\n获取URL是为了获取请求的目的地，获取User-Agent是为了让服务器认为我们是一个人，而不是脚本在自动操作（虽然真的是一个脚本），现在这两者已经获取，我们这段信息就有了身份。（虽然请求标头中还有许多其它的信息，但笔者也没搞懂有什么作用，索性也就没管）\n接下来这既然是一个请求，那么我们就需要携带需要请求的消息，消息的格式是什么呢？在负载中可以找到，负载就是请求的内容，如下图所示：\n显而易见的是，表单数据中携带了我们待翻译内容的语种，翻译结果的语种，以及翻译的数据。我们需要将这些信息放进我们的请求中。\n信息收集完毕，开始编写代码（下面展示代码主题，读者需要注意这其中还调用了第三方关于爬虫的库，如报错，请pip install 响应的第三方库）\n1 2 3 4 5 6 7 8 9 url = \u0026#34;https://cn.bing.com/ttranslatev3?isVertical=1\u0026amp;\u0026amp;IG=94BF74DDDBA34ECB8B2CFB8D7960E4F9\u0026amp;IID=translator.5025\u0026#34; header = {\u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} data = {\u0026#34;fromLang\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;en\u0026#34;,\u0026#34;text\u0026#34;:text} data = urllib.parse.urlencode(data).encode(\u0026#34;utf-8\u0026#34;) req = urllib.request.Request(url, data, headers=header) response = urllib.request.urlopen(req) html = response.read().decode(\u0026#34;utf-8\u0026#34;) target = json.loads(html) print(target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;]) 以下，我们来逐行分析代码：\n将刚刚得到的URL存放起来 将user-agent也存放起来，存放在header字典中 将我们请求的数据：翻译前的语种，翻译后的语种，文本也存放起来，存放在data字典中 将data进行utf-8加密，转换成响应的url请求格式 使用Request方法发送请求，参数为url,data,header 使用urlopen方法获取响应 将响应解码 将JSON格式的字符串解析成python对象，比如字典，列表等 获取这个target中关于translation列表下的字典的text对应的值 总结 以上，是笔者的第一次爬虫，一开始爬取的时候使用正常，可以正常的使用，但没过多久，翻译器无法使用，无故闪退，笔者开始debug，发现已经无法通过这个url发送请求了。\n笔者开始整理，经过多次请求尝试和实验，发现url存在一些端倪：\nhttps://cn.bing.com/ttranslatev3?isVertical=1\u0026\u0026IG=94BF74DDDBA34ECB8B2CFB8D7960E4F9\u0026IID=translator.5025\n我们再来看一下这个URL，可以发现，这URL本身就携带了一些信息，IG与IID，这两个数据在每次会话结束后，都会发生变化，也就是说，当一个会话结束后，笔者所记录的IG与IID就失效了，无法访问，因此，这一次爬虫并不成功，还需要继续改进，获取每次访问微软翻译时的IG和IID数据。\n结语 总的来说，本文只是笔者在爬虫方向上的一次探索与学习，这是一次失败的尝试，不过可以看出，笔者在学习上的思路，笔者在学习时，喜欢在实践中发现问题并解决问题，因为理论与实践总是存在一定的差距，现实世界总是复杂且多变的。在实践中，你总会发现一些与理论有偏差或者相悖的地方，让你陷入迷茫，但是在实践中，你不会没有一点头绪，相反，在实践中，你有太多太多的方向去验证问题的本质，有时候往往是方向太多，你无法确定哪条路才能通向正确，你害怕做了无用功，害怕走错了方向，因此迟迟不敢动手，才导致了自己的踌躇不前。在现实世界中抽丝剥茧，也是一种学习，虽然笔者在这里也走错了路，离成功还有一段距离，但是走到这里，让笔者学会了如何看网络包，分析请求和响应，学会调用request库，以及最重要的找到了正确的道路，即：接下来，我们要想办法找到每一次IG和IID这两个数据如何变，在哪里变，如何获取到那个存放这两个数据的包。致敬技术，希望你变得更强！\n","date":"2024-11-07T19:16:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AB/webspider_hu11857342585609557978.jpg","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AB/","title":"基于PyQt开发的脚本集合包（八）"},{"content":"前言 上期文章我们讲了如何去实现一个UTF-8编码的转换器的构造以及代码实现。本期我们实现脚本集合包的第二个脚本（功能）：翻译器。目前，该翻译一起支持中译英，英译中，或自动检测翻译。翻译功能的实现本质上是通过爬虫技术去爬取网页实现的翻译功能，因此翻译功能需要联网才可进行。因此，在设计之初需要注意的是（虽然笔者并不是在设计之初就意识到会有这么多问题）：如何爬取一个网站，如何将需要翻译的内容上传给网站，是否需要判断当前状态是否联网，如何判断是否联网。如果处于断网状态如何处理\u0026hellip;\u0026hellip;接下来两到三篇文章会详细讲述这些问题如何解决。\n翻译器的UI布局 首先先看翻译器的UI布局\n可以看到这个翻译器的主要框架分为上中下三个部分，垂直分布，因此，主布局是一个垂直布局，三个部分分别是：翻译语言选择，翻译文本框，快速翻译三个部分。\n翻译语言选择：该部分由从左到右三个部分组成，水平布局，第一个下拉列表可选取待翻译语言的语种，包括：自动检测、中文、English三种，中间的组件是一个带有图标的按钮，可以转换左右下拉列表的语种，右边的下拉列表可选取翻译后的语种，包括：English、中文。 翻译文本框：该部分由从左到右三个部分组成，水平布局，第一个文本框是可读写文本框，可输入待翻译的内容，中间是一个按钮，点击按钮则开始翻译，右边文本框是一个只读文本框，在点击翻译按钮后，若翻译成功则会在该文本框中显示翻译后的内容。 快速翻译：快速翻译一个ListView，列表组件，其中存储了一个字典，显示对应的key，点击后会自动访问对应key的value，将value显示出来，无需联网，用于快速反应一些常用常翻译的内容。 代码解释 创建布局对象 根据上述UI的设计，我们可以创建对应的layout对象，并将子布局一次添加进主布局，主布局设置为widget的布局\n1 2 3 4 5 6 7 8 9 # create a horizontal layout layout = QVBoxLayout() # 主布局 langlayout = QHBoxLayout() # 翻译语言选择的布局 hlayout = QHBoxLayout() # 翻译文本框的布局 listlayout = QVBoxLayout() # 快速翻译列表的布局 layout.addLayout(langlayout) # 将三个子布局添加进主布局 layout.addLayout(hlayout) # 将三个子布局添加进主布局 layout.addLayout(listlayout) # 将三个子布局添加进主布局 self.setLayout(layout) # 将layout设置为该翻译器widget的布局 翻译语言的选择与切换UI设计 该部分由两个comboBox（下拉列表）和一个PushButton（按钮）组成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # lang layout self.langfromcb = QComboBox(self) # 创建输入语言的下拉列表 self.langfromcb.addItem(\u0026#34;自动检测\u0026#34;) # 往下拉列表中添加元素 self.langfromcb.addItem(\u0026#34;中文\u0026#34;) self.langfromcb.addItem(\u0026#34;English\u0026#34;) self.langfromcb.setCurrentIndex(1) # 将下拉列表中的第二个元素（0为第一个）设置为默认选项 self.langtocb = QComboBox(self) # 创建输出语言的下拉列表 self.langtocb.addItems([\u0026#39;中文\u0026#39;,\u0026#39;English\u0026#39;]) # 往下拉列表中添加元素 self.langtocb.setCurrentIndex(1) # 将下拉列表中的第二个元素设置为默认选项 self.exchangebtn = QPushButton(self) # 创建交换语种的按钮 pixmap = QPixmap(\u0026#34;_internal/res/img/exchange.ico\u0026#34;) # 将图标添加进变量 self.exchangebtn.setIcon(QIcon(pixmap)) # 为按钮设置图标 self.exchangebtn.setIconSize(self.exchangebtn.sizeHint()) # 设置图标为自适应按钮大小 self.exchangebtn.setToolTip(\u0026#34;交换语言\u0026#34;) # 为按钮设置提示泡泡 self.exchangebtn.clicked.connect(self.tranasexchange) # 给按钮点击状态连接事件方法，该方法将调转输入与输出语种 langlayout.addWidget(self.langfromcb) # 将三个组件都加入到第一个子布局中 langlayout.addWidget(self.exchangebtn) langlayout.addWidget(self.langtocb) 在这一段代码值得注意的是：\n这段代码展示了之前文章未出现的组件，即下拉列表（ComboBox）。\n下拉列表有两种添加元素的方法，addItem()与addItems()，一个参数为单个元素，一个参数为list，可同时输入多个元素。\nsetCurrentIndex()方法可设置下拉列表的首选项，比如：下拉列表的顺序为：自动检测，中文，English，我想让中文成为默认选项，则可使用setCurrentIndex(1)来使得中文成为默认选项，因为python是从0开始算起的。\n按钮可以添加图标，这个图标的地址开头是__internal，为什么使用这个作为最高级目录，请看往期内容基于PyQt开发的脚本集合包（三）第三节初始化应用程序部分，在窗口标签部分讲过相关内容。\n按键的提示泡泡长这样，当鼠标放在按钮上，会弹出一个小框描述该按键的功能。\n翻译文本框的UI设计 该部分是由两个文本框与一个按键组成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # input editor self.editor = QTextEdit(self) # 创建输入文本框 self.editor.setPlaceholderText(\u0026#34;翻译内容\u0026#34;) # 设置文本框的背景内容 hlayout.addWidget(self.editor) # 将输入文本框添加到子布局中 TextEditStyle(self.editor) # 修改文本框的样式，作者创建的方法，非第三方库调用 # translation button self.button = QPushButton(\u0026#34;翻译\u0026#34;,self) # 创建翻译按钮 btnReleaseStyleA(self.button) # 修改按钮的样式，作者创建的方法，非第三方库调用 self.button.clicked.connect(self.translating) # 按钮点击状态连接到translating事件方法 hlayout.addWidget(self.button) # 将按钮添加到子布局中 # output edit self.textedit = QTextEdit(self) # 创建输出文本框 self.textedit.setPlaceholderText(\u0026#34;翻译结果\u0026#34;) # 设置文本框的背景内容 self.textedit.setReadOnly(True) # 设置文本框为只读 hlayout.addWidget(self.textedit) # 将文本框添加到子布局中 TextEditStyle(self.textedit) # 修改文本框的样式，作者创建的方法，非第三方库调用 这段代码并没有什么需要特殊注意的地方，在之前的文章中我们已经用过多次了\n快速翻译列表UI设计 1 2 3 4 5 6 7 8 9 10 11 12 # list layout self.workdist = {\u0026#39;快进\u0026#39;:\u0026#39;forward\u0026#39;,\u0026#39;后退\u0026#39;:\u0026#39;backward\u0026#39;,\u0026#39;暂停\u0026#39;:\u0026#39;pause\u0026#39;,\u0026#39;停止\u0026#39;:\u0026#39;stop\u0026#39;, \u0026#39;播放\u0026#39;:\u0026#39;play\u0026#39;} self.model = QStandardItemModel(0, 1) # 创建一个模型类，0行1列，即没有元素 self.view = QListView(self) # 设置一个ListView对象 self.view.setModel(self.model) # 设置ListView对象的模型为上面创建的模型 for i in self.workdist.keys(): # 做一个for循环，循环从workdist中读取key item = QStandardItem(i) # 按顺序，将key设置为模型元素对象 self.model.appendRow(item) # 将对象添加到模型中 ListViewStyle(self.view) # 修改ListView的样式，作者创建的方法，非第三方库调用 listlayout.addWidget(self.view) # 将ListView对象添加到子布局中 self.view.clicked.connect(self.modelselected) # 将listview的点击状态连接到事件方法modelselected 这里新知识比较多，尤其是出现了一个陌生的控件QListView与一个模型类QStandardItemModel\nQStandardItemModel的定义\n在 PyQt 中，QStandardItemModel 是一个常用的模型类，它提供了一种标准的方式来存储和管理数据，尤其是用于与视图类（如 QListView、QTreeView 和 QTableView）配合使用。QStandardItemModel 是一种基于项（Item）模型的数据结构，它通过 QStandardItem 类来表示每个数据项。\nQStandardItemModel 主要特点：\n基于项的模型：它使用 QStandardItem 来表示数据的每一项，QStandardItem 是存储数据和管理项状态的对象。 支持树形和表格数据：通过 QStandardItemModel 可以管理数据，支持表格和树形结构。它可以通过层次结构来组织数据。 与视图（View）绑定：QStandardItemModel 与 PyQt 中的视图类（如 QListView、QTreeView、QTableView）一起使用，模型控制数据，而视图负责数据的显示和交互。 QListView控件与QComboBox功能相似，但是用途，行为和样式差别较大，直接问大模型会给你长长的一条差别，但在这里，使用QListView的原因是它好看，可自定义样式，且不会收束成一个单个元素，而是完整地展示所有元素。\n布局代码解释完了，接下来我们看一下实现交互功能的代码：\ntranasexchange 1 2 3 4 5 6 7 def tranasexchange(self): cba = self.langfromcb.currentText() cbb = self.langtocb.currentText() if cba == \u0026#34;自动检测\u0026#34;: cba = \u0026#34;English\u0026#34; self.langfromcb.setCurrentText(cbb) self.langtocb.setCurrentText(cba) 这个代码逻辑很简单实际上就是一个获取两个QComboBox的当前选择内容，然后交换它，因为langto并没有自动检测这一选项，所以当langfrom选择的是自动检测，则切换成English。\ntranslating 1 2 3 4 5 6 7 8 def translating(self): print(self.langfromcb.currentText(),\u0026#34; to \u0026#34;,self.langtocb.currentText()) text = self.editor.toPlainText() tran = Translation.translating(text,self.langfromcb.currentText(),self.langtocb.currentText()) if tran == \u0026#34;website is not reachable\u0026#34;: MsgClass().show_HTTP_error(\u0026#34;Website is not reachable\u0026#34;) else: self.textedit.setText(tran) 首先将从什么语种翻译到什么语种打印到log面板上 text变量获取当前输入文本框中的文本内容 将text中的文本内容，当前选择的两个语种，一共3个参数传入Translation对象的translating方法中，该方法才是真正实现翻译功能的方法，该方法会返回一个字符串，tran获取这个字符串 该if的其实就是回应我们开头提出的问题：“需不需要判断网络问题”以及“如果网络异常该怎么办”，在一开始，笔者并没有处理这个异常，直到有一次笔者挂了clash访问GitHub时，无法访问翻译网站，结果导致程序闪退，所以，必须要判断网络问题，才做了这个if判断来抛出异常，使脚本在遇到网络问题时依然能够正常运行。 MsgClass是笔者写的一个消息处理类，主要功能是获取文本，制作一个弹窗，弹窗内容就是获取到的文本，在这里是Website is not reachable 如果网络没有问题，则不会将获取的文本输出到输出文本框中 当然这个网络异常逻辑设计并不完美，因为有可能翻译的内容恰恰是website is not reachable，这样也会导致UI这一部分误以为是网络异常，从而弹窗警告。更优解时返回两个变量，一个变量是翻译内容，一个变量是网站访问情况。if检测网站访问情况，如果非200，如404，则抛出弹窗警告。 modelselected 1 2 3 4 def modelselected(self): print(self.view.currentIndex().data(),\u0026#39;to\u0026#39;,self.workdist[self.view.currentIndex().data()]) self.editor.setText(self.view.currentIndex().data()) self.textedit.setText(self.workdist[self.view.currentIndex().data()]) 如果是点击快速翻译中的某一项，则无需点击翻译按钮，直接完成翻译\n在log面板上打印当前选择的元素以及元素所对应的value（元素为字典中的key） 将元素设置为输入文本框的内容 将元素对应的value设置为输出文本框的内容 本文要点 翻译器的主要UI布局其实是模仿目前市面上大多数的翻译器设计的，主要是模仿微软翻译，即：搜索 Microsoft Translator - 从英语翻译到中文 (简体)。其实，该翻译器的实现，主要也是爬取了微软翻译，翻译器模仿成用户，向微软翻译发送翻译文本，并获取返回的response，拿到翻译后的结果。之所以不爬取有道翻译，是因为有道翻译对爬虫限制很高，现在甚至无法打开开发者工具（如果在有道翻译页面强行打开开发者工具，会导致闪退该页面）。 在这个页面的UI设计中，我们加入了许多新玩意儿，比如ListView，模型类QStandardItemModel，QComboBox，等等有趣的东西，想使用但却没有实际例子模仿的小伙伴可以借鉴参考。 在本文中我们回答了开头的五个问题中的两个，“是否需要判断当前状态是否联网”答案是：需要判断当前状态是否联网，如果不加以判断，当处于断网时，爬虫无法正常爬取网页，会抛出Error或Exception，如果处理，则会导致程序闪退。 “如果处于断网状态如何处理”，答案是，当判断出断网状态时，会抛出弹窗警告，弹窗警告的设计是笔者自做，后续系列更新会介绍。 ","date":"2024-11-07T15:33:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%83/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%83/","title":"基于PyQt开发的脚本集合包（七）"},{"content":"方法在工程中的位置 这一小节需要结合前面的基于PyQt开发的脚本集合包（二）内容来看，在那一篇文章中，我们讲到，我们讲主界面，功能UI界面，以及实现功能本身的方法分别放在了不同的地方以方便我们维护，此方法属于功能的实现，因此与其它脚本功能一同放在了tools目录下，如果要调用该功能，则需要使用import导入模块。\n代码解释 convertor模块中并没有类，只有一个方法，即convertor方法，它接受一个字符串参数，并将字符串进行编码，处理成UTF-8格式，输出十六进制数以及十六进制数的个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def convertor(s): res = \u0026#39;\u0026#39; # 将字符串s编码为UTF-8格式的字节串 strlen = len(s) for i in range(strlen): # 将字节串转换为十六进制表示，同时移除b\u0026#39;\u0026#39;标记并替换\\\\x为0x hexstr = \u0026#39;\u0026#39;.join(f\u0026#39;{byte:02x}\u0026#39; for byte in s[i].encode(\u0026#34;UTF-8\u0026#34;)) hexstr = hexstr.upper() # 可选：转换为大写 # 添加空格使得输出更易于阅读 hexstr_space = \u0026#39;, 0x\u0026#39;.join(hexstr[i:i + 2] for i in range(0, len(hexstr), 2)) hexstr_space = \u0026#39;0x\u0026#39;+hexstr_space res = res + hexstr_space + \u0026#39;, \u0026#39; res = res[:-2] print(res) return res,res.count(\u0026#39;0x\u0026#39;) 以下逐行解释代码：\n初始化res字符串变量， 获取传入的参数s字符串的长度，并传给strlen for循环遍历字符串中的每一个字符 s[i].encode(\u0026quot;UTF-8\u0026quot;)将字符编码为UTF-8字节串 for byte in ...是一个生成器表达式，它遍历编码后的字节串，每个byte表示UTF-8编码中的每一个字节 f'{byte:02x}'将每个字节转换为两位的十六进制字符串，0表示如果十六进制不足两位，则以0补足，2表示宽度位两位，x表示以十六进制格式输出，比如：如果byte的值为255，则会生成\u0026rsquo;ff\u0026rsquo;，如果byte的值为7，则会生成'07' ''.join(...)，join方法将生成器表达式的所有结果连成一个字符串，即格式化操作，例如：一个字符编码为b'\\xe4\\xb8\\xad'，经过格式化后将变成'e4b8ad' upper方法将输出的字符串中所有小写转换成大写 又一个join方法，将hexstr一个字符一个字符拆开，每个两个字符中间便加入, 0x，经过上一个join方法，这次经过格式化操作后，e4b8ad将会变成E4, 0xB8, 0xAD, 0x 在字符串最前面加上0x，变成：0xE4, 0xB8, 0xAD, 0x 删除最后3个字符（-1是最后一个，-2是倒数第二个，但是[]读内容的规则：前面读，后面不读，也就是虽然是最后一位是倒数第二，但实际上倒数第二不读，只读到倒数第三） 打印res结果 返回结果以及0x的计数（通过计算0x来计算有多少个十六进制数） 本文要点 本文中展示了，方法在工程中的位置，以及如何在工作区UI对象中导入该模块 详细解释了convertor方法如何实现字符串转UTF-8格式 其中有许多用法值得我们详细学习，比如join方法的使用，f'{byte:02x}'将每个字节转换成十六进制数，upper方法的使用，[]的读取范围的规则等 ","date":"2024-11-04T21:36:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AD/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AD/","title":"基于PyQt开发的脚本集合包（六）"},{"content":"UTF-8编码器 UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无需或只进行少部分修改后，便可继续使用。\n比如：在蓝牙领域中，主机与从机自身携带的一些信息如蓝牙名称等，就是由UTF-8编码成十六进制字符串后进行传输，在进行蓝牙开发时，就会经常用到UTF-8编码，因此作者也是自做了一个UTF-8编码器集成到自己的脚本工具包中方便使用。\nUI设计 首先看成品，这个UTF-8编码器的工作区一共有几个部分组成：\n编码内容：是读写文本框，在此文本框中，可输入数字，符号，中文，英文等各种可被UTF-8编码的字符串，该文本框为默认形式，即可读可写。 编码结果：是只读文本框，在此文本框中，会显示编码完成后的结果，即十六进制数字组，例如：PyQt5编码后，编码结果会显示0x50, 0x79, 0x51, 0x74, 0x35，此文本框只允许读，复制等操作，不允许改写其中的内容。 字符数：也是只读文本框，在此文本框中，会显示编码结果的字符数，例如：PyQt5编码后，编码结果为5个十六进制数，字符数就为5，值得注意的是，字符数并不是与编码内容的字符串的长度一定相等，如果你的编码内容中含有中文，1个中文则会有3个十六进制数表示。 按钮：按钮连接了一个方法，在按钮被点击时触发方法，读取编码内容中的字符串，进行处理，然后再将结果输出再编码结果与字符数中。 功能UI的存放目录 在PyQt的第二篇文章（基于PyQt开发的脚本集合包（二））中我们讲到，实现不同功能的UI类是存放在一个相同的目录下，这样方便我们维护，也正是因为功能区的UI放在一个名为Classes的目录下，PrimeWindow不在该目录下。\n因此PrimeWindow想要调用，实现UTF-8编码器的UI界面，需要使用import。\n这表示：导入Classes目录下的ConvertorClass模块，并重命名为ConvertorClass。\n可以回到第四篇文章基于PyQt开发的脚本集合包（四）查看PrimeWindow如何使用这个模块的（在create_stack方法中）。\n代码解释 def __init__ 先看初始化代码，也是这个UTF-8对象的入口（这个UTF-8编码器是写在另一个目录下的一个类，上一篇文章中讲到的PrimeWindow就是调用了这个UTF-8编码器类，创建了一个编码器对象，这个类继承于Qwidget，因此这个编码器对象可以被看作是一个Qwidget来使用。）\nPS：如果对Qwidget这个概念有些模糊的话请看这里（如果熟悉了PyQt的基本知识请继续往下看），Qwidget本质上是一个组件，和按钮，文本框一样，只不过这个组件中可以放其它的组件，你可以把Qwidget想象成一个容器，这个容器装了许多东西，打包起来，然后再放到另一个容器中，像套娃一样。我们这里就是将上面说的三个文本框与按钮排列好放在一个名为Convertor的Qwidget容器中，然后打包成一个类，可供其它更大的Qwidget（比如PrimeWindow）调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def __init__(self): super().__init__() self.layout = QVBoxLayout() # 设置编码器的主布局为垂直布局VBox self.inputlayout = QHBoxLayout() # 设置水平的输入布局，即编码内容（由“编码内容”这四个字的标签与文本框水平布局构成） self.outputlayout = QHBoxLayout() # 设置水平的输出布局，即编码结果 self.countlayout = QHBoxLayout() # 设置水平的计数布局，即字符数 self.layout.addLayout(self.inputlayout) # 将三个布局以此添加进主布局中 self.layout.addLayout(self.outputlayout) # 依次添加会按顺序从上往下排列 self.layout.addLayout(self.countlayout) # 总的来说是三个小布局垂直分布，每个小布局中的两个组件水平分布 self.inputlable = QLabel(\u0026#34;编码内容\u0026#34;,self) # 创建“编码内容”这个四个字的标签 self.inputlayout.addWidget(self.inputlable) # 加入到输入布局中，从左到右排列 self.inputedior = QTextEdit(\u0026#34;输入文本\u0026#34;,self) # 创建输入文本框 TextEditStyle(self.inputedior) # 设置文本框的样式，该方法为作者自写，非第三方库调用 self.inputlayout.addWidget(self.inputedior) # 将文本框添加到输入布局中 convertbtn = QPushButton(\u0026#34;UTF-8编码\u0026#34;,self) # 创建按钮，按钮上的文字为“UTF-8编码” btnReleaseStyleA(convertbtn) # 设置按钮弹起状态的样式，该方法为作者自写，非第三方库调用 convertbtn.clicked.connect(self.converting) # 将按钮的点击状态连接到converting方法上，一旦检测到按钮被点击，则调用该方法 convertbtn.clicked.connect(self.counting) # 同理，将按钮的点击状态连接到counting方法上，一旦检查测到按钮被点击，则调用该方法 self.layout.addWidget(convertbtn) # 将按钮添加到主布局中，因为上面已经添加了三个小布局，因此按钮在布局最下方 self.outputlable = QLabel(\u0026#34;编码结果\u0026#34;,self) # 创建“编码结果”这四个字的标签 self.outputlayout.addWidget(self.outputlable) # 添加到输出布局中 self.outputedit = QTextEdit(\u0026#34;输出文本\u0026#34;,self) # 创建输出文本框 self.outputedit.setReadOnly(True) # 将文本框设置为只读模式 TextEditStyle(self.outputedit) # 设置文本框的样式，作者自写，非第三方库嗲用 self.outputlayout.addWidget(self.outputedit) # 将文本框添加到输出布局中 self.countlable = QLabel(\u0026#34;字符数：\u0026#34;,self) # 与上相同 self.countlayout.addWidget(self.countlable) self.countedit = QTextEdit(\u0026#34;字符数\u0026#34;,self) self.countedit.setReadOnly(True) TextEditStyle(self.countedit) self.countlayout.addWidget(self.countedit) # ********************** 已删，不好看 ********************** # 删除edit边框 # self.countedit.setFrameShape(QFrame.NoFrame) # # 删除edit背景 # self.countedit.setStyleSheet(\u0026#34;background-color: transparent;\u0026#34;) # ********************** 已删，不好看 ********************** self.setLayout(self.layout) # 将主布局设置为Qwidget的布局 def converting converting方法是主要实现UTF-8编码的方法的入口，它并不直接完成该任务，而是获取输入文本框的数据，然后传参给真正的编码方法。\n1 2 3 4 def converting(self): self.text = self.inputedior.toPlainText() self.res,self.count = convertor(self.text) self.outputedit.setText(self.res) 下面逐行解释代码：\n从输入文本框中获取文本内容，在PyQt中，toPlainText是QTextRdit控件的一个方法，用于获取文本框中的所有内容，并返回一个字符串，这与toHtml()不同，后者返回的是HTML格式的文本。 调用convertor这个外部方法，传入的参数就是文本框的内容（字符串），并获取返回结果（两个参数，一个是结果，一个是字符串数）。 将结果设置为输出框的文本。 值得注意的是，这里count变量被形容为self，这也就是说，在同一实例（对象）中，实例中的各个方法（被传入self），都可以调用这个count变量。\ndef counting counting方法的作用就是将上面得到的count设置为计数文本框中的内容。\n1 2 def counting(self): self.countedit.setText(str(self.count)) 为什么要舍近求远做这样一个操作呢，是为了提醒我：\n一个按钮的某一状态连接多个事件是可行的。 使用setText方法对某一文本框填入数据时，参数必须为字符串，如果非字符串的参数，必须使用str()方法转为字符串。 更深入了解self，可支持某一变量在其它方法间共用。 本文要点 本文中展示了，之前文章中铺垫的，功能区的用法。本质上就是功能区是PrimeWindow这个大的容器（Qwidget）专门空出来的一块地方，可以用来放其它的小的容器（Qwidget），其它的小的容器以对象（实例）的方式被创建，然后存放在抽屉（stack）中，这样我们在切换抽屉时，就是在切换小的容器，实现了大容器不变的情况下，大容器中的某一块区域可以灵活变化。 __init__方法是这个对象的入口（创建时被首先调用的函数），当对象被创建时，则会自动地进行初始化，完成整个编译器UI的创建和布局。初始化方法的代码解释写在了代码块中，因为代码较长，如果写出来的话篇幅太大，但是不写的话在CSDN和个人博客中都比较难阅读（无法自动换行），因此建议大家复制下来，贴在VScode中或自己的Typora中看，这样方便一点。 按钮连接的方法是使用xxxbtn.clicked.connect(xxxfunction)，该方法旨在某按键被click（点击）时，调用xxxfunction方法，且可以连接多个方法。 converting方法实际上是一个处理API的方法，负责传参与接收结果，convertor方法在下一篇文章中会介绍。 counting方法可以被整合到converting方法中，不过整个项目是作者的一个学习过程与心得，这样写是为了方便展示一些特性。 如果本文对你有所帮助，请记得给作者的CSDN点赞收藏QAQ，多多逛逛和订阅作者的个人博客，有什么问题或错误请联系作者的CSDN或发送到邮件中，祝大家生活愉快，变得更强！ ","date":"2024-11-04T19:29:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%94/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%94/","title":"基于PyQt开发的脚本集合包（五）"},{"content":"前言 作者的编程环境为VScode，工作时常使用VScode打开整个工程文件夹。如果先打开VScode再从VScode中选择文件夹打开效率太慢，作者一般使用的方式是右键文件夹，直接选择\u0026quot;通过code打开文件夹\u0026quot;，但某天，作者同往常一样工作时发现快捷键不起效，桌面的快捷方式也变成了无法使用的状态。\n通过设置索引回快捷方式的目标和起始位置，发现找不到对应的code.exe文件。这说明可能有以下几种情况：\nVScode在我不知情的情况下被卸载了 VScode中code.exe执行文件被删了 VScode出于某种情况（可能是更新），将执行文件改了名字或移动了位置 更新VScode快捷方式 通过查找VScode的目录，发现code.exe文件从原本的Microsoft VS Code目录下移动到Microsoft VS Code\\_目录下，多了一级目录，暂不清楚什么原因，因此桌面快捷方式不起作用，只需要将快捷方式的目标和起始位置做一下修改，桌面的快捷方式就可以重新使用了。\n右键使用VScode打开文件夹 重装软件 重装软件确实是一个简单且有效的方法，如果你的VScode比较干净的话。但如果你安装了许多插件且配置了多个Python的虚拟环境（那可是一个大工程），那么放弃现在的VScode对你来说可能是一个噩梦。如果你是此类人，我推荐你使用下面的方法。\n修改注册表 使用win + R打开运行，输入regedit打开注册表。\n配置：右键使用vscode打开文件 你可以直接在左侧目录树下找到HKEY_CLASSES_ROOT\\*\\shell，也可以在上方地址栏中输入，索引到相应的目录中\n在此目录下，shell目录下，执行以下操作：\n右键目录新建VisualCode项（根据知乎大神的操作，但是我看原本VScode自动配置时是生成VSCode项，名字似乎无关紧要，重点是其中的数据。如果你本身就有VSCode项，可以尝试直接对VSCode项做修改，而不新建VisualCode项）\n配置操作描述：VisualCode项中有一个名称为(默认)的数据，双击进去填写数值数据用VScode打开这个数据是你右键文件时出现的操作描述\n这个描述可自定义，你改成用用全世界最好用的VScode打开也可以\n配置图标：右键刚才新建的VisualCode项，在VisualCode中新建一个可扩充字符串值，双击该数据，将数值名称改为Icon，将数值数据修改为：Code.exe执行文件的地址，如我的地址为：\nC:\\Users\\86153\\AppData\\Local\\Programs\\Microsoft VS Code_\\Code.exe\n配置命令：右键刚才新建的VisualCode项，在VisualCode项中新建一个项，命名为command，这个项中也会有一个默认值，双击默认，修改数值数据为：\u0026quot;your\\path\\Code.exe\u0026quot; \u0026quot;%1\u0026quot;，注意：要有\u0026quot;\u0026quot;引号，%1为要打开的文件参数\n配置：右键使用vscode打开文件夹 找到HKEY_CLASSES_ROOT\\Directory\\shell目录。\n除了更改目录，其它操作与上面的完全一样\n配置：右键空白处使用vscode打开文件夹 找到HKEY_CLASSES_ROOT\\Directory\\Background\\shell目录。 把command中的数值数据中的%1改成%V 其它操作与上面完全一样 效果 现在，你就可以使用右键文件夹，使用vscode打开该文件夹\n参考文章：右键菜单加入用VSCode打开文件和文件夹 - 知乎\n","date":"2024-11-04T09:45:00+08:00","image":"https://Lyrical-wander.github.io/p/vscode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%8F%B3%E9%94%AE%E7%94%A8vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/VScodeShortCutLogo_hu9814141210490913990.png","permalink":"https://Lyrical-wander.github.io/p/vscode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%8F%B3%E9%94%AE%E7%94%A8vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"VSCode无法使用右键“用VScode打开文件夹”解决办法"},{"content":"PyQt主窗口框架设计(QWidget) PrimeWindow.py的主要作用是绘制主窗口，在主窗口中：\n最左边是各种功能组件的入口，比如：翻译器，UTF-8转换，图像处理等。 按下左边的按键，则会切换功能区，切换功能并非重新开一个窗口，而是切换中间部分，这里主要是采用stack的原理 最右边是日志打印区，通过重定向的方法，把打印在操作台的内容打印到这个窗口上，这样方便开发人员debug 4.1 import部分 1 2 3 4 5 6 7 8 import Classes.TranslatorClass as TranslatorClass import Classes.ConvertorClass as ConvertorClass import Classes.AudioProcessClass as AudioProcessClass import Classes.AudiocodecClass as AudiocodecClass import Classes.AudioPlayerClass as AudioPlayerClass import Classes.ImgProcessClass as ImgProcessClass from component.btnStyle import * from component.editStyle import * 这些引用均来自作者自己的代码，分别保存在Classes目录下和component目录下，从这些目录下import不同的类或方法供PrimeWindow调用。\nClasses中的各种类，如TranslatorClass，保存着翻译功能的功能区UI结构：翻译按钮，翻译内容输入框以及翻译结果展示框等，以及各组件的摆放位置。\ncomponent中的各种方法，如btnStyle，该文件中有按钮按下的样式，按钮抬起的样式等，只需在点击按钮时调用该方法即可改变按钮样式。\n4.2 重定向操作台输出 重定向操作台输出需要调用一些系统方法\n1 2 3 4 5 6 7 current_directory = os.getcwd() # 获取当前工作目录，并将其存储在current_directory中。 self.original_stdout = sys.stdout # 将当前的标准输出（操作台）保存到self.original_stdout中，这样可以在将来恢复标准输出 self.output_stream = io.StringIO() # 创建一个StringIO对象，这个对象像一个文件，可以在内存中操作字符串，之后的标准输入输出将写入这个对象 sys.stdout = self.output_stream # 将标准输出重定向到刚才创建的StringIO对象self.output_stream。这样，所有通过print语句输出的信息都将储存在output_stream中，而不是打印到操作台 self.timer = QTimer() # 创建一个定时器对象，用于定期触发某些事件 self.timer.timeout.connect(self.updateOutput) # 将定时器的信号连接到self.updateOutput方法上，当定时器达到超时时间时则会调用该方法 self.timer.start(1000) # 设置定时器的超时时间为1000ms即1s 以上实现的是：重定向操作台的输出，开启定时器，每1s后，将原本pirnt方法打印到操作台的字符串储存起来，并调用updateOutput方法\n以下是代码逐行分析：\n获取当前工作目录，并将其存储在current_directory中 将当前的标准输出（操作台）保存到self.original_stdout中，这样可以在将来恢复标准输出 创建一个StringIO对象，这个对象像一个文件，可以在内存中操作字符串，之后的标准输入输出将写入这个对象 将标准输出重定向到刚才创建的StringIO对象self.output_stream。这样，所有通过print语句输出的信息都将储存在output_stream中，而不是打印到操作台 创建一个定时器对象，用于定期触发某些事件 将定时器的信号连接到self.updateOutput方法上，当定时器达到超时时间时则会调用该方法 设置定时器的超时时间为1000ms即1s updateOutput方法：\n1 2 3 4 5 6 7 8 9 def updateOutput(self): output = self.output_stream.getvalue() # 从output_stream中获取字符串 if output: # 如果其中有字符串的话 cursor = self.consoleedit.textCursor() # 获取日志打印文本编辑控件的当前光标，方便在特定的位置插入文本 cursor.movePosition(QTextCursor.End) # 将光标移动至结尾，以便现有文本插入新的输出内容 cursor.insertText(output) # 将内容添加到日志打印文本编辑控件中 self.consoleedit.setTextCursor(cursor) # 更新光标位置为刚刚移动的光标，这确保了后续的输入或操作将从正确的位置开始 self.consoleedit.ensureCursorVisible() # 确保光标在文本编辑器中可见，特别是光标在底部时，防止用户无法看到最新的插入内容，尤其是文本框不够大时 self.output_stream.truncate(0) # 清空output_stream中的内容，将其内容截断为0，使得下一轮输出时不会将之前的内容重复添加 通过这个方法，即可将打印的内容输出到日志打印区中。并每1秒就检查一次是否有新的内容需要输出\n因为是利用定时器每1秒检查一次是否有新的输出内容，所以输出并不是实时进行的，如你需要更精确的日志打印，则调小定时器的超时时间，但请注意，定时器的超时时间越短，定时器就会越频繁地调用updateOutput方法，即使什么新内容也没有。如果你需要做一些复杂且精密的操作，则可能需要考虑时间与空间开销的问题。 以下是代码逐行分析：\n从output_stream中获取字符串 如果其中有字符串的话 获取日志打印文本编辑控件的当前光标，方便在特定的位置插入文本 将光标移动至结尾，以便现有文本插入新的输出内容 将内容添加到日志打印文本编辑控件中 更新光标位置为刚刚移动的光标，这确保了后续的输入或操作将从正确的位置开始 确保光标在文本编辑器中可见，特别是光标在底部时，防止用户无法看到最新的插入内容，尤其是文本框不够大时 清空output_stream中的内容，将其内容截断为0，使得下一轮输出时不会将之前的内容重复添加 4.3 stackLayout 切换功能 在PyQt中，QStackLayout是用于在同一位置上堆叠多个小组件的布局管理器，允许根据需要在它们之间进行切换，这对实现标签页或动态内容展示非常有用\n1 2 3 4 5 6 def create_stack(self): # create a stack layout self.stacklayout = QStackedLayout() convertor = ConvertorClass.Wconvertor() self.stacklayout.addWidget(convertor) 创建stacklayout 把功能UI实现的对象添加在stacklayout中 1 2 3 4 5 6 7 # set the convertor buttons self.UTF8ConvertorBtn = QPushButton(\u0026#34;UTF-8 转换\u0026#34;) # 创建按钮对象 btnReleaseStyleA(self.UTF8ConvertorBtn) # 修改按钮样式，该方法为作者创建，并非第三方库调用 self.UTF8ConvertorBtn.clicked.connect(self.Cbtn_press_clicked) # 为按钮连接触发事件，该事件会切换stack # add the buttons to the layout self.btnlayout.addWidget(self.UTF8ConvertorBtn) # 将按钮添加到功能按钮区布局 updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，并非第三方库调用 UTF8ConvertorBtn按钮连接上了Cbtn_press_clicked方法，表示当该按钮被按下时，则调用Cbtn_press_clicked方法。同时我对按钮的样式做了修改，使用方法btnReleaseStyleA，因为要对按钮做批量相同的修改，因此集成到一个方法中去调用是常见的编程思想。\n1 2 3 def Cbtn_press_clicked(self): updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，非第三方库调用 self.stacklayout.setCurrentIndex(0) # 将当前stack布局设置为第一个抽屉 setCurrentIndex方法的意思是，stacklayout所占据的这一片区域，可以随意切换成被它add了的widget，它就像一个抽屉一样，抽屉的大小固定，但是这个固定的大小所展示的内容是由你抽出第几层决定。就比如参数为0，则抽出的是第1个抽屉，这个抽屉是一个widget，这个widget可以套一个layout，其中放各种各样的组件。同理，参数为1,则表示抽出第2个抽屉，则stacklayout所占据的这一片区域就会切换成第2个抽屉的样子。\n4.4 UI初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def initUI(self): #---------------- create Layout we needed ---------------------------- self.Mainlayout = QHBoxLayout() # 主窗口 self.Primarylayout = QVBoxLayout() # 功能区布局 self.btnlayout = QVBoxLayout() # 功能按钮区布局 #---------------- create Layout we needed ---------------------------- #---------------- there has more btn but unshowing ------------------- # set the convertor buttons self.UTF8ConvertorBtn = QPushButton(\u0026#34;UTF-8 转换\u0026#34;) # 创建按钮对象 btnReleaseStyleA(self.UTF8ConvertorBtn) # 修改按钮样式，该方法为作者创建，并非第三方库调用 self.UTF8ConvertorBtn.clicked.connect(self.Cbtn_press_clicked) # 为按钮连接触发事件，该事件会切换stack # add the buttons to the layout self.btnlayout.addWidget(self.UTF8ConvertorBtn) # 将按钮添加到功能按钮区布局 updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，并非第三方库调用 #---------------- there has more btn but unshowing ------------------- self.btnlayout.setAlignment(Qt.AlignTop) # 调整按钮区的各组件对齐方式为向上对齐，而非均匀分布 #----------------- put the stack in function area -------------------- widget = QWidget() # 创建一个widget，用于存放stack布局 widget.setLayout(self.stacklayout) # 将stack布局放到widget中 self.Primarylayout.addWidget(widget) # 将widget放到功能区布局中，至此stack在功能区中进行切换 #----------------- put the stack in function area -------------------- #---------------------- create log area ------------------------------ self.Consolelayout = QVBoxLayout() # 创建日志区布局 self.consoleedit = QTextEdit() # 创建日志编辑文本框 self.consoleedit.setReadOnly(True) # 文本框设置为只读 TextEditStyle(self.consoleedit) # 修改文本框样式， 该方法为作者创建，并非第三方库调用 self.consoleedit.verticalScrollBar().setPageStep(100) # 修改滚动条步长 self.Consolelayout.addWidget(self.consoleedit) # 添加文本框到日志区布局中 #---------------------- create log area ------------------------------ #------------------ put the layouts in main layout ------------------- self.Mainlayout.addLayout(self.btnlayout,stretch=1) # 将按钮布局添加到主布局中 self.Vline = QFrame(self) # 添加细线 将按钮区与功能区分隔开 self.Vline.setFrameShape(QFrame.VLine) # 优化细线 self.Vline.setFrameShadow(QFrame.Raised) # 使细线具有凸起的立体感 self.Vline.setLineWidth(3) # 设置细线外部粗细 self.Vline.setMidLineWidth(1) # 设置细线内部粗细 self.Mainlayout.addWidget(self.Vline) # 将细线添加至主布局 self.Mainlayout.addLayout(self.Primarylayout,stretch=4) # 将功能区添加至主布局中 self.Mainlayout.addLayout(self.Consolelayout,stretch=2) # 将日志区添加至主布局中 # add the layout to the window self.setLayout(self.Mainlayout) # 将主窗口的布局设置为主布局 #------------------ put the layouts in main layout ------------------- 4.5 结语 到目前为止，我们脚本工具集合包已经具备了初步的大致框架，三大区块已经被划分出来了，接下来的工作将重点放在要开发哪些功能，如何实现这些功能，以及这些功能的UI页面布局。这个系列将会==持续更新==，动手能力强的小伙伴可以根据路线自己实操一遍，后续我也会将完整代码开源带GitHub上（等系类差不多结束的时候），同时系列文章也会同步更新到我的CSDN博客中，如果本系列真的帮助到你，请关注本频道，并给我的CSDN==点赞收藏==QAQ，感激不尽！\n如有任何疑问，欢迎私信我的CSDN或发邮件到707973090@qq.com，在我看到时会第一时间回复！\n","date":"2024-11-01T10:43:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%9B%9B/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%9B%9B/","title":"基于PyQt开发的脚本集合包（四）"},{"content":"PyQt程序入口（QMainWindow） main.py是程序的入口，程序最开始运行的文件，在这个文件中，需要完成以下几件事：\n创建一个MainWindow（主窗口） 设置主窗口的标题，图标 设置窗口的主体（centralWidget） 设置窗口的状态栏 创建workspaces目录 运行窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import sys import os from PyQt5.QtWidgets import * from PyQt5.QtGui import * from PyQt5.QtCore import * import PrimeWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;Script Tools\u0026#34;) self.setWindowIcon(QIcon(\u0026#34;_internal/res/icon/icon.ico\u0026#34;)) centralWidget = PrimeWindow.PrimeWindow() self.setCentralWidget(centralWidget) self.addStatusBar() def addStatusBar(self): self.statusBar = QStatusBar() self.statusWidget = QWidget() self.statusLayout = QHBoxLayout() self.copyrightlable = QLabel(\u0026#34;© Author: LyricalRover. All rights reserved.\u0026#34;) self.versionlable = QLabel(\u0026#34;Last updated: 2024-10-18. Version: 1.3.1\u0026#34;) self.statusLayout.addWidget(self.copyrightlable) self.statusLayout.addStretch() self.statusLayout.addWidget(self.versionlable) self.statusWidget.setLayout(self.statusLayout) self.statusBar.addWidget(self.statusWidget) self.setStatusBar(self.statusBar) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) w = MainWindow() if not os.path.exists(\u0026#34;workspaces\u0026#34;): os.makedirs(\u0026#34;workspaces\u0026#34;) w.show() app.exec() 最开始进入的地方是：if__name__ == \u0026ldquo;_main_\u0026rdquo;:\napp = QApplication(sys.argv)初始化应用程序对象\n1. QApplication 类 QApplication 是 Qt 应用程序的主类，负责管理应用程序的控制流和主要设置。 它处理应用程序的主事件循环，并为 GUI 元素提供必要的支持。 每个使用 Qt 的应用程序通常需要一个 QApplication 实例。 2. sys.argv 的作用 sys.argv 是一个列表，包含命令行参数。这些参数是在运行 Python 脚本时传递的。 QApplication 可以使用这些参数来配置应用程序的行为，例如窗口大小、样式等。 3. 初始化应用程序 通过 app = QApplication(sys.argv)，你完成了以下几个步骤：\n创建应用程序对象：这行代码创建了一个 QApplication 的实例，并将命令行参数传递给它。 设置事件循环：这个实例负责管理 GUI 的事件循环，使得应用程序能够响应用户输入和事件（例如鼠标点击、键盘输入等）。 为应用程序提供上下文：QApplication 提供了关于应用程序的信息，例如样式、主题、字体等。 创建MainWindow对象，即运行上面的class中的代码\ndef __init__中，设置窗口的标题，设置窗口的图标，在这里可以看到，设置图标的路径是：_internal/res/icon/icon.ico，但我们并没有创建这个__internal的目录，回顾环境配置中pyinstaller部分的讲解：“pyinstaller在v6.0版本以后，数据将被移动到__internal目录下”，也就是说，如果我们打包程序形成exe文件后，想要文件能够正确找到icon的地址，则必须在你写的地址前加上__internal目录，配合上打包时的参数,-add-data \u0026quot;icon.ico;__internal/res/icon/icon.ico\u0026quot;，就可以在打包后显示正常的图标。\n1 centralWidget = PrimeWindow.PrimeWindow() 上面的代码是创建一个UI主体，该主体是PrimeWindow对象，这个类在PrimeWindow.py中，这个主体内具体是怎样的后面会讲到。\naddStatusBar的结构如下图所示：\n左右分别是两个label的Widget，分别装了两条信息，中间用addStretch弹簧将两个label分压向两侧。\n理想很丰满，现实很骨感，实际上并没有呈现出这样一个操作，我猜测应该是有另一个东西阻碍了StatusBar，并没有完整占据整个窗口的下方，也就是说，StatusBar本身被压缩了，导致versionlabel并没有被压向窗口主体的右侧。但具体原因尚不明朗。\n还有一点值得注意的是：\n我在引入第三方库的时候因为偷懒使用了“*”，即：from PyQt5.QtWidgets import *等。\n建议使用了什么就引入import什么，而不是为了图方便而直接使用“*”，理由如下：\npython模块的导入实际上是通过import来进行导入的，一个模块一旦被导入，后续的导入操作则直接从缓存中读出，而不会重复导入，这就说明，在初次操作时，需要加载导入内容，如果使用“*”，初次导入的时间开销会更多一些，但后续的性能差别并不明显。 由于import *会导入所有的公共成员，因此它可能会占用更多的内存，因此空间开销会更大。 使用更明确的导入方式，会有助于代码的可读性，避免不必要的模块加载，减少潜在的时间和空间开销，同时较少命名冲突的风险，这种情况在大型项目中更为明显。 ","date":"2024-11-01T10:40:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%89/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%89/","title":"基于PyQt开发的脚本集合包（三）"},{"content":"布局 2.1 UI页面布局 整体框架分为分为三个部分，垂直分布。\n第一个部分为功能选择按钮（如UTF-8转换，翻译器等）\n第二部分为功能区，即对应功能输入，输出展示区\n第三部分为后台区，显示对应的后台信息（本质上是将终端输出的print重定向至这块区域，方便调试以及使用）\n除此之外，整体的下方状态信息栏中有版本信息\n整体布局如下图所示：\ntips：\n这个界面是直接在vscode中运行时所展示的，因此图标以及部分按钮并未完全列装（不保证debug与打包一致的原因较为复杂，与pyinstaller的版本有关，后续内容会解释），图标列装后如下所示：\n2.2 工程布局 在创作自己的程序前（如果是较大的程序），最好需要规划一下自己的工程结构，用多个不同的目录保存不同的资源，如图像，文本，代码等，而代码中，实现不同功能的subprograms（子程序）也可以再细分在不同的目录中，尤其是可以多个subprogram（子程序）反复调用的subprograms（子程序）或scripts（脚本）。\n我的工程布局意识也是在这个项目中不断完善的，还有一些不足和错误的地方也在不断更新中。\n一级目录 MyScriptTools目录是包目录，为了方便管理我们需要用到的各种包文件，需要在项目开始时便创建好该项目python运行的虚拟环境（虚拟环境具体的创建流程看前文）。创建完成后，使用pip包管理器下载的所有包都会保存在这个包目录中。（因为我的虚拟环境名字叫MyScriptTools，因此包目录的名字也叫MyScriptTools） src是存放代码的位置，所有的代码都存放在这个目录下 workspaces目录是运行时创建的保存文件目录，因为我的项目中，有一些功能或脚本会产生新的文件，我希望它们被保存在一个统一的空间，看起来不会太过混乱，因此专门设计了这一个功能：在程序运行时，创建一个workspaces目录，以后若产生新的文件，统一保存在workspaces目录下 BingTranslator.py与test.py是两个测试脚本，目前已经失去了作用 src目录 Classes：该目录下存放着各种功能的功能区UI类，error类等，如TranslatorClass.py为翻译功能的UI设计，包括按钮，文本框的布局等 component：该目录下存放着修改组件样式的方法，如editStyle.py文件中存放着修改QLineEdit样式的方法以及修改QTextEdit样式的方法。这样如果有多个QLineEdit组件需要修改样式时，只需要调用其中的方法即可。 dist：该目录是使用pyinstaller将程序打包成exe可执行文件时生成的，exe可执行文件存放在其中 res：该目录下存放着需要使用的图片，图标等资源文件 tools：该目录下存放着脚本以及功能的实现，如：实现翻译的功能方法存放在tools目录下的translation.py文件中，Classes目录下的TranslatorClass.py文件中会调用translation.py文件来实现功能 xxx.spec：该文件是如果打包时使用了\u0026ndash;onefile参数，即打包生成一个单独的exe文件，则会产生该文件，该文件记录了一些打包时需要关注的信息 icon.ico：图标文件，可要可不要，如果不要，在打包时想要生成exe文件的图标时需要指定图标的路径，我懒得指定路径，只想填个名字，就把图标放在与main.py同一目录下 main.py：该文件时程序的入口，与C程序的main相同。打包时需要指定程序入口，即该文件 PrimeWindow.py：主UI框架，即主窗口，上面Classes中的UI仅为功能区UI，属于主窗口的三部分之一 2.3 布局思想 我的布局思想是在不断碰壁的过程中自己摸索出来的，在开发这个程序之初并没有想把它做成一个完整的具有UI界面的功能集合包，因此一开始并没有工程布局的概念，需要做什么便在src下新建一个文件开始编码，这种习惯的弊端在随着程序愈发庞大而变得愈发清晰，使程序越来越难管理且开发难度增大。之后抽时间将程序整理了一遍，便形成了这种布局。个人观念，仅供参考。\n我的工程布局思想主要遵循两个原则：\n归类 相同属性或相同功能或本质相同的文件放在一个目录下，如：图片，文本等文件属于输入文件，只可被调用，因此放在同一目录res下，当然，res下可再做区分，img，icon，txt等。不同的功能区UI可放在同一目录下，这样可以将primeWindow与功能UI区分开来，且方便primeWindow调用功能UI，来实现功能的切换。功能的实现放在tools目录下，classes可以调用tools下相应的功能。tools目录下，部分功能过于复杂无法用一个文件完成也可以再建立子目录。\n重复调用 如果遇到需要反复调用的功能，可集成出来单独形成一个方法单独存放，方便不同文件的调用，而不需要重复实现，如文本框，单行文本框，按钮等样式，实现选择文件等功能\n","date":"2024-11-01T10:36:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%8C/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%8C/","title":"基于PyQt开发的脚本集合包（二）"},{"content":"前言 作者因为工作需要，用python写了一些脚本用于数据处理，UTF-8转换，以及一些我的工作专属脚本，又因为想要偷懒，用爬虫爬取了微软翻译的页面做了一个自己的翻译器，近来突发奇想，想要把各种python写的脚本整合到一起，并写一个GUI应用程序，因此PyQt进入了我的视野。想着用业余时间一点一点摸索，到目前为止算是做的有模有样，现写博客记录下来。\n这个GUI程序会分成一个系列更新，把我的UI框架，布局，工程整理，功能编写等等都写出来，包括：利用爬虫爬取微软翻译来做自己的翻译器，图像处理等。\n本脚本工具包还在持续更新（部分功能我也还没有完成），目前还没有做完的功能有：做音频数据处理（抓取BLE音频数据包，自动去包头去CRC校验，获取raw data的功能），音频编解码（利用市面上常见开源编解码器对音频数据进行编码或解码，ADPCM，SBC等），后续根据需要和精力，看能不能做音频数据的时域频域转换器等等。都是美好幻想，敬请期待！\n因为程序还在不断地完善更新，所以到系列结束时，代码应该就已经更新完成了，到时候我会将代码开源到我的GitHub仓库上，有兴趣的小伙伴可以下载使用或交流学习。本系列文章也会同步更新到我的CSDN博客中，如果小伙伴们觉得本系列对你有帮助，麻烦点个赞与收藏，感激不敬！\n环境配置 1.1 Python环境 python下载 python下载网上有许多教程，这里不赘述了，我的编程环境是vscode，创建虚拟环境，\n创建虚拟环境 1 python -m venv myPyQt #创建虚拟环境，命名为myPyQt 可以在终端查看包列表\n1 2 pip list # 看列表中是否有PyQt5相关的包 1.2 PyQt5安装 创建好虚拟环境后先进入虚拟环境，然后在该虚拟环境中下载PyQt5\n1 pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple # -i + 地址 为从国内镜像网站下载，提升下载速度 下载好qt后可以测试一下是否安装成功\n1 2 3 from PyQt5.QtCore import * print(QT_VERSION_STR) # 如果没有报错，则说明安装成功 1.3 Pyinstaller 打包命令：\n1 pyinstaller -n yourProgramName -i icon/path/icon.ico --add-data \u0026#34;path/xxx.png;.\u0026#34; --add-data \u0026#34;CanAddLotData.ico;path/in/__interval\u0026#34; -w main.py -n：你程序的名字\n-i：你应用的图标，如果与程序入口（main）不在同一目录下，则需要给出相应的路径\n\u0026ndash;add-data：链接外部资源，比如图片，图标等资源，该参数分为两个部分，使用“:”（Linux）或“;”（Windows）隔开，前面是打包前该文件的路径，后面是打包后该文件要保存的路径，下面是重点\n值得注意的是，pyinstaller在v6.0版本以后，如果没有加入--onefile参数，那么打包后会生成一个附带的目录__internal，打包后你的文件会保存在该目录下，比如：--add-data \u0026quot;res/xx.icon;res/xx.icon\u0026quot;，那么pyinstaller会在与main.py相同的目录下寻找一个res目录下的xx.icon文件，将其作为外部资源链接到程序中，并在__internal目录下创建一个res目录，存放一个xx.icon文件。如果你使用了--onefile参数，那么将不会创建__internal目录，res目录将会创建在与exe文件相同的目录下。GitHub上有对该问题的解释：Regression: datas moved to _internal in pyinstaller 6.1.0. pyinstaller 5.13.1 puts datas in correct directory · Issue #8075 · pyinstaller/pyinstaller\n切记切记这一点，因为这影响到你程序中调用资源文件时该如何填写路径，如果还没弄懂没有关系，后面会在代码中详细解释\n-w：此参数用于创建不显示命令行窗口的GUI程序，即：避免应用程序运行时弹出命令行窗口\nmain.py：程序入口\n如果你在使用 -i 命令时遇到来了以下报错：\n1 Received icon image \u0026#39;D:\\python\\MyScriptTools\\src\\icon.ico\u0026#39; which exists but is not in the correct format. On this platform, only (\u0026#39;exe\u0026#39;, \u0026#39;ico\u0026#39;) images may be used as icons. If Pillow is installed, automatic conversion will be attempted. Please install Pillow or convert your \u0026#39;ico\u0026#39; file to one of (\u0026#39;exe\u0026#39;, \u0026#39;ico\u0026#39;) and try again. 说明你使用的图标文件格式不正确，只有exe或ico格式的图像才可以用作图标。如果系统无法识别你的ico或你只有jpg或png等格式的图标，可以安装pillow，它会为你解决一切\n1 pip install pillow 那么到此为止，你做好了开发PyQt的前置工作\n","date":"2024-11-01T10:30:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%80/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%80/","title":"基于PyQt开发的脚本集合包（一）"}]