[{"content":"前言 这是音频编解码器的第三篇文章，也是收官文章，上一篇文章中，我们讲了如何制作一个自定义的特色进度条，现在，我们需要将进度条的刷新与编解码器的进度绑定起来，如此进度条才有意义，因为编解码器比较吃算力（虽然看起来ADPCM的算法非常的简单，但是奈何笔者采用的是python脚本通过循环调用C编译的exe可执行文件来实现的编码，因此算上python本身的性能，加上反复调用exe可执行文件的系统操作开销，导致ADPCM的计算时间也是不可忽视的，尤其在大数据量时），因此我们需要对编解码器单独开一个子线程跑，这样，在编解码器运行时，QT界面也能正常使用不受影响。既然编解码器是由子线程跑，那么为何也为进度条开一个子线程，两个之间沟通消息，这样编码器与进度条的运行都不会影响QT界面的运行，而且也给进度条的使用提供了一个范式，以后再有其它功能需要使用进度条时复制粘贴即可。\nPython中的线程 Python处理线程的模块有两个：thread 和 threading。Python 3已经停用了 thread模块，并改名为 _thread 模块。Python 3在 _thread 模块的基础上开发了更高级的 threading 模块，因此我们现在用的线程模块都是 threading 模块。\n创建线程 1 threading.Thread(target=None, name=None, args=(), kwargs={}) target 指要创建的线程的方法名，name 指给此线程命名，命名后可以调用 threading.current_thread().name 方法输出该线程的名字， args/kwargs 指 target 指向的方法需要传递的参数，必须是元组形式，如果只有一个参数，需要以添加逗号。\n线程之间的消息传递 线程与线程之间的通信是一个常见的需求。Python提供了几种方法来实现进程与进程之间的通信，常见的方式包括：queue.Queue、threading.Event、threading.Lock等同步原语。\n使用 queue.Queue 进行线程通信 queue.Queue 是线程安全的队列，适合用于线程之间的数据传递。你可以在子线程中将数据放入队列，然后在主线程中读取。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 pythonCopy Codeimport threading import queue import time # 子线程函数 def worker(q): for i in range(5): time.sleep(1) # 模拟一些工作 q.put(f\u0026#34;Message {i}\u0026#34;) # 将消息放入队列 print(f\u0026#34;Worker: Sent message {i}\u0026#34;) # 主线程 def main(): # 创建一个队列 q = queue.Queue() # 创建并启动子线程 t = threading.Thread(target=worker, args=(q,)) t.start() # 主线程从队列中接收消息 for _ in range(5): msg = q.get() # 阻塞直到队列中有数据 print(f\u0026#34;Main Thread: Received {msg}\u0026#34;) t.join() # 等待子线程结束 if __name__ == \u0026#34;__main__\u0026#34;: main() 解释：\n子线程 worker 将一些消息放入队列 q 中。 主线程从队列中获取消息并打印。queue.get() 是阻塞的，直到队列中有新的数据。 q.put() 和 q.get() 是线程安全的，可以在多个线程之间安全地交换数据。 使用 threading.Event 进行线程通信 threading.Event 是一个简单的同步原语，允许线程在等待某个条件发生时进行通信。例如，主线程可以等待子线程完成某些操作，或者子线程可以通知主线程某个事件已经发生。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pythonCopy Codeimport threading import time # 子线程函数 def worker(event): time.sleep(2) # 模拟一些工作 print(\u0026#34;Worker: Setting event\u0026#34;) event.set() # 设置事件，通知主线程 # 主线程 def main(): # 创建一个事件对象 event = threading.Event() # 创建并启动子线程 t = threading.Thread(target=worker, args=(event,)) t.start() print(\u0026#34;Main Thread: Waiting for event\u0026#34;) event.wait() # 阻塞，直到子线程设置事件 print(\u0026#34;Main Thread: Event received\u0026#34;) t.join() # 等待子线程结束 if __name__ == \u0026#34;__main__\u0026#34;: main() 解释：\n子线程在执行完某些任务后调用 event.set() 来通知主线程。 主线程使用 event.wait() 来等待事件的发生，wait() 会阻塞直到事件被设置。 使用 threading.Lock 和共享变量 如果需要在多个线程之间共享一些资源（如变量），可以使用 threading.Lock 来避免竞争条件（race condition），确保数据的一致性。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 pythonCopy Codeimport threading import time # 共享变量 shared_data = 0 lock = threading.Lock() # 子线程函数 def worker(): global shared_data for _ in range(5): time.sleep(1) # 模拟工作 with lock: # 使用锁保护共享资源 shared_data += 1 print(f\u0026#34;Worker: Incremented shared_data to {shared_data}\u0026#34;) # 主线程 def main(): # 创建并启动子线程 t = threading.Thread(target=worker) t.start() t.join() # 等待子线程结束 # 访问共享资源 with lock: # 同样使用锁保护共享资源 print(f\u0026#34;Main Thread: Final shared_data is {shared_data}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 解释：\nshared_data 是一个主线程和子线程共享的变量。 使用 threading.Lock() 来确保只有一个线程能够访问和修改共享数据，从而避免了数据的竞争。 使用 threading.Condition 进行更复杂的通信 threading.Condition 是一种更复杂的同步机制，允许线程在某个条件发生时进行等待和通知。它结合了 Lock 和 Event 的特性，适用于更复杂的线程间协调问题。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 pythonCopy Codeimport threading import time # 共享资源和条件变量 shared_data = 0 condition = threading.Condition() # 子线程函数 def worker(): global shared_data time.sleep(2) # 模拟工作 with condition: shared_data = 42 # 修改共享数据 print(\u0026#34;Worker: Shared data set to 42\u0026#34;) condition.notify() # 通知主线程 # 主线程 def main(): # 创建并启动子线程 t = threading.Thread(target=worker) t.start() with condition: print(\u0026#34;Main Thread: Waiting for condition\u0026#34;) condition.wait() # 等待通知 print(f\u0026#34;Main Thread: Shared data is {shared_data}\u0026#34;) t.join() # 等待子线程结束 if __name__ == \u0026#34;__main__\u0026#34;: main() 解释：\n子线程修改共享数据并使用 condition.notify() 通知主线程。 主线程通过 condition.wait() 等待子线程通知，直到条件满足才继续执行。 接下来我们看一下编解码器UI是如何调用编解码器以及编解码器如何与进度条进行消息传递的\n编码器UI设计 编码器的UI布局在上一篇文章中已经阐述过，在这里就不做过多的赘述，直接放上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 import sys from PyQt5.QtWidgets import * from PyQt5.QtGui import * from PyQt5.QtCore import * from PyQt5.QtSvg import * import threading import queue from component.btnStyle import * from component.editStyle import * from component.getPath import * from component.progressBar import * from tools.adpcmcoder.adpcmEncRun import * from tools.adpcmcoder.adpcmDecRun import * class WAcodec(QWidget): def __init__(self): super().__init__() self.filePaths = [\u0026#39;\u0026#39;] self.initUI() def initUI(self): self.layout = QVBoxLayout() self.setLayout(self.layout) # 文件选择 self.filelayout = QHBoxLayout() self.lable = QLabel(\u0026#34;请选择文件\u0026#34;,self) self.filelayout.addWidget(self.lable) self.input = QLineEdit(self) LineEditStyle(self.input) self.filelayout.addWidget(self.input) self.choosebtn = QPushButton(\u0026#34;选择文件\u0026#34;,self) btnReleaseStyleA(self.choosebtn) self.choosebtn.clicked.connect(self.getpath) self.filelayout.addWidget(self.choosebtn) self.layout.addLayout(self.filelayout) # 编码器选择 self.codeclayout = QHBoxLayout() self.codeccb = QComboBox(self) self.codeccb.addItem(\u0026#39;ADPCM\u0026#39;) self.codeclayout.addWidget(self.codeccb) self.layout.addLayout(self.codeclayout) # 编码解码选择 self.encdeclayout = QHBoxLayout() self.encdecbtn = QPushButton(\u0026#34;编码\u0026#34;,self) btnReleaseStyleA(self.encdecbtn) self.encdecbtn.clicked.connect(self.encodeRun) self.encdeclayout.addWidget(self.encdecbtn) self.decbtn = QPushButton(\u0026#34;解码\u0026#34;,self) btnReleaseStyleA(self.decbtn) self.decbtn.clicked.connect(self.decodeRun) self.encdeclayout.addWidget(self.decbtn) self.layout.addLayout(self.encdeclayout) # 进度条 self.runlayout = QVBoxLayout() self.progress_bar = ProgressBar() # 自定义进度条 self.runlayout.addWidget(self.progress_bar) self.layout.addLayout(self.runlayout) def getpath(self): get_path(self) self.input.setText(self.filePaths[0]) def encodeRun(self): if self.input.text() == \u0026#39;\u0026#39;: print(\u0026#34;未选择文件\u0026#34;) return q = queue.Queue() self.progress_bar.init_grids() if self.codeccb.currentText() == \u0026#39;ADPCM\u0026#39;: # 以多线程并发的形式规避ADPCM编解码时带来的卡顿问题 threading.Thread(target=ADPCMencodeRun, args=(self.input.text(),q), daemon=True).start() threading.Thread(target=self.progress_bar.update_progress,args=(q,), daemon=True).start() def decodeRun(self): if self.input.text() == \u0026#39;\u0026#39;: print(\u0026#34;未选择文件\u0026#34;) return q = queue.Queue() self.progress_bar.init_grids() if self.codeccb.currentText() == \u0026#39;ADPCM\u0026#39;: threading.Thread(target=ADPCMdecodeRun, args=(self.input.text(),q), daemon=True).start() threading.Thread(target=self.progress_bar.update_progress,args=(q,), daemon=True).start() PyQt5部分的代码已经是老朋友了，获取文件，下拉选框，两个按钮。进度条的设计在上一篇文章中详细介绍过，这里着重介绍按钮按下时，创建线程执行编解码器与进度条\n以解码器为例：\n使用threading.Thread函数创建线程，target传入线程需要调用的方法，即ADPCMdecodeRun，解码启动脚本，args向ADPCMdecodeRun方法传入参数，文件路径与队列对象，队列对象用于保存和传输消息，daemon表示该线程是否为守护线程，如果是，则它会在主线程结束时自动终止，哪怕它的任务没有结束，如果不是，则如果它的任务没有结束，程序会等待它执行完毕才会结束 .start表示启动该线程 解码器启动脚本 介绍完如何开启线程与线程之间如何进行通信，那么我们接下来就实现解码器的启动脚本，并在解码器的启动脚本中做一些小小的设计：\n设置一个percent，来记录当前已解码的进度，percent记录的是 已解码行数/总行数 因为进度条共有100个格子来表示0%,1%,...,100%，因此进度条应接收整数的1，2，3，4，...，进而percent应该是整数，且+1后通过put方法，向进度条传递消息 进度条通过get方法阻塞自己，等待解码器的消息，当解码器传递来新的消息时，就会触发更新进度条。 接下来我们看编码器的启动脚本代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import subprocess import queue import sys def ADPCMdecodeRun(filepath,q): print(\u0026#34;ADPCM decode start\u0026#34;) with open(\u0026#39;workspaces/pcm.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: fw.close() error = [] linecount = 0 totalcount = 0 progressblock = 0 percent = 1 if sys.platform == \u0026#39;win32\u0026#39;: # 仅在 Windows 上使用这个设置 creation_flags = subprocess.CREATE_NO_WINDOW else: creation_flags = 0 # 在其他平台上没有必要使用这个参数 ###···················DEXP ADPCM解码·························· with open(filepath,\u0026#39;r\u0026#39;) as f: print(\u0026#34;ADPCM decoding ...\u0026#34;) adlist = [] adlist.append(\u0026#39;00\u0026#39;) adlist.append(\u0026#39;00\u0026#39;) lines = f.readlines() totalcount = len(lines) progressblock = totalcount / 100 for line in lines: for i in range(len(line)): if line[i] == \u0026#39; \u0026#39; or line[i] == \u0026#39;\\n\u0026#39;: adlist.append(line[i-2:i]) # 若打包，用下面路径 #args = [\u0026#34;_internal/res/AdpcmCodec/adpcmdecoder.exe\u0026#34;] + adlist # 若调试，用下面路径 args = [\u0026#34;src\\\\tools\\\\adpcmcoder\\\\adpcmdecoder.exe\u0026#34;] + adlist #print(args) result = subprocess.run(args, capture_output=True,text=True,creationflags=creation_flags) #print(\u0026#34;STDOUT:\u0026#34;, result.stdout) #print(\u0026#34;liencount:\u0026#34;,linecount) if result.returncode != 0: error.append(linecount) else: hex_list = result.stdout.split() adlist.clear() adlist.append(hex_list[len(hex_list)-2]) adlist.append(hex_list[len(hex_list)-1]) hex_list.pop() hex_list.pop() hex_list = \u0026#39; \u0026#39;.join(hex_list) with open(\u0026#39;workspaces/pcm.txt\u0026#39;,\u0026#39;a\u0026#39;) as fw: fw.write(hex_list) fw.write(\u0026#34;\\n\u0026#34;) fw.close() linecount += 1 if linecount \u0026gt; percent * progressblock: #msg = f\u0026#34;已完成{percent}%\u0026#34; q.put(percent) #print(\u0026#34;msg:\u0026#34;,msg) #print(\u0026#34;linecount:\u0026#34;,linecount) percent += 1 q.put(percent) print(\u0026#34;ADPCM decode end\u0026#34;) 在这段代码中，可以看到，ADPCMdecodeRun方法除了接收文件路径外，还接收一个q变量，即Queue对象，这样，在该线程中可以使用队列对象来传递消息，我们来依次解释一下代码：\n写文件，使用w打开后直接关闭，达到一个创建文件，若文件存在，则清空文件中的内容的目的（因为后面我们用a命令在文件中追加内容，如果不提前清理文件，则会在同名文件下追加内容导致数据会乱） 默认情况下，Windows会弹出命令窗口（CMD）以运行程序，在此python脚本中，因为会循环调用CMD来启动解码器adpcmdecoder.exe，因此会导致CMD窗口被反复打开又关闭。为避免这个CMD窗口弹出，可以通过设置subprocess的creation_flags参数来隐藏它。具体来说，你可以使用 subprocess.CREATE_NO_WINDOW 来防止命令行窗口的出现。这对于 Windows 系统特别有效。 totalcount获取总行数，progressblock为总行数的1% 循环读取数据，并将数据放入解码器中，注意，这里使用的是ADPCM解码器，根据往期内容，我们的解码器接收的参数为：函数名称，valprev，index，data_1，data_2，\u0026hellip;.，data_n。valprev与index初始化值为0。 如果解码失败或遇到错误参数，导致解码器无法正常解码，解码器会返回非0数字，脚本会记录下当前未被正确解码的行数，保存在error列表中 对解码后的数据做分割处理，在这里返回的数据保存方式为：data_0，data_1，data_2，\u0026hellip;.，data_n，valprev，index，这与输入的刚好相反，将valprev与index这两个参数放在最后，因为历史遗留问题，笔者没(lan)有(de)改动。 将valprev与index保存在adlist列表的开头，用以下一次解码，并在hex_list列表中弹出这两个值，因为写入数据时不需要这两个值，这两个是解码时产生的中间值，不是数据。 将数据写入文件中，a表示在末尾追加内容 linecount记录当前行数，如果linecount超过了progressblock * percent，则执行percent ++ 操作。例如：文件中共有100行数据，则totalcount=100，progressblock=10，现在当linecount=11时，则会导致linecount \u0026gt; percent * progressblock，则会对percent+1，此时percent= 1 如果上面的条件达成，则会将percent=1的消息通过q.put方法放到队列中 此时，在进度条对象ProgressBar中的update_progress方法中的percent = q.get()在阻塞，检测是否有新消息，现在得到了新消息，则将消息赋值给percent，如此，就实现了解码的进度传递给进度条组件的操作。 以上便是解码启动器脚本，下面给出编码器启动脚本，原理相同，代码改动不大，笔者就不做赘述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import subprocess import queue import sys def ADPCMencodeRun(filepath,q): print(\u0026#34;ADPCM encode start\u0026#34;) with open(\u0026#39;workspaces/adpcm.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: fw.close() error = [] linecount = 0 totalcount = 0 progressblock = 0 percent = 1 if sys.platform == \u0026#39;win32\u0026#39;: # 仅在 Windows 上使用这个设置 creation_flags = subprocess.CREATE_NO_WINDOW else: creation_flags = 0 # 在其他平台上没有必要使用这个参数 ###···················DEXP ADPCM编码·························· with open(filepath,\u0026#39;r\u0026#39;) as f: print(\u0026#34;ADPCM encoding ...\u0026#34;) adlist = [] adlist.append(\u0026#39;00\u0026#39;) adlist.append(\u0026#39;00\u0026#39;) lines = f.readlines() totalcount = len(lines) progressblock = totalcount / 100 for line in lines: for i in range(len(line)): if line[i] == \u0026#39; \u0026#39; or line[i] == \u0026#39;\\n\u0026#39;: adlist.append(line[i-4:i]) # 若打包，用下面路径 #args = [\u0026#34;_internal/res/AdpcmCodec/adpcmencoder.exe\u0026#34;] + adlist # 若调试，用下面路径 args = [\u0026#34;src\\\\tools\\\\adpcmcoder\\\\adpcmencoder.exe\u0026#34;] + adlist #print(args) result = subprocess.run(args, capture_output=True,text=True,creationflags=creation_flags) #print(\u0026#34;STDOUT:\u0026#34;, result.stdout) #print(\u0026#34;liencount:\u0026#34;,linecount) if result.returncode != 0: error.append(linecount) else: hex_list = result.stdout.split() adlist.clear() adlist.append(hex_list[len(hex_list)-2]) adlist.append(hex_list[len(hex_list)-1]) hex_list.pop() hex_list.pop() hex_list = \u0026#39; \u0026#39;.join(hex_list) with open(\u0026#39;workspaces/adpcm.txt\u0026#39;,\u0026#39;a\u0026#39;) as fw: fw.write(hex_list) fw.write(\u0026#34;\\n\u0026#34;) fw.close() linecount += 1 if linecount \u0026gt; percent * progressblock: #msg = f\u0026#34;已完成{percent}%\u0026#34; q.put(percent) #print(\u0026#34;msg:\u0026#34;,msg) #print(\u0026#34;linecount:\u0026#34;,linecount) percent += 1 q.put(percent) print(\u0026#34;ADPCM encode done\u0026#34;) 总结 这是一个简单的实现线程之间消息传递的模式，在我的实践中是可行的，至此，我们实现了音频编解码器的功能模块，并实现了一个新的组件，即进度条。当然，这个功能模块尚不完美，后续还会持续地检查并优化（如果有优化方法的小伙伴也欢迎私信我）。在这里我整理了几点不足：\n首先，ADPCM的编解码器通过subprocess的方法循环调用确实有些笨拙，也比较吃性能，在频繁地启动编码器过程中，往往会损失大量的时间 其次，在实际测试过程中ADPCM的编解码速度时好时坏，同一份数据，有时候会非常慢，有时候又会非常快，我通过观察脚本的硬件调度，发现内存占用比没有发生很大的变化，但是GPU的调度会有明显变化，当GPU持续被分配给脚本时，编解码的速度会非常快，当GPU没有被分配给脚本时，编码速度会变得异常慢。为什么会产生GPU分配的差异原因笔者还没查出来，在代码中，Python也没有显式地说明在什么环节会调用GPU，笔者也没有刻意地去调用GPU，如果直到原因的同学可以私信我。 percent这种简易（甚至说简陋）的粗暴计算编解码进度的方法实在有些拙劣，可能还会产生其它对进度预估错误的情况发生。我推测可能会产生bug的一种场景是，当adpcm编解码速度过快，进度条还未处理上一条消息的绘制时，下一条消息就来了，可能会导致缺画漏画的情况，笔者还没测出，但笔者会持续改进算法，也希望各位大佬能够指点一二。 到目前为止，音频编解码器模块的代码已经全部出来。\n我们先从UI界面开始，通过PrimeWindow的stack切换到音频编解码器模块，即本文出现的第一个代码，那里实现了编解码器功能区的UI\n代码存放的工程目录如下：\n之后，便是音频编码器的启动脚本与解码器的启动脚本都在本文中展示了\n工程目录如下：\n再者，到进度条样式的实现，在上一篇文章中实现了\n工程目录如下：\n最后，到编解码器的实际实现，这部分是通过C程序实现的，在上上篇文章中实现了\n工程目录如下：\n阅读完这三篇文章，加上熟悉本系列前期的基础，即工程布局架构，你可以轻松复制我的代码，实现自己的音频编解码器，快来试试吧！有任何疑问请联系我，祝你变得更强！\n因为语音编解码器功能模块的实现较为复杂，而且也增加了一些新的UI设计，因此知识点与代码都无法在一篇文章中全部呈现，但将代码分散在不同的文章里又让一些基础比较薄弱的同学难以快速上手，因此，如若对此模块感兴趣的人比较多，笔者将在这三篇文章的基础上，单独开一篇新的博文，梳理代码的布局以及如何在自己的机器上跑起来，让新手小白也能复制即用。\n","date":"2024-12-14T18:03:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%8D%81%E4%BA%8C/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%8D%81%E4%BA%8C/","title":"基于PyQt开发的脚本集合包（十二）"},{"content":"前言 这是实现音频编解码器功能模块的第二篇文章，在本文中，我们将实现自定义的特色进度条以及简单介绍编码器的UI布局，本文主要实现特色进度条，在本文中，我们会涉及到的知识点有：特色进度条的实现原理，一个python生成器的用法，PyQt的控件绘制机制。本文仅介绍编解码器UI的布局，因为实现UI时会用到开线程的部分，因此本文先不展示。\n本次笔者设计的特色进度条，是涂格子形式的进度条，当进度增加时，进度条内的方格会被随机涂上颜色，供大家参考。\nUI框架 如下图所示：\n编码器的UI布局同样为垂直分布\n在第一层级，由经典的选择文件构成，这个选择文件的布局样式已经在本系列中多次出现\n一个下拉选择框，目前只有ADPCM一个算法可供选择\n两个按钮水平布局，编码按钮启动编码器，解码按钮启动解码器\n编解码器读取选中的文件，从文件中读取数据。注意，文件最好是txt文件格式，数据是十六进制数1字节为单位，以空格分隔开，可选择一帧数据一行，如下图所示：\n解码器会在workspaces目录下生成pcm.txt数据文件，其中包含了解码后的PCM数据，以文本形式保存，后续将其放入pcm构建器中可生成二进制文件，在PCM播放器中播放即可。\n编码器会在workspaces目录下生成adpcm.txt数据文件，其中包含了编码后的ADPCM数据，以文本形式保存，后续如何处理数据，可自行决定。\n最下方是进度条，由20*5共100个方格组成，在未启动状态下为灰色，当开始解码或编码时，编码进度每增加1%，那么就会随机涂蓝一个格子，在进度为100%时，即编码完成，则所有格子全部为蓝色。\n当重新开始编码或解码时，格子会重新初始化，全部被重新涂成灰色。\n进度条展示 下面是正在解码过程中的进度条展示，在右边的日志展示区中可以看到，正在进行ADPCM解码，在功能区中，下方进度条在随机选择格子涂蓝，将这些以显示当前进度\n下面是解码结束后的进度条样式，可以看到，在右边的日志区中，显示ADPCM decode end，adpcm解码完成，下方的进度条已被完全涂成蓝色。\n代码详解 下面给出进度条的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import sys import random from PyQt5.QtCore import Qt, QTimer from PyQt5.QtGui import QColor, QPainter, QPainterPath from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QPushButton import queue class ProgressBar(QWidget): def __init__(self): super().__init__() self.setFixedSize(640, 160) # 设置进度条的大小 self.grid_size = 32 # 每个方格的宽度和高度 self.total_grids = (self.width() // self.grid_size) * (self.height() // self.grid_size) # 方格总数 self.lit_grids = 0 # 当前已点亮的方格数量 self.grid_status = [False] * self.total_grids # 每个方格是否被点亮 def init_grids(self): self.lit_grids = 0 # 当前已点亮的方格数量 self.grid_status = [False] * self.total_grids self.update() # 更新进度条绘制 def update_progress(self,q): \u0026#34;\u0026#34;\u0026#34;随机点亮一个未点亮的方格\u0026#34;\u0026#34;\u0026#34; while True: percent = q.get() if self.lit_grids \u0026lt; self.total_grids and percent \u0026lt;= 100: # 随机选择一个未点亮的方格 unlit_grids = [i for i, lit in enumerate(self.grid_status) if not lit] random_grid = random.choice(unlit_grids) self.grid_status[random_grid] = True # 点亮该方格 self.lit_grids += 1 # 增加已点亮的方格数量 self.update() # 更新进度条绘制 if percent == 100: break else: break def paintEvent(self, event): \u0026#34;\u0026#34;\u0026#34;自定义绘制进度条\u0026#34;\u0026#34;\u0026#34; painter = QPainter(self) painter.setRenderHint(QPainter.Antialiasing) # 启用抗锯齿效果，使边角更平滑 # 绘制方格 for row in range(self.height() // self.grid_size): for col in range(self.width() // self.grid_size): x = col * self.grid_size y = row * self.grid_size # 计算当前方格的索引 index = row * (self.width() // self.grid_size) + col if self.grid_status[index]: color = QColor(144, 203, 251) # 已点亮的部分，蓝色 else: color = QColor(224, 224, 224) # 未点亮的部分，灰色 painter.fillRect(x, y, self.grid_size, self.grid_size, color) # 绘制方格 painter.end() 我们来解释一下上面的代码：\n在__init__方法中，设置了一些基础配置，进度条的大小，方格的大小，方格的总数，已点亮的方格数，每个方格的状态（是否被点亮了），值得注意的是，方格的总是是通过进度条的长除以方格的长，进度条的宽除以方格的宽然后相乘的来的，这里直接翻译为20*5 = 100 init_grids方法重新初始化方格的基础配置，归零已点亮的方格数量，擦除方格的状态，并重新绘制进度条，即恢复初始状态 update_progress方法用以更新进度，可以看到，该函数接收一个q参数，该参数为一个队列对象，用以线程之间的沟通（线程方面我们下篇文章讨论），此处做一个while的死循环，从队列中获取来自另一个线程的消息，这个操作是阻塞的，也就是说，当未从队列中获取新的消息，则线程不会继续进行下一条指令。 如果已经点亮的方格数小于全部方格数，且进度≤100%，则执行以下操作，随机选择一个未点亮的方格，标志为点亮 unlit_grids = [i for i, lit in enumerate(self.grid_status) if not lit]，解释一下这一段代码： enumerate(self.grid_status)将会返回一个生成器，生成的是每个元素的索引i和对应的值lit，例如：假设self.grid_status = [True, False, True, Flase]，那么生成器将会返回，(0,True),(1,False),(2,True),(3,False) for i, lit in enumerate(self.grid_status)是一个for循环，用来遍历enumerate(self.grid_status)返回的每一个(i,lit)元组，i是索引，lit是self.grid_status中对应的状态值 if not lit这个条件判断会检查lit是否为False，如果为False，就会被加入到列表unlit_grids中 总的来说，这是整个列表推导式的语法，它会创建一个包含所有符合条件if not lit的元素索引i的新列表 random.choice方法在unlit_grids中随机选择一个方格 将选择的的方格状态设置为点亮 增加已点亮的方格数量 更新进度条绘制 如果进度条达到100%，则直接退出该函数，不再循环，也不再接收来自其它线程的消息 paintEvent方法是用以绘制进度条的，创建一个在PyQt中可绘制的对象QPainter。 两层for循环，计算现在的位置，确定这个位置的方格是以点亮还是未点亮，确定颜色，绘制方格。 painter.end方法结束绘制 总结 进度条的更新实际上是对控件的重新绘制 paintEvent在什么时候被调用？\npaintEvent 是一个 Qt 事件处理函数，它在 需要重新绘制组件时 被自动调用。Qt 会在以下几种情况下触发 paintEvent：\n窗口或控件首次显示时： 当窗口或控件第一次显示时，paintEvent 会被触发，负责绘制控件的初始状态。 控件大小发生变化时： 如果控件的大小发生了变化（例如，窗口调整大小），paintEvent 会被调用来重新绘制控件，以适应新的尺寸。 调用 update() 或 repaint() 时： 当你调用 update() 或 repaint() 方法时，Qt 会标记该控件为“需要重绘”，并会在下一个事件循环中触发 paintEvent。 其他因素： 如果控件的内容发生了变化，或者某些部分被遮挡并随后暴露出来，Qt 会重新触发 paintEvent 来重新绘制这些区域。例如，当窗口被部分遮挡后再显示出来时，Qt 会调用 paintEvent 来刷新被遮挡的部分。 在上面的代码中，每次更新进度条的状态时，调用self.update，重新绘制控件。\n如果不适用self.update，而是直接调用paintEvent绘制进度条可以吗？\n直接调用 paintEvent 来重绘进度条并不是一种推荐的做法。原因在于，Qt 的事件机制是自动管理绘制过程的，而直接调用 paintEvent 会绕过事件系统，可能导致一些问题。下面我将详细解释原因和影响。\nQt 的绘制机制： 在 Qt 中，paintEvent 由事件循环自动管理，通常不需要直接调用。当你调用 self.update() 时，Qt 会将控件标记为“需要重绘”，并在合适的时机调用 paintEvent。 self.update() 会触发一个绘制事件，但不会立即调用 paintEvent，而是将重绘请求加入事件队列，稍后由 Qt 的事件循环处理。这样做的好处是，Qt 会合理地合并多个绘制请求，避免频繁的重复重绘，提高性能。 直接调用 paintEvent 的问题： 如果你直接调用 paintEvent，就会绕过 Qt 的事件循环和绘制机制。paintEvent 通常是由系统在适当时机（如控件需要重绘时）自动触发的。 直接调用paintEvent可能会导致： 绘制不一致：因为 Qt 的绘制机制已经负责了缓存和重绘的时机，直接调用 paintEvent 可能会与其他重绘请求冲突，导致绘制不稳定。 不符合最佳实践：Qt 推荐使用 update() 来请求重绘，因为它利用了 Qt 内部的绘制优化策略。如果你直接调用 paintEvent，可能会破坏这些优化。 通过消息队列传递更新消息 进度条的更新实际上需要与编解码器的编解码进度相关，因为编解码器吃算力，因此不建议将编解码器放在主线程中运行，所以对编解码器开了子线程运行，消息的互传需要通过消息队列来进行。关于线程问题，我们将在下一期内容时更详细地讲解。\n祝你变得更强！\n因为语音编解码器功能模块的实现较为复杂，而且也增加了一些新的UI设计，因此知识点与代码都无法在一篇文章中全部呈现，但将代码分散在不同的文章里又让一些基础比较薄弱的同学难以快速上手，因此，如若对此模块感兴趣的人比较多，笔者将在这三篇文章的基础上，单独开一篇新的博文，梳理代码的布局以及如何在自己的机器上跑起来，让新手小白也能复制即用。\n","date":"2024-12-13T13:26:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%8D%81%E4%B8%80/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%8D%81%E4%B8%80/","title":"基于PyQt开发的脚本集合包（十一）"},{"content":"前言 从本篇文章开始，接下来的三篇文章，我们将实现音频编解码器功能模块，第一篇文章，也就是本文，我们将实现基于开源的IMA-ADPCM算法的音频编解码器，第二篇文章，我们将实现自定义的特色进度条以及简单介绍编码器的UI布局，在第三篇文章中 ，我们将实现编解码器的UI以及进度条与编解码器的消息传递。这三篇文章涉及到的知识点较多，比如ADPCM编解码的实现算法，python脚本使用subprocess调用C编译的exe可执行文件，python的多线程功能应用，线程之间的消息传递，还有特色进度条的实现等等。知识点很多，也是笔者自己一点一点摸索出来的，有许多不足的地方，还请多多指正批评。同时，模块的代码分布在三篇文章中，在第三篇文章的结尾，笔者会给出代码的存放的工程目录，这样大家就可以理解代码中的import模块导入。\n本文开始讲述实现音频的编解码，目前笔者只写了一个算法，APDCM，产生笔者自写ADPCM的原因是笔者当初使用ffmpeg解一些经过ADPCM压缩后的数据，发现非常困难，不是因为ffmpeg没有ADPCM解码算法，而是它拥有太多ADPCM算法了，如果你安装了ffmpeg的话，使用命令ffmpeg -codecs可以查询ffmpeg内置的编解码库，关于ADPCM的就有如下： 我并没有完全看完这些ADPCM算法各有哪些不同，笔者只对比过一些变种，如微软的ADPCM，adpcm_ms，它生成的二进制文件前会增加一些头部信息，指明其是由adpcm_ms编码的，其编码算法究竟和开源的ADPCM究竟有何不同，本文没有做详细的对比，但就其加的头部信息，就让其无法解码经过经典开源ADPCM算法编码的音频数据。因此笔者就根据开源的ADPCM算法，自行编写编解码器。\nADPCM算法原理 本文不对ADPCM算法做非常详细的数学推导，只介绍大概思想原理，如想了解更详细的原理，可以推荐可以去看看ADPCM(自适应差分脉冲编码调制)的原理和计算_单片机使用adpcm音频编解码算法-CSDN博客这篇文章。关于原理部分，笔者对这篇文章做一些简单地整理。\nADPCM(Adaptive Differential Pulse Code Modulation)自适应差分脉冲编码调制 ADPCM是DPCM的进阶版本，而DPCM是改良PCM而来的，我们先介绍PCM\nPCM，脉冲编码调制，是声音模拟信号数字化的一种基础技术，本质上是将时间连续取值的模拟信号转换成离散的数字信号，即模数转换，事实上，“连续”这个词在机器上是非常难以实现的，现在大多数的“连续”，实际上都是快速且频繁的“离散”组成的，包括音频，视频等。过程就是采样，量化和编码。首先由硬件机器采样，将采样得到的信号幅度转换成数字（ADC）。PCM实际上就是一个大数组，数组中的每个值，代表了当前时间点上的模拟量强度。\n在量化过程中会产生误差，一般而言，ADC的精度越高，失真越小，常见的量化数位8比特，16比特，32比特。\nDPCM，差分脉冲编码调制，PCM是原始采样数据，即不对数据做压缩，保存的是最原始采样结果，这样的是数据量是比较大的，尤其在嵌入式设备中，硬件规格较低，在存储空间以及功耗方面都有比较严格的要求，传输PCM数据显然是不合适的。因此，我们需要对PCM数据进行压缩。\n对音频数据归纳时可以看到，数据值与相邻的值通常相差不大，即过渡得比较平滑，不会忽高忽低，因此两点之间得差值不会太大，所以我们可以使用差值来表示下一个数据，而这个差值，可以用很少的位数(比如4比特)来进行表示，这样，如果PCM的量化位数位16比特时（一般会采用16比特），那么使用差分法将会把数据缩小成原来的1/4。\n以8K的采样率为例，即1秒钟，机器采样8000次，量化精度为16比特，则1秒钟的数据量为 8000 * 16bit = 8000 * 2 byte = 128 000 bit = 128kb，如果用4bit表示差值，则1秒钟的数据仅需存储32kb左右的数据量。\nDPCM存在一个问题，虽然音频数据大多数时候是比较平滑的，但是还是存在差值较大的情况，如果差值超过了4比特(-15,15)，就无法很好地还原原来的数据，这时候如果增大差值宽度，例如将4比特调整为6比特或8比特，可以减少此问题的发送概率，但同样地，数据量增大了。\nADPCM的出发点就是解决DPCM的差值宽度问题，通过采用一个差值表（IMA ADPCM中使用89个固定差值，取值从7到32767），将差值的范围放宽到16bit，此时差值在数组中的编号只需要6bit就可以表示（0，88），再进一步只记录编号的变化值，就将变化量压缩到4bit。\n16bit的 IMA ADPCM 编码产生的数据为一个数组, 数组中每个数都是4个bit(值范围为0x00到0x0F), 因为C语言编程中变量的最小单位是byte, 所以通常表示为 uint8_t 数组, 数组中每个元素存储2个 ADPCM 编码值, 或者对于32位系统使用 uint32_t, 每个元素存储8个 ADPCM 编码值.\n对于IMA ADPCM, 还需要了解两个码表, 一个是差值步长码表, 一个是差值步长下标变化量码表\n差值步长码表: 下标从0到88, 共89个值, 从小到大, 非均匀分布, 下标越大, 值之间的间隔越大, 这个码表的具体计算方式不清楚, 通过多次项拟合需要至少4次方到5次方才能拟合。 差值步长下标变化量码表: 下标从-7到7, ADPCM 队列中每个值可以通过这个直接查表得到下一个值的差值步长的下标变化量, 进而得到下一个值的差值步长. 值在 [-3, 3] 之间的, 变化都是-1, 也就是差值步长变小, 在[-4,-7]和[4,7]的, 变化是2,4,6,8, 可以看到对于-7和7, 差值步长会快速增大。\n下面给出ADPCM解码和编码C程序\nADPCM解码代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;adpcm.h\u0026#34; void adpcm_decoder(char indata[], short outdata[], int len, adpcm_state_t* state) { const static int indexTable[16] = { -1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8, }; const static int stepsizeTable[89] = { 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767 }; adpcm_state_t voice_adpcmState; signed char* inp; short* outp; int sign; int delta; int step; int valpred; int vpdiff; int index; int inputbuffer; int bufferstep; outp = outdata; inp = (signed char*)indata; valpred = state-\u0026gt;valprev; index = state-\u0026gt;index; step = stepsizeTable[index]; bufferstep = 0; len *= 2; for ( ; len \u0026gt; 0 ; len-- ) { if ( bufferstep ) { delta = inputbuffer \u0026amp; 0xf; } else { inputbuffer = *inp++; delta = (inputbuffer \u0026gt;\u0026gt; 4) \u0026amp; 0xf; } bufferstep = !bufferstep; index += indexTable[delta]; if ( index \u0026lt; 0 ) index = 0; if ( index \u0026gt; 88 ) index = 88; sign = delta \u0026amp; 8; delta = delta \u0026amp; 7; vpdiff = step \u0026gt;\u0026gt; 3; if ( delta \u0026amp; 4 ) vpdiff += step; if ( delta \u0026amp; 2 ) vpdiff += step\u0026gt;\u0026gt;1; if ( delta \u0026amp; 1 ) vpdiff += step\u0026gt;\u0026gt;2; if ( sign ) valpred -= vpdiff; else valpred += vpdiff; if ( valpred \u0026gt; 32767 ) valpred = 32767; else if ( valpred \u0026lt; -32768 ) valpred = -32768; step = stepsizeTable[index]; *outp++ = valpred; } state-\u0026gt;valprev = valpred; state-\u0026gt;index = index; } ADPCM编码代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include \u0026#34;adpcm.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; void adpcm_encoder(short indata[], char outdata[], int len, adpcm_state_t* state) { const static int indexTable[16] = { -1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8, }; const static int stepsizeTable[89] = { 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767 }; adpcm_state_t voice_adpcmState; short* inp; signed char* outp; int val; int sign; int delta; int diff; int step; int valpred; int vpdiff; int index; int outputbuffer; int bufferstep; outp = (signed char*)outdata; inp = indata; valpred = state-\u0026gt;valprev; index = state-\u0026gt;index; step = stepsizeTable[index]; bufferstep = 1; len /= 2; for ( ; len \u0026gt; 0 ; len-- ) { val = *inp++; diff = val - valpred; sign = (diff \u0026lt; 0) ? 8 : 0; if ( sign ) diff = (-diff); delta = 0; vpdiff = (step \u0026gt;\u0026gt; 3); if ( diff \u0026gt;= step ) { delta = 4; diff -= step; vpdiff += step; } step \u0026gt;\u0026gt;= 1; if ( diff \u0026gt;= step ) { delta |= 2; diff -= step; vpdiff += step; } step \u0026gt;\u0026gt;= 1; if ( diff \u0026gt;= step ) { delta |= 1; vpdiff += step; } if ( sign ) valpred -= vpdiff; else valpred += vpdiff; if ( valpred \u0026gt; 32767 ) valpred = 32767; else if ( valpred \u0026lt; -32768 ) valpred = -32768; delta |= sign; index += indexTable[delta]; if ( index \u0026lt; 0 ) index = 0; if ( index \u0026gt; 88 ) index = 88; step = stepsizeTable[index]; if ( bufferstep ) { outputbuffer = (delta \u0026lt;\u0026lt; 4) \u0026amp; 0xf0; } else { *outp++ = (delta \u0026amp; 0x0f) | outputbuffer; } bufferstep = !bufferstep; } if ( !bufferstep ) *outp++ = outputbuffer; state-\u0026gt;valprev = valpred; state-\u0026gt;index = index; } 在代码中，已经把差分表以及步长表都放在了函数中\n下面给出编码器与解码器共用的头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #ifndef __ADPCM_H__ #define __ADPCM_H__ struct adpcm_state { short valprev; char index; }; typedef struct adpcm_state adpcm_state_t; void adpcm_decoder(char [], short [], int, struct adpcm_state*); void adpcm_encoder(short [], char [], int, struct adpcm_state*); #endif 在这个头文件中，存放着一个结构体，adpcm_state，该结构体有两个变量，valprev表示预测值，index表示步长。\n每次计算后，都会生成一个新的valprev和index，用以计算下一个值，因此，我们如果想要做一个编解码器，则必须向该程序中传递输入数组，adpcm_state以及数据长度。\n上面是ADPCM的编码与解码算法，注意，上面的算法并不能直接构成一个可执行文件，因为没有main函数入口\n因为我们的数据是通过python来进行读写的，因此我们要通过python将数据传入ADPCM编码器与解码器的入口，由入口对数据稍作处理，再传入ADPCM算法中进行运算，输出的结果由入口打印出来，打印的结果被python捕获并写入相应的文件中。\n下面给出ADPCM编解码器的入口\nAdpcmDecMain 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;errno.h\u0026gt; #include \u0026#34;adpcm.h\u0026#34; /****************************************************************** ADPCM is a lossless data compression algorithm. it is used in video and audio compression. it is a type of adaptive differential pulse code modulation (ADPCM). ADPCM is a type of lossless data compression algorithm that uses a variable bit rate to encode audio or video data. in this example, adpcm has three five arguments: valprev, index, indata, outdata, len. len: the length of outdata which is the double of indata.But it is quadruple of data that was compress by adpcm, because the data type of indata is char(1 octet), the data type of outdata is short(2 octet). The compression ratio is 4:1 */ int main(int argc, char *argv[]) { // 如果没有输入参数，则直接返回错误 if(argc \u0026lt;= 1) { printf(\u0026#34;No arguments provided\\n\u0026#34;); return 1; } errno = 0; // 获取参数，并将参数转换成十六进制，如果遇见非法参数，则返回错误 char invalue[argc-1]; for(int i = 1; i \u0026lt; argc; i++) { char * endptr; //argv[i]是字符串，需要转换成十六进制 //endptr是一个指向char的指针，用于指向字符串的结尾 //16 表示十六进制转换 //strtol是一个标准库函数，用于将字符串转换成整数，他将返回一个long类型的值 invalue[i-1] = (char)strtol(argv[i], \u0026amp;endptr, 16); if(*endptr != \u0026#39;\\0\u0026#39; || endptr == argv[i] || errno == ERANGE) { printf(\u0026#34;Invalid argument: %s\\n\u0026#34;, argv[i]); return 1; } } // 将参数中，index，prevalue和data的值提取出来 // 定义变量 char indata[argc-3]; short valprex = 0; char index = 0; int len = argc-3; // 通过检查参数的长度来确定数据的长度 // 提取data for(int i = 0; i\u0026lt;len; i++) { indata[i] = invalue[i+2]; } // 提取valprex和index valprex = (short) invalue[0]; index = invalue[1]; adpcm_state_t voice_adpcmState; voice_adpcmState.valprev = valprex; voice_adpcmState.index = index; // 进行解码 outdata的长度冗余 short outdata[276] = {0}; adpcm_decoder(indata, outdata, len,\u0026amp;voice_adpcmState); // 循环打印结果，被python脚本捕获 for(int i = 0; i \u0026lt; len * 2; i ++) { printf(\u0026#34; %04hx \u0026#34;,outdata[i]); } printf(\u0026#34; %04hx \u0026#34;,voice_adpcmState.valprev); printf(\u0026#34; %02x \u0026#34;,voice_adpcmState.index); return 0; } 我们能以解码器入口为例来解释代码，编码器入口同理：\nmain函数接收参数，第一个参数无疑是函数名，第二个参数是valprev，第三个参数是index，第四个参数往后是待解码的数据。 解释一下strtol函数，argv[i]是输入参数，\u0026amp;endptr是一个指向char*的指针，它将在解析后指向第一个不属于数字部分的字符（如果整个字符串都是有效数字，它将指向字符串的末尾）。16是十六进制。 strtol函数会返回一个long类型的整数值，它是从字符串中解析出来的，如果字符串中包含无效字符，strtol将会在该字符串处停止解析，endptr将会指向该处。 outdata做了冗余处理，根据经验，一语音帧最大138个字节。len是传入的待解码的数据长度，如若供有20个字节的待解码数据，则len=20 有同学能猜出为什么循环打印outdata要乘以2吗？总结时会给出解释。 将outdata打印出来，被python脚本捕获，将valprev与index一起打印，被python脚本捕获，在下一轮数据来临时，带上valprev和index。 在这里敏锐的同学可能会注意到，我们在输入时，valprev和index参数是放在数据前面的，而在输出时，则是放在数据后面的，使用的同学需注意这一点，并没有什么特殊含义，只是笔者当初脚本先传的valprev和index，而编解码器后给出这两个值，笔者没改过来而已。 在此轮解码结束后，编码器将结束生命周期，此时内存将全部释放，valprev与index将会丢失，因此必须抛出给python脚本，以供下一次解码时使用 AdpcmEncMain 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;errno.h\u0026gt; #include \u0026#34;adpcm.h\u0026#34; /****************************************************************** ADPCM is a lossless data compression algorithm. it is used in video and audio compression. it is a type of adaptive differential pulse code modulation (ADPCM). ADPCM is a type of lossless data compression algorithm that uses a variable bit rate to encode audio or video data. in this example, adpcm has three five arguments: valprev, index, indata, outdata, len. len: the length of outdata which is the double of indata.But it is quadruple of data that was compress by adpcm, because the data type of indata is char(1 octet), the data type of outdata is short(2 octet). The compression ratio is 4:1 */ int main(int argc, char *argv[]) { adpcm_state_t voice_adpcmState; short indata[argc-3]; short valprex = 0; char index = 0; int len = (argc-3)*2; //如果没有输入参数，则直接返回错误 if(argc \u0026lt;= 1) { printf(\u0026#34;No arguments provided\\n\u0026#34;); return 1; } errno = 0; //获取参数，并将参数转换成十六进制，如果遇见非法参数，则返回错误 for(int i = 1; i \u0026lt; argc; i++) { char * endptr; //argv[i]是字符串，需要转换成十六进制 //endptr是一个指向char的指针，用于指向字符串的结尾 //16 表示十六进制转换 //strtol是一个标准库函数，用于将字符串转换成整数，他将返回一个long类型的值 if( i == 1 ) { valprex = (short)strtol(argv[i], \u0026amp;endptr, 16); } else if ( i == 2 ) { index = (char)strtol(argv[i], \u0026amp;endptr, 16); } else { indata[i-3] = (short)strtol(argv[i], \u0026amp;endptr, 16); } if(*endptr != \u0026#39;\\0\u0026#39; || endptr == argv[i] || errno == ERANGE) { printf(\u0026#34;Invalid argument: %s\\n\u0026#34;, argv[i]); return 1; } } voice_adpcmState.valprev = valprex; voice_adpcmState.index = index; // 进行解码 outdata的长度冗余 char outdata[276] = {0}; adpcm_encoder(indata, outdata, len, \u0026amp;voice_adpcmState); // 循环打印结果，被python脚本捕获 for(int i = 0; i \u0026lt; len / 4; i ++) { printf(\u0026#34; %02hhx \u0026#34;,(unsigned char)outdata[i]); } printf(\u0026#34; %04hx \u0026#34;,voice_adpcmState.valprev); printf(\u0026#34; %02x \u0026#34;,voice_adpcmState.index); return 0; } 编码器入口与解码器入口大差不差，大家仔细阅读即可\n编译 在本文中可以看到，我们采用了一个头文件，一个c文件存放编码算法，一个c文件存放程序入口这种形式来组织代码，这样的好处是方便整理代码，可读性更高，但同时呢，无法直接运行，因为编码算法的c文件与程序入口的c文件并没有链接到一起，因此程序入口无法找到adpcm_encoder和adpcm_decoder的函数实现，我们需要使用GCC命令来对文件进行手动编译。命令如下：\n1 gcc AdpcmDecMain.c AdpcmDec.c -o AdpcmDecoder 这条命令的作用是：\n将AdpcmDecMain.c文件与AdpcmDec.c文件编译并链接在一起，生成一个名为AdpcmDecoder.exe的可执行文件\n总结 这篇文章总的来说笔者不是很满意，因为并没有仔细解释ADPCM的原理，笔者认为ADPCM(自适应差分脉冲编码调制)的原理和计算_单片机使用adpcm音频编解码算法-CSDN博客这篇文章已经给出的非常详细，笔者解释只是锦上添花，而笔者也没有想到更好的理解方法，如果笔者后续对这些音频算法有更深的理解时，笔者会做出整理。\n现在给出上面的问题的解释，为什么循环打印outdata要乘以2，这是因为，我们解码前的数据存储的是前一个数据与后一个数据的差分，仅用4bit存储，而解码后的单个PCM数据就有16bit，但在C语言中，最小存储单位为uint8_t，即8个比特，在本程序中，解码前的数据用char存储，也是8个比特，也就是说，一个indata能存储两个差分数据，即两个解码前的数据，outdata数组的数据类型是short即16个比特，一个解码的indata，解码后需要两个outdata来存储才行，这样，outdata的长度就是indata的2倍\n为什么编码器的循环要除以4呢，同理，ADPCM的压缩比为4：1，至于为什么是4倍而不是两倍，主要是因为编码器的len是输入参数的两倍，这与解码器不同，与adpcm算法内部的len有关。\npython脚本将在下一篇文章中展现，本文到这里就结束啦，祝大家变得更强！\n因为语音编解码器功能模块的实现较为复杂，而且也增加了一些新的UI设计，因此知识点与代码都无法在一篇文章中全部呈现，但将代码分散在不同的文章里又让一些基础比较薄弱的同学难以快速上手，因此，如若对此模块感兴趣的人比较多，笔者将在这三篇文章的基础上，单独开一篇新的博文，梳理代码的布局以及如何在自己的机器上跑起来，让新手小白也能复制即用。\n","date":"2024-12-12T22:23:00+08:00","image":"https://Lyrical-wander.github.io/p/adpcm%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/AudioWave_hu14236730171867375332.jpg","permalink":"https://Lyrical-wander.github.io/p/adpcm%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"ADPCM编解码器的实现"},{"content":"前言 距离上次更新PyQt实战系列隔了好久，因为现实中比较忙，而且确实是存货已经用完，现在对脚本集合包更新了一些新的内容，包括：JSON数据的处理，ADPCM音频编解码，PCM二进制文件构建以及PCMM音频播放功能，此外，还有一个数据加密解密算法，与笔者之前的文章《逆向工程实战，在反汇编中发生的事》中的算法一致，是笔者在反汇编的学习中无意间发现的一种数据加密算法，简单且有效，当初逆向该算法时花了不少时间，总之，这些内容后续都会讲到！\nJSON数据处理UI 本功能的UI设计十分简单，用到的全是PyQt5实战系列提及过的内容，因此本文将不再重复讲解UI界面的代码，但是代码依然会贴出来，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from PyQt5.QtWidgets import * from PyQt5.QtGui import * from PyQt5.QtCore import * from PyQt5.QtSvg import * from component.btnStyle import * from component.editStyle import * from component.getPath import * from tools.wiresharckJsonProcess import * class WwiresharkJsonProc(QWidget): def __init__(self): super().__init__() self.filePaths = [\u0026#39;\u0026#39;] self.initUI() def initUI(self): self.JsonProcesslayout = QVBoxLayout() self.setLayout(self.JsonProcesslayout) # 文件选择 self.filelayout = QHBoxLayout() self.lable = QLabel(\u0026#34;请选择文件\u0026#34;,self) self.filelayout.addWidget(self.lable) self.input = QLineEdit(self) LineEditStyle(self.input) self.filelayout.addWidget(self.input) self.choosebtn = QPushButton(\u0026#34;选择文件\u0026#34;,self) btnReleaseStyleA(self.choosebtn) self.choosebtn.clicked.connect(self.getpath) self.filelayout.addWidget(self.choosebtn) self.JsonProcesslayout.addLayout(self.filelayout) # 开始处理 self.exebtn = QPushButton(\u0026#34;开始处理\u0026#34;,self) btnReleaseStyleA(self.exebtn) self.exebtn.clicked.connect(self.exebtn_press_clicked) self.JsonProcesslayout.addWidget(self.exebtn) def getpath(self): get_path(self) self.input.setText(self.filePaths[0]) def exebtn_press_clicked(self): processJson(self.filePaths[0]) 界面非常简单，如下所示\n可以看到，在这个页面下仅有一个文件选择的组件加上一个处理的按钮。非常简单的一个页面设计，本文的重点并不在这个UI设计上，而是在wireshark的抓包数据转换成JSON格式以及python提取JSON数据。\nJSON数据的来源 本文所使用的JSON数据来源于wireshark抓包，wireshark是一个网络封包分析工具，可以截取各种网络数据包，并显示数据包中的各种详细信息，常用于开发测试过程中的问题定位。但笔者并不是用wireshark来处理网络封包，而是处理低功耗蓝牙(BLE)的封包。wireshark本身并没有捕获BLE数据包的能力，但是结合特殊的dongle可以，使用NRF52832 BLE Sniffer低功耗蓝牙抓包器可以捕捉到到低功耗蓝牙的空中数据，非常实用，感兴趣的同学可以在网上查询相关信息，本文不做赘述。\n这里笔者对一个数据包做了筛选，如下图所示，从机通过notify的形式向主机传递消息，消息通过handle值为0x97的特征传递给主机，这里不了解蓝牙的同学可以不用理会，以后笔者会单独出一个蓝牙系列，分享笔者的蓝牙知识。\n在下面详细信息中可以看到，所选中的这一条数据，是从机通过handle为0x97的特征，向主机发送共计120个字节的value数据：3b 18 01 ....... 04 d1 1a，如果手动一条一条数据中蓝色框框的内容复制出来是非常耗时的，可以采用以下方式获取数据：\n文件 → 导出分组解析结果 → As JSON\n可以导出JSON格式的数据，我们展示一下JSON数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 [ { \u0026#34;_index\u0026#34;: \u0026#34;packets-2024-12-06\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;doc\u0026#34;, \u0026#34;_score\u0026#34;: null, \u0026#34;_source\u0026#34;: { \u0026#34;layers\u0026#34;: { \u0026#34;frame\u0026#34;: { \u0026#34;frame.section_number\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;frame.interface_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;frame.interface_id_tree\u0026#34;: { \u0026#34;frame.interface_name\u0026#34;: \u0026#34;COM30-4.0\u0026#34;, \u0026#34;frame.interface_description\u0026#34;: \u0026#34;nRF Sniffer for Bluetooth LE COM30\u0026#34; }, \u0026#34;frame.encap_type\u0026#34;: \u0026#34;186\u0026#34;, \u0026#34;frame.time\u0026#34;: \u0026#34;Dec 6, 2024 11:19:43.491844000 中国标准时间\u0026#34;, \u0026#34;frame.offset_shift\u0026#34;: \u0026#34;0.000000000\u0026#34;, \u0026#34;frame.time_epoch\u0026#34;: \u0026#34;1733455183.491844000\u0026#34;, \u0026#34;frame.time_delta\u0026#34;: \u0026#34;0.000231000\u0026#34;, \u0026#34;frame.time_delta_displayed\u0026#34;: \u0026#34;0.000000000\u0026#34;, \u0026#34;frame.time_relative\u0026#34;: \u0026#34;62.812024000\u0026#34;, \u0026#34;frame.number\u0026#34;: \u0026#34;12534\u0026#34;, \u0026#34;frame.len\u0026#34;: \u0026#34;53\u0026#34;, \u0026#34;frame.cap_len\u0026#34;: \u0026#34;53\u0026#34;, \u0026#34;frame.marked\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;frame.ignored\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;frame.protocols\u0026#34;: \u0026#34;nordic_ble:btle:btl2cap:btatt\u0026#34; }, \u0026#34;nordic_ble\u0026#34;: { \u0026#34;nordic_ble.board_id\u0026#34;: \u0026#34;30\u0026#34;, \u0026#34;nordic_ble.header\u0026#34;: { \u0026#34;nordic_ble.plen\u0026#34;: \u0026#34;46\u0026#34;, \u0026#34;nordic_ble.protover\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;nordic_ble.packet_counter\u0026#34;: \u0026#34;36765\u0026#34;, \u0026#34;nordic_ble.packet_id\u0026#34;: \u0026#34;6\u0026#34; }, \u0026#34;nordic_ble.len\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;nordic_ble.flags\u0026#34;: \u0026#34;0x0d\u0026#34;, \u0026#34;nordic_ble.flags_tree\u0026#34;: { \u0026#34;nordic_ble.crcok\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;nordic_ble.direction\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;nordic_ble.encrypted\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;nordic_ble.micok\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;nordic_ble.phy\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;nordic_ble.flag_reserved7\u0026#34;: \u0026#34;0\u0026#34; }, \u0026#34;nordic_ble.channel\u0026#34;: \u0026#34;29\u0026#34;, \u0026#34;nordic_ble.rssi\u0026#34;: \u0026#34;-45\u0026#34;, \u0026#34;nordic_ble.event_counter\u0026#34;: \u0026#34;1158\u0026#34;, \u0026#34;nordic_ble.time\u0026#34;: \u0026#34;1172995411\u0026#34;, \u0026#34;nordic_ble.packet_time\u0026#34;: \u0026#34;296\u0026#34;, \u0026#34;nordic_ble.delta_time\u0026#34;: \u0026#34;151\u0026#34;, \u0026#34;nordic_ble.delta_time_ss\u0026#34;: \u0026#34;231\u0026#34; }, \u0026#34;btle\u0026#34;: { \u0026#34;btle.access_address\u0026#34;: \u0026#34;0x27353836\u0026#34;, \u0026#34;btle.master_bd_addr\u0026#34;: \u0026#34;90:e4:68:a8:41:7c\u0026#34;, \u0026#34;btle.slave_bd_addr\u0026#34;: \u0026#34;00:00:00:08:47:2c\u0026#34;, \u0026#34;btle.data_header\u0026#34;: { \u0026#34;btle.data_header.llid\u0026#34;: \u0026#34;0x02\u0026#34;, \u0026#34;btle.data_header.next_expected_sequence_number\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;btle.data_header.sequence_number\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;btle.data_header.more_data\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;btle.data_header.cte_info_present\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;btle.data_header.rfu\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;btle.data_header.length\u0026#34;: \u0026#34;27\u0026#34; }, \u0026#34;btle.length\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;btle.l2cap_index\u0026#34;: \u0026#34;132\u0026#34;, \u0026#34;btle.connection_parameters_in\u0026#34;: \u0026#34;11696\u0026#34;, \u0026#34;btle.crc\u0026#34;: \u0026#34;0xe3cc46\u0026#34; }, \u0026#34;btl2cap\u0026#34;: { \u0026#34;btl2cap.length\u0026#34;: \u0026#34;23\u0026#34;, \u0026#34;btl2cap.cid\u0026#34;: \u0026#34;0x0004\u0026#34; }, \u0026#34;btatt\u0026#34;: { \u0026#34;btatt.opcode\u0026#34;: \u0026#34;0x1b\u0026#34;, \u0026#34;btatt.opcode_tree\u0026#34;: { \u0026#34;btatt.opcode.authentication_signature\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;btatt.opcode.command\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;btatt.opcode.method\u0026#34;: \u0026#34;0x1b\u0026#34; }, \u0026#34;btatt.handle\u0026#34;: \u0026#34;0x0036\u0026#34;, \u0026#34;btatt.handle_tree\u0026#34;: { \u0026#34;btatt.service_uuid16\u0026#34;: \u0026#34;0x1812\u0026#34; }, \u0026#34;btatt.value\u0026#34;: \u0026#34;60:d8:4b:d4:62:66:d9:d5:4c:d5:5f:d6:d3:5d:63:da:64:d7:61:d8\u0026#34; } } } }, 这么长的数据，仅仅wireshark中展示的一条数据，而我们需要的数据，仅仅是btatt.value这一个属性\n1 \u0026#34;btatt.value\u0026#34;: \u0026#34;60:d8:4b:d4:62:66:d9:d5:4c:d5:5f:d6:d3:5d:63:da:64:d7:61:d8\u0026#34; 而敏锐的同学可以发现，此JSON文件的开头，是[，也就是说，此JSON文件的框架是[{第一条数据},{第二条数据}....{第n条数据}...]，这种格式非常适合python通过list数据结构进行处理。\nJSON数据提取 先来观察我们需要的目标数据，btatt.value，这是由多层字典嵌套在其中的，因此要依次往上查找不同层级的字典，可以发现：\n__source layers btatt btatt.value 是这样的一个结构。\n我们现在来看代码\n1 2 3 4 5 6 7 8 9 10 11 12 import json def processJson(filename): with open(filename, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: attvalue = json.load(f) for i in range(len(attvalue)): voicevalue = attvalue[i][\u0026#34;_source\u0026#34;][\u0026#34;layers\u0026#34;][\u0026#34;btatt\u0026#34;][\u0026#34;btatt.value\u0026#34;] + \u0026#34;\\n\u0026#34; with open(\u0026#34;workspaces/VoiceData.txt\u0026#34;, \u0026#34;a\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(voicevalue) print(\u0026#34;line len: \u0026#34;,len(voicevalue)) print(\u0026#34;line count: \u0026#34;,len(attvalue)) # print(data) 我们来分析一下代码：\n从filename这个文件中读取数据，以utf-8编码格式解码 json.load(f)是指从f中读取数据JSON数据，解析并返回对应的Python对象（例如，字典，列表等，具体取决于JSON的结构），通过我们上面的分析，此json会被解析成python的列表（因为最外层是[]）。 循环读取attvalue列表对象 读取attvallue列表中第i个元素中的layers字典中的btatt字典中的btatt.value所对应的值，并加上一个换行符/n，最后复制给voicevalue 将voicevalue写进workspaces/VoiceData.txt文件的末尾，a表示在文件末尾写入东西，而不覆盖原来的内容。 当将所有的内容都写完时，返回每条数据的数据量以及数据总量 该方法被单独写在wiresharckJsonProcess.py文件中，存放在tools目录下，被UI页面通过import以模块导入的形式使用。\n总结 本文的内容并不复杂，主要是如何从wireshark中导出JSON数据，以及如何使用python对数据进行过滤和处理，JSON是非常常用的数据传输和保存格式尤其在网络中非常常用，因此熟练的掌握看懂和处理对程序员来说是值得的，而且并不难不是吗，祝你变得更强！\n","date":"2024-12-12T19:26:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%8D%81/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%8D%81/","title":"基于PyQt开发的脚本集合包（十）"},{"content":"前言 今天对某外国的机器中的某个音频解码库进行反汇编，发现了一些有趣的知识，故而记录下来，以防以后重复遇到。\n现笔者使用的反汇编工具为“Ghidra”。可在GitHub上下载：NationalSecurityAgency/ghidra: Ghidra is a software reverse engineering (SRE) framework\nGhidra是由美国国家安全局研究局创建和维护的软件逆向工程 (SRE) 框架 。该框架包括一套功能齐全的高端软件分析工具，使用户能够在包括 Windows、macOS 和 Linux 在内的各种平台上分析编译代码。功能包括反汇编、汇编、反编译、绘图和脚本，以及数百个其他功能。\nGhidra由java编写，因此使用Ghidra前先配置java运行环境。\n注：本文不介绍Ghidra的使用\nadpcm_decoder1函数 C代码 笔者通过获取机器日志，发现了机器存在音频解码函数，通过grep命令查询到了，存有相应解码函数的库文件，并将库文件pull了出来，我们来看一下该库文件中相应的解码函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 void adpcm_decoder1(char *param_1,undefined2 *param_2,int param_3,int *param_4) { bool bVar1; uint uVar2; int iVar3; uint uVar4; int iVar5; int iVar6; int iVar7; uint uVar8; char *local_2c; int local_28; undefined2 *local_24; iVar3 = __divsi3(param_3,0x14); for (iVar6 = 0; iVar6 \u0026lt; iVar3; iVar6 = iVar6 + 1) { Decryption(0x32,param_1 + iVar6 * 0x14); } bVar1 = false; uVar8 = 0; iVar5 = param_4[1]; iVar6 = *param_4; iVar3 = *(int *)(\u0026amp;DAT_00019c5c + iVar5 * 4); local_2c = param_1; local_24 = param_2; for (local_28 = param_3 \u0026lt;\u0026lt; 1; 0 \u0026lt; local_28; local_28 = local_28 + -1) { uVar2 = uVar8; if (!bVar1) { uVar8 = (uint)*local_2c; local_2c = local_2c + 1; uVar2 = (int)uVar8 \u0026gt;\u0026gt; 4; } uVar4 = uVar2 \u0026amp; 0xf; bVar1 = (bool)(bVar1 ^ 1); iVar5 = iVar5 + (\u0026amp;DAT_00019dc0)[uVar4]; if (iVar5 \u0026lt; 0) { iVar5 = 0; } else if (0x58 \u0026lt; iVar5) { iVar5 = 0x58; } iVar7 = iVar3 \u0026gt;\u0026gt; 3; if ((int)(uVar4 \u0026lt;\u0026lt; 0x1d) \u0026lt; 0) { iVar7 = iVar7 + iVar3; } if ((int)(uVar4 \u0026lt;\u0026lt; 0x1e) \u0026lt; 0) { iVar7 = iVar7 + (iVar3 \u0026gt;\u0026gt; 1); } if ((uVar2 \u0026amp; 1) != 0) { iVar7 = iVar7 + (iVar3 \u0026gt;\u0026gt; 2); } if ((uVar2 \u0026amp; 8) != 0) { iVar7 = -iVar7; } iVar6 = iVar6 + iVar7; if (iVar6 \u0026lt; -0x8000) { iVar6 = -0x8000; } if (0x7fff \u0026lt; iVar6) { iVar6 = 0x7fff; } iVar3 = *(int *)(\u0026amp;DAT_00019c5c + iVar5 * 4); *local_24 = (short)iVar6; local_24 = local_24 + 1; } *param_4 = iVar6; param_4[1] = iVar5; return; } 以上是反汇编后的结果，Ghidra将机器语言解析成汇编语言，再自动转换成相应的C语言。\nDecryption函数并非ADPCM的一部分 可以看到，这是典型的ADPCM音频解码算法，笔者已经对比过经典的开源ADPCM音频解码算法的C语言版本，确实是相差无几，但在这段代码中，多出了以下内容：\n1 2 3 4 iVar3 = __divsi3(param_3,0x14); for (iVar6 = 0; iVar6 \u0026lt; iVar3; iVar6 = iVar6 + 1) { Decryption(0x32,param_1 + iVar6 * 0x14); } 在解释这一段内容前，读者需要先了解：该机器通过蓝牙接收语音数据，每语音帧20字节。但机器处理不一定是20字节一处理，根据音频收发的速率，丢包率以及buffer的大小决定。\n现在笔者来解释一下这一段的内容：\nparam_3除以20，将结果赋值给iVar3变量，这里计算出一共进来多少语音帧需要处理，每帧20字节 一个for循环，将每帧数据丢入Decryption函数中进行处理 Decryption函数接收两个参数，0x32,一个固定的常量值；param_1 + iVar6 * 0x14，param_1是语音数据的数组指针 Decryption函数的参数问题 这里解释一下Decryption函数接收的两个参数，实际上，Decryption函数接收三个参数，在这里，Ghidra在C中只给出了两个参数，笔者不清楚这是Ghidra的特性还是工具缺陷。对汇编不感兴趣的同学可以跳过这一部分，但推荐看看\n下面会给出Decryption的函数体，在函数体中可以发现Decryption是接收三个参数的，这里我们讲解一下这一段for循环的汇编内容\nC语言：\n1 2 3 for (iVar6 = 0; iVar6 \u0026lt; iVar3; iVar6 = iVar6 + 1) { Decryption(0x32,param_1 + iVar6 * 0x14); } 汇编：\n1 2 3 4 5 6 7 8 9 10 11 12 LAB_00016624 00016624 bc 42 cmp r4,r7 00016626 09 da bge LAB_0001663c 00016628 14 22 movs r2,#0x14 0001662a 62 43 muls r2,r4 0001662c 01 9b ldr r3,[sp,#local_2c ] 0001662e 32 20 movs r0,#0x32 00016630 9a 18 adds r2,r3,r2 00016632 11 1c adds r1,r2,#0x0 00016634 ff f7 38 ff bl Decryption 00016638 01 34 adds r4,#0x1 0001663a f3 e7 b LAB_00016624 这是这个for循环中涉及到的汇编语言，我们尝试在这段汇编中找到Decryption的三个参数\ncmp 指令表示比较，即比较r4与r7寄存器中的值，结合c代码，可以看出，r4，r7分别代表了iVar6和iVar3，但目前不清楚哪个对哪个。 bge 指令是分支指令，表示条件跳转(branch if greater or equal)，即如果大于等于，则跳转。这两个指令合起来为，如果r4≥r7，则跳转到LAB_0001663c代码段，可以看出，已经超出了这个for循环的地址，即退出了for循环。 movs 指令表示移动，将立即数0x14移动到r2寄存器中，现在r2寄存器中存储了0x14这个值。 muls 指令表示乘法，即将r2与r4寄存器中的值相乘，结合c代码可以看到，代码中仅有一个乘法，即iVar6 * 0x14，可以得出，r2 = 0x14，r4 = iVar6。 ldr 指令表示加载寄存器(load register)，语法为：ldr \u0026lt;寄存器\u0026gt;, [\u0026lt;基址寄存器\u0026gt;, \u0026lt;偏移量\u0026gt;]，从基址寄存器中取出地址，加上偏移量，将结果加载到寄存器中，这里取出的地址加载到r3中，在c代码中，只有一个涉及到取址操作，即param_1，这是一个adpcm_decoder1函数接受的传参，传入的是一个指针，即param_1其实是一个数组指针。这里是获取param_1数组的地址，放到r3中。 movs 指令表示移动，将立即数0x32移动到r0寄存器中，现在r0寄存器中存放了0x32这个值。 adds 指令表示加法，将r3与r2相加，并存放到r2寄存器中，即，param_1的地址加上一个计算的偏移量，本质上是从param_1的语音数据中获取第n个语音帧的地址。 adds 指令表示加法，将r2寄存器的值加上立即数0x00存放到r1寄存器中，这操作让r2寄存器存放的内容与r1一致。 bl 指令表示跳转，即跳转到Decryption函数的位置去，执行Decryption函数，并把下一条指令的地址存放到lr寄存器中，以方便Decryption函数执行完能回来，相当于压栈，将Decryption函数压入函数栈。 adds 指令表示加法，将r4 加上立即数0x01，并存放到r4中，即for循环的++操作。 可以看到，在调用Decryption函数前，分别给三个寄存器存放了东西，分别为r0存放了0x32，r1存放了param_1的偏移地址，r2存放与r1相同的东西。这三个寄存器就是Decryption函数用的三个参数。如果还不确定，可以跳转到Decryption函数中查看相应的param_1,param_2,param_3三个参数调用时所使用的寄存器，分别为r0，r1，r2，本文给出结论，不做赘述。\n小结 总而言之，这里的音频解码，虽然使用的是ADPCM算法，但是在raw data与adpcm data之间还加入了一个加密解密过程，即，实际上的过程为：\n原始音频数据raw data → adpcm压缩→ 加密算法 encryption → 蓝牙传输 → 解密算法 decryption → adpcm解压 → 原始音频数据 raw data\n因此，接下来看如何用解密算法还原加密算法\ndecryption函数 C代码 下面是decryption函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void Decryption(byte param_1,int param_2,int param_3) { int *piVar1; byte bVar2; int iVar3; int iVar4; byte local_30 [20]; int local_1c; local_1c = __stack_chk_guard; iVar3 = 0; do { local_30[iVar3] = *(byte *)(param_2 + iVar3); iVar3 = iVar3 + 1; } while (iVar3 != 0x14); iVar3 = 0x13; do { iVar4 = iVar3 * 4; piVar1 = \u0026amp;DAT_00019c08 + iVar3; bVar2 = (byte)iVar3; iVar3 = iVar3 + -1; local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] = local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] + local_30[*piVar1] ^ bVar2 ^ param_1; } while (iVar3 != 0); local_30[0] = local_30[0] - 0x3e ^ param_1; iVar3 = 0; do { *(byte *)(param_3 + iVar3) = local_30[iVar3]; iVar3 = iVar3 + 1; } while (iVar3 != 0x14); if (local_1c != __stack_chk_guard) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } 笔者依次解释上面的代码\n数据本地化 1 2 3 4 5 6 iVar3 = 0; do { local_30[iVar3] = *(byte *)(param_2 + iVar3); iVar3 = iVar3 + 1; } while (iVar3 != 0x14); iVar3 = 0x13; 这一段代码其实很好看出是在做什么，就是将传入的数据存在函数内部的局部变量中，iVar3变量是一个很重要的变量，在后续计算中会用到，记住它。在将所有数据搬完之后（一共20个字节，一语音帧20个字节），iVar3变量来到了0x13，十进制19\n第19到1的数据解码 1 2 3 4 5 6 7 8 do { iVar4 = iVar3 * 4; piVar1 = \u0026amp;DAT_00019c08 + iVar3; bVar2 = (byte)iVar3; iVar3 = iVar3 + -1; local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] = local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] + local_30[*piVar1] ^ bVar2 ^ param_1; } while (iVar3 != 0); 这里有一个很容易混淆的地方，就是标题采用的“第19到第1”这个概念，我们只能说，从while循环，从iVar3变量的角度，是“从19到1”，而从数据的角度说并不是这样。为了强化读者这个概念，我们先介绍local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)]与local_30[*piVar1]这两个变量。\nlocal_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] 首先，从定义上看byte local_30 [20];，local_30是一个数组的局部变量，且具有20个元素的大小，每个元素的大小为1byte，即，该数组是专门存放音频数据的。\n其次，我们先看local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)]，数组的内部index部分很复杂，我们来做介绍\n\u0026amp;DAT_00019c0c是内存中的一个地址 \u0026amp;DAT_00019c0c + iVar4表示这个地址 + 一个偏移量，组成一个新的地址 (int *)(\u0026amp;DAT_00019c0c + iVar4)表示将这个地址被强制类型转换为int类型的指针 *(int *)(\u0026amp;DAT_00019c0c + iVar4)表示取值这个int指针，即从这个地址中取值，这个值是int类型的 然后，我们来看这个iVar4变量，iVar4 = iVar3 * 4，在每一次循环中，iVar4都会被更新一次，且更新为iVar3 * 4，iVar3在每次循环中会被做-1操作。也就是说，第一次iVar4 = 19 * 4，第二次为iVar4 = 18 * 4，以此类推。\n最后，我们查查这个DAT_00019c0c，以及它对应的偏移量中究竟存了什么东西，通过Ghidra的汇编地址中可以查到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 DAT_00019c0c 00019c0c 00 ?? 00h 00019c0d 00 ?? 00h 00019c0e 00 ?? 00h 00019c0f 00 ?? 00h 00019c10 0c ?? 0Ch 00019c11 00 ?? 00h 00019c12 00 ?? 00h 00019c13 00 ?? 00h 00019c14 0d ?? 0Dh # 为方便阅读，此处省略部分...... 00019c4c 01 ?? 01h 00019c4d 00 ?? 00h 00019c4e 00 ?? 00h 00019c4f 00 ?? 00h DAT_00019c50 00019c50 02 00 00 00 undefine 00000002h DAT_00019c54 00019c54 07 00 00 00 undefine 00000007h DAT_00019c58 00019c58 08 00 00 00 undefine 00000008h 0x00019c0c地址存放的数据为0x00，隔4个字节后，0x00019c10地址存放的数据为0x0c\u0026hellip;\u0026hellip;一直到19 * 4个字节，即0x00019c58存放的数据为0x08，通过查询并列出发现，其数据依次为：\n0x0\t0xc\t0xd\t0x3\t0x4 0x9\t0xa\t0xb\t0x10\t0x11 0x12\t0x13\t0x5\t0x6\t0xe 0xf\t0x1\t0x2\t0x7\t0x8\n刚好是0~19，即根据通过\u0026rsquo;iVar3\u0026rsquo;的依次从19到1的变化，local_30数组依次参与解码的数据为8，7，2，1，\u0026hellip;，4，3，13，12，0，而非按顺序解码。\nlocal_30[*piVar1] 在这里我们可以看到，该变量依然是local_30数组中的元素，只不过其index表示为*piVar1。\n看piVar1 = \u0026amp;DAT_00019c08 + iVar3; 一些敏锐的同学可能注意到，在我们介绍的前一个变量中，地址都是四个字节一偏移，在内存地址中查询数据的分布，也是四个字节存一个数据，其它地方都是0，而按照我们的理解，piVar1 = \u0026amp;DAT_00019c08 + iVar3 * 4;似乎才是正确的。我们查看一下相应的汇编代码：\n1 2 3 000164da ee 59 ldr r6,[r5,r7]=\u0026gt;DAT_00019c58 000164dc 04 3d subs r5,#0x4 000164de 7d 59 ldr r5,[r7,r5]=\u0026gt;DAT_00019c54 这一段代码，分别是做了*(int *)(\u0026amp;DAT_00019c0c + iVar4)的计算以及piVar1 = \u0026amp;DAT_00019c08 + iVar3的计算，我们来解释一下：\nldr指令表示加载寄存器，先计算r5与r7寄存器相加的值，再传给r6寄存器，ghidra已经给出了第一次循环中指向的地址，即0x00019c58 subs指令表示减法，将r5寄存器中的值减去立即数0x04并传给寄存器r5 与第一条指令相同，且ghidra给出了第一次循环中指向的地址，即0x00019c54 这样可以看出，实际上，寄存器r5与r6都是读地址值且相差仅有4个字节。也就是说，piVar1比\u0026amp;DAT_00019c08 + iVar3 * 4仅仅相差了4个字节，例如：在第一次循环中，\u0026amp;DAT_00019c08 + iVar3 * 4中的值为0x8，piVar1中的值为0x7，在最后一次循环中，\u0026amp;DAT_00019c08 + iVar3 * 4的值为0xc，piVar1的值为0x0。\n为什么C代码会与汇编相差如此之大呢，第一，在GCC编译C语言的过程中，本身会对代码进行优化，即调整指令顺序，甚至优化掉部分操作，以提升效率；第二，从已经编译过的二进制文件反推出C语言代码本身就是非常难的一件事情，正如数学中，求导的难度往往比求原函数的难度要低。所以有些细微的差池是可能的，因此在逆向工程中，除了要看C代码，还要检查汇编代码以及内存的走向。\n解码过程 现在我们了解了那两个复杂的变量，现在我们来讲一讲解码的算法\n1 2 local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] = local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)] + local_30[*piVar1] ^ bVar2 ^ param_1; 在这条运算中，我们可以了解到local_30[*(int *)(\u0026amp;DAT_00019c0c + iVar4)]表示当前解码运算的数据，local_30[*piVar1]表示下一个解码运算的数据，例如：当*(int *)(\u0026amp;DAT_00019c0c + iVar4)=8时，*piVar1 = 7，这样上式就变成了：\n1 local_30[8] = local_30[8] + local_30[7] ^ bVar2 ^ param_1; 依次类推，到最后一次循环时，上式变成：\n1 local_30[12] = local_30[12] + local_30[0] ^ bVar2 ^ param_1; 我们假设，存在一个table[20]\n1 2 3 4 5 6 table[20] = { 0x0,0xc,0xd,0x3,0x4,\\ 0x9,0xa,0xb,0x10,0x11,\\ 0x12,0x13,0x5,0x6,0xe\\ 0xf,0x1,0x2,0x7,0x8 } 那么整个while循环可以改写成：\n1 2 3 4 5 do { local_30[table[iVar3]] = local_30[table[iVar3]] + local_30[table[iVar3-1]] ^ bVar2 ^ param_1; iVar3 = iVar3 + -1; } while (iVar3 != 0); 这样，读者应该可以理解，我们从iVar3的角度上来讲，是“从第19到1的解码”，但从数据实际的解码顺序来讲，其实是“8，7，2，1，15，14，6，5，19，18，17，16，11，10，9，4，3，13，12”的顺序解码，0在后面单独解码。\n这19个数据，每一个解码，都依赖于前一个还未解码的数据，即当解码第8个数据的时候，需要依赖第7个数据，当解码第12个数据时，需要依赖第0个数据。\n现在我们仔细讲一下式子，在该式子中， bVar2 = (byte)iVar3;即，bVar2与iVar3相同，从19到1根据循环次数递减，param_1是一个常量，为0x32，是从adpcm_decoder1中传进来的第一个参数，如果不记得可往上翻阅。\n在这条式子中，既有加法，又有异或运算，那么问题来了，该怎样计算呢？或者说，先算哪个呢？\n这时熟悉C语言的同学们会说，在C语言中，加减法的优先级高于异或运算的优先级，因此先计算local_30[table[iVar3]] + local_30[table[iVar3-1]]，再计算 ^ bVar2 ^ param_1，答案是没错的，在不同的语言中，异或运算与加减法的优先级可能会有所不同，因此这里的运算优先级要额外注意，但同理，在逆向工程中，不要过分相信逆向工具给你的C代码，它不一定是你想象的那样，因此我们还是来看一下它的汇编代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LAB_000164d6 000164d6 1a 1c adds r2,r3,#0x0 000164d8 9d 00 lsls r5,r3,#0x2 000164da ee 59 ldr r6,[r5,r7]=\u0026gt;DAT_00019c58 000164dc 04 3d subs r5,#0x4 000164de 7d 59 ldr r5,[r7,r5]=\u0026gt;DAT_00019c54 000164e0 42 40 eors r2,r0 000164e2 01 92 str r2,[sp,#local_3c ] 000164e4 4a 5d ldrb r2,[r1,r5] 000164e6 8d 5d ldrb r5,[r1,r6] 000164e8 01 3b subs r3,#0x1 000164ea 94 46 mov r12 ,r2 000164ec 01 9a ldr r2,[sp,#local_3c ] 000164ee 65 44 add r5,r12 000164f0 55 40 eors r5,r2 000164f2 8d 55 strb r5,[r1,r6] 000164f4 00 2b cmp r3,#0x0 因为式子中有一个“+”和两个“^”，因此我们只要着重看“add”指令与“eor”指令即可。\nadds r2,r3,#0x0：这条指令并不是加法指令，而是将r3寄存器中的值赋值给r2寄存器，这个寄存器中实际存了什么值呢，我们看后续有一个subs r3,#0x1，因此可知，r3寄存器是在循环中递减的，这符合bVar2的特征，因此可以断定，r2寄存器存储的实际上就是bVar2。 eors r2,r0：r2寄存器与r0寄存器的值做异或运算，将结果存放到r2中，在我们之前提到，r0寄存器存储的是param_1传参，即0x32固定参数，因此这条指令实际上就是bVar2 ^ param_1。 ldrb r2,[r1,r5]：指令表示加载寄存器，r5与r6两个寄存器的内容我们上面分析过，[r1,r5]表示目标内存地址，这个地址是通过将寄存器r1与r5的值相加得来的，r1为param_2，即数据数组指针，r5为上面分析时讲到的乱序查表得到的偏移量。两者相加则索引到对应的数据。将其存放在r2中，下面ldrb r5,[r1,r6]一样。 mov r12 ,r2：该指令将r2寄存器中的值转移到r12寄存器，因此，现在r12与r2的内容一样。 add r5,r12：该指令将r12与r5相加，即式子中的两个local_30相加，并将结果存放到r5中。 eors r5,r2：将r5寄存器与r2寄存器中的值做异或运算。 通过汇编指令，我们可以推算出运算的优先级为：\n$$\rr1 = bVar2 \\oplus param_1\\\\\rr2 = local\\_30[*(int *)(\\\u0026DAT\\_00019c0c + iVar4)] + local\\_30[*piVar1]\\\\\rres = r1 \\oplus r2\r$$第0个数据的解码 1 2 local_30[0] = local_30[0] - 0x3e ^ param_1; iVar3 = 0; 第0个数据不依赖于任何其它的数据，仅靠自身便可完成解码\n其对应的汇编代码也很简单，如果读者理解了上面的过程，那么理解这一段汇编代码也是轻而易举，在此笔者不做过多赘述\n1 2 3 000164fc 3e 38 subs r0,#0x3e 000164fe 50 40 eors r0,r2 00016500 08 70 strb r0,[r1,#0x0 ]=\u0026gt;local_30 返回数据 1 2 3 4 do { *(byte *)(param_3 + iVar3) = local_30[iVar3]; iVar3 = iVar3 + 1; } while (iVar3 != 0x14); 在此过程中，通过while循环将local_30中已经完成解码的数据全部放到param_3参数中，完成了数据的返回（因为param_3是一个指针，因此对指针数据做修改在函数退出时修改依然成立，而不会随着函数出栈而消失）。\n总结 在这个反汇编的过程中，我们通过C代码与汇编代码的结合，还原出了解码过程的真实情况，因此，在反汇编中除了看反汇编工具提供的c语言代码，也需要看原来的汇编代码。所以，在逆向工程中，学会阅读汇编代码对你的帮助时巨大的，会避免因编译优化等问题带来的困扰，同时，笔者推荐读一读《深入理解计算机系统》，会让你对C和逆向有更深层次的理解，最后祝你变得更强！\n","date":"2024-12-08T19:20:00+08:00","image":"https://Lyrical-wander.github.io/p/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%9C%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B/GHIDRA_hu18354248310373415165.jpg","permalink":"https://Lyrical-wander.github.io/p/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%9C%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B/","title":"逆向工程实战，在反汇编中发生的事"},{"content":"前言 笔者在阅读《深入理解计算机系统》时，理解了为何C语言被称为不安全语言，C语言除了指针非常灵活可能会导致大量漏洞之外，C语言的无符号数据也可能带来致命性危害。\n扩展一个数据的表示 将一个无符号数转换为更大的数据类型，我们只需要在表示的开头添加0，这种运算称之为0扩展(zero extension)，将一个补码数字转换为一个更大的数据类型可以执行符号扩展(sign extension)。\n因此我们可以看到，无符号表示的数和补码表示的数扩展方式不一样，这就会导致下面这种情况：\nsx = -12345: cf c7\nusx = 53191: cf c7\nx = -12345: ff ff cf c7\nux = 53191: 00 00 cf c7\n尽管-12345的补码表示和53191的无符号表示在16位字长时是相同的，但是在32位字长时却是不同的。前者使用的是符号拓展——最开头加了16位，都是最高有效位1，后者开头使用了16个0来扩展。\n在书中有符号扩展，数值不变的数学证明过程，不感兴趣的小伙伴可以跳过这一部分。\n$B2T_{w+k}([x_{w-1},\u0026hellip;,x_{w-1},x_{w-1},x_{w-2},\u0026hellip;x_0])$ = $B2T_w([x_{w-1},x_{w-2},\u0026hellip;,x_0])$\n上面这一条表达式左边增加了K个$x_{w-1}$，下面的证明是对k进行的归纳，即，我们只需证明拓展1次，即可通过数学归纳法证明上式正确\n要证明：\n$B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\u0026hellip;,x_0])$ = $B2T_w([x_{w-1},x_{w-2},\u0026hellip;,x_0])$\n展开左边得到：\n$$\r\\begin{aligned}\rB2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])\r\u0026=\\ -x_{w-1}2^{w}+\\sum\\limits^{w-1}_{i=0}x_{i}2^{i}\\\\\r\u0026=\\ -x_{w-1}2^{w} + x_{w-1}2^{w-1} + \\sum\\limits^{w-2}_{i=0}x_{i}2^{i}\\\\\r\u0026=\\ -x_{w-1}(2^{w} - 2^{w-1}) + \\sum\\limits^{w-2}_{i=0}x_{i}2^{i}\\\\\r\u0026=\\ B2T_w([x_{w-1},x_{w-2},...,x_0])\\\\\r\\end{aligned}\r$$不同大小的有无符号转变 当把short转换成unsigned时，我们先要改变大小，之后再完成从有符号到无符号的转变。\nunsigned sx = unsigned int sx\n因为是先改变大小，因此是先按照有符号的规则进行符号扩展，然后再从有符号转变成无符号。\n截断数字 当我们强制类型转换将int修改为short，是直接将数字高位的相应部分直接截断，因此截断一个数字可能会改变它的值（溢出的部分没了）。截断它到k位的结果就相当于计算 $x mode 2^k$。\n关于有符号数与无符号数 有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。\n下面给出两个例题：\n根据上一篇文章得知，在无符号数与符号数之间的比较时，通通转换成无符号数比较。\n可以看出，当usigned length 被设置为0时，在length - 1中，无符号数的减法是通过模运算实现的，因此不会得到负数，该表达式会变成UINT_MAX - 1（在32位系统中为0xFFFFFFFE，即4294967294），这么大的数进行遍历时，a数组的长度肯定是不够的，因此会遇到存储器错误，修改只需要将unsigned length改为int length即可\n在此例题中，因为strlen函数返回值的数据类型为size_t即unsigned int，因此涉及到无符号数据类型是要小心是否会转变成有符号类型，如果有，在转变时是否会发生与预期的数值产生偏差。\n在此处，strlen(s)与strlen(t)都是无符号类型，且进行大小比较，因此整个表达式都会转换成无符号类型进行比较。\n在无符号类型中，0就是最小值，无论strlen(s)与strlen(t)谁大谁小，相减也不会小于0，因此这个表达式只有在两者相等时为false，否则皆为true。\n函数getpreername的安全漏洞 2002 年，从事 FreeBSD 开源操作系统项目的程序员意识到，他们对 getpeername 函数的实现存在安全漏洞。代码的简化版本如下 ：\n​\t在这段代码里，第 7 行给出的是库函数 memcpy 的原型，这个函数是要将一段指定长度为 n的字节从存储器的一个区域复制到另一个区域。\n​\t从第 14 行开始的函数 copy_from_kernel 是要将一些操作系统内核维护的数据复制到指定的用户可以访问的存储器区域。对用户来说，大多数内核维护的数据结构应该是不可读的，因为这些数据结构可能包含其他用户和系统上运行的其他作业的敏感信息，但是显示为 kbuf 的区域是用户可以读的。参数 maxlen 给出的是分配给用户的缓冲区的长度，这个缓冲区是用参数user_dest 指示的。然后，第 16 行的计算确保复制的字节数据不会超出源或者目标缓冲区可用的范围。\n​\t不过，假设有些怀有恶意的程序员在调用 copy_from_kernel 的代码中对 maxlen 使用了负数值，那么，第 16 行的最小值计算会把这个值赋给 len，然后 len 会作为参数 n 被传递给 memcpy。不过，请注意参数 n 是被声明为数据类型 size_t 的。这个数据类型是在库文件stdio.h 中（通过 typedef）被声明的。典型地，在 32 位机器上被定义为 unsigned int。既然参数 n 是无符号的，那么 memcpy 会把它当作一个非常大的正整数，并且试图将这样多字节的数据从内核区域复制到用户的缓冲区。虽然复制这么多字节（至少 231 个）实际上不会完成，因为程序会遇到进程中非法地址的错误，但是程序还是能读到没有被授权的内核存储器区域。\n​\t我们可以看到，这个问题是由于数据类型的不匹配造成的 ：在一个地方，长度参数是有符号数 ；而另一个地方，它又是无符号数。正如这个例子表明的那样，这样的不匹配会成为缺陷的原因，甚至会导致安全漏洞。幸运的是，还没有案例报告有程序员在 FreeBSD 上利用了这个漏洞。他们发布了一个安全建议，“FreeBSD-SA-02:38.signed-error”，建议系统管理员如何应用补丁消除这个漏洞。要修正这个缺陷，只要将 copy_from_kernel 的参数 maxlen 声明为类型 size_t，也就是与 memcpy 的参数 n 一致。同时，我们也应该将本地变量 len 和返回值声明为 size_t。\n​\t实际上，除了C语言，很少有语言支持无符号整数，很明显，设计者们认为它们带来的麻烦要比益处多得多。\n​\t但当我们想把字仅仅看作时位的集合，并且没有任何数字意义时，无符号数值是非常有用的。例如，往一个字中放入描述各种布尔条件的标记时，就是这样。地址自然地就是无符号的，所以系统程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。\n","date":"2024-11-22T21:14:00+08:00","image":"https://Lyrical-wander.github.io/p/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%B7%E9%98%B1/image_hu7244334846861214996.jpg","permalink":"https://Lyrical-wander.github.io/p/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%B7%E9%98%B1/","title":"C语言中关于数据类型带来的陷阱"},{"content":"我是流浪的诗人 在现实的荒芜中\n捡拾破碎的梦境\n这一片是海盗的船帆\n那一片是宇宙的吟唱\n我以梦作诗\n将诗喂给残缺污秽的灵魂\n梦啊\n如果没有你\n我早已死在某个枯树之上！\n","date":"2024-11-22T19:20:00+08:00","image":"https://Lyrical-wander.github.io/p/%E6%B5%81%E6%B5%AA%E8%AF%97%E4%BA%BA/image2_hu8665551074602845967.jpg","permalink":"https://Lyrical-wander.github.io/p/%E6%B5%81%E6%B5%AA%E8%AF%97%E4%BA%BA/","title":"流浪诗人"},{"content":"前言 本文同样地是整理和归纳《深入理解计算机系统》这本书的内容，但本文不会继续长篇大论地去将所有内容都总结，而是总结笔者认为容易遗忘或混淆或表述不清的内容。\n字 首先字这个概念对于学习过《计算机体系结构》或《操作系统》的同学都不陌生，但是笔者对于这个概念很容易遗忘，所以笔者还是记录下来。\n总的来说：字长决定了虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器而言，虚拟地址的范围为 0 ～ $2^w-1 $，程序最多访问 $2^w$ 个字节。\n如果一台计算机的字长为32位，这就限定了虚拟地址空间为4GB。也就是说，即使你的主存容量再大，处理器也只能寻址4G的范围，同样的道理，在嵌入式中，8位机的概念就是字长为8位的微型处理器。\n现在市面上有许多32位，64位机器，在不同机器之间程序会遇到数据长度，寻址能力等方面的挑战，一个强大的程序，应该兼容不同的机器。\n数据大小 可以看到，在C语言中，数据类型在不同的字长的机器上占有不同的字节数，程序员应该力图使它们的程序在不同的机器和编译器上是可移植的，可移植性的一个方面就是程序堆不同数据类型的确切大小不敏感。\n布尔代数 布尔代数实际上就是围绕数字0与1建立起来的一种代数体系，以研究逻辑推理和基本原则。\n布尔代数只有0和1两个数，拥有与（\u0026amp;）、或（|）、非（~）、异或（^） 等运算，且运算间也遵循某种分配律和交换律\n位级运算 在这里我们值得一提的是：在异或（^）运算中，我们需要注意到：a^a=0以及a^b^a=b\n正是由于异或拥有这种神奇的性质，我们可以完成以下脑经急转弯。\n请设计一个程序，在不适用第三个变量的情况下，交换x与y的值\n1 2 3 4 5 6 void inplace_swap(int *x, int *y) { *y = *x ^ *y; // step1 *x = *x ^ *y; // step2 *y = *x ^ *y; // step3 } 从上面这个函数可以看出，在step1时，y现在存储的值时 x ^ y ，在step2时，x 的值变为 x^ x ^ y = y这是根据a^b^a=b的运算规则，step3同学们可以自己算一下。\na^b^a=b这是一个运算规则而非定理，即，这并非人为规定，而是客观规律。我们尝试以下运算\na = 0110 0101\nb = 1100 1011\n根据异或的运算规则，相同则为0，不同则为1\n我们设c = a ^ b = 1010 1110\n此时再用c ^ a 得到\nd = c ^ a = 1100 1011\n你会发现，d = b ，即 a ^ b ^ a = b\n除此之外，还有一个例题非常有意思\nbis(位设置)：输入一个数据字x和一个掩码字m，生成一个结果z，z是由掩码m的位来修改x得到的，这种修改是在m为1的每个位置上，将z对应的位置设为1\nbic(位清除)：输入一个数据字x和一个掩码字m，生成一个结果z，z是由掩码m的位来修改x得到的，这种修改是在m为1的每个位置上，将z对应的位置设为0\n为了清楚因为这些运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 | 和 ^ 运算。填写下列代码中缺失的代码。提示 ：写出 bis 和 bic 运算的 C 语言表达式。\n1 2 3 4 5 6 7 8 9 10 11 12 // 你可以使用的函数 int bis(int x, int m); int bic(int x. int m); // 完善下列函数 int bool_or(int x,int y){ int result = _______; return result; } int bool_xor(int x, int y){ int result = _______; return result; } 我们可以根据说明，模拟一下bis函数的运行输入输出：\n当x = 0110 0101 m = 1100 1011时，\n根据bis的说明，m的某一位为1时，则x对应的位被修改为1，其它不变\n那么，res = bis(x,y) 则 res = 1110 1111\n根据bic的说明，m的某一位为1时，则x对应的位被修改为0，其它不变\n那么， res = bic(x,y) 则 res = 0010 0100\n那么， res = bic(y,x) 则 res = 1000 1010\n根据上面的演算，我们可以发现，当你使用bis时，则x与m两者都是0的位才为0，否则即为1。当你使用bic时，则仅有m为0时且x为1时，才为1。\n那么或运算就好办了，因为或运算的规则就是只要有1则为1，逆命题就是两者为0才为0，即bis运算\n则第一个函数为：\n1 2 3 4 int bool_or(int x,int y){ int result = bis(x,y); return result; } 异或运算的规则为，只要不同则为1，否则为0。根据bic运算，当你使用bic时，则仅有m为0时且x为1时，才为1，可以得到不同的其中一种情况，即m为0且x为1，还要第二种情况，m为1且x为0，那么只需要将m与x的位置调换，在运算以此即可获得，然后将两者进行或预算，也就是bis运算即可。\n1 2 3 4 int bool_xor(int x, int y){ int result = bis(bic(x,y),bic(y,x)); return result; } 掩码 在数据处理中的掩码与计算机网络中的掩码概念有所不同，在这里的掩码你可以理解为是一种滤波器，它可以将特定位的数据通过而屏蔽掉其它位的数据，如\n掩码：0x0000FF 与 a : 0x123456 进行运算，则会得到\nres = 0x000056\n补码编码 跳过了无符号数的编码\n在计算机中，有符号数的表示方式就是补码，将字中最高有效位定义为负权（negative weight），如\n1011 = -1*$2^3$+0*$2^2$+1*$2^1$+1*$2^0$ = -8 + 0 + 2 + 1 = -5\n在这种编码下，最高位变成了乘了一个-1，因此，在这种情况下，我们要考虑在有有符号数补码编码的情况下的几种特殊情况：\n0000 = 0\n1111 = -1\n0001 = 1\n1000 = -8\n0111 = 7\n在字长未4的情况下，有符号数的补码编码中，取值范围为[-8:7]，1111并非最小值，而是-1，1000才是最小值为-8，0111是最大值7\n在0000，0001，0010，\u0026hellip;，0111，1000，\u0026hellip;，1111以此类推中，实际上的数值变化是，0，1，2，\u0026hellip;，7，-8，-7，\u0026hellip;，-1\n由此我们可以看到，补码的范围是不对成的，即最小值没有与之对应的正数。这导致补码运算的某些特殊的属性，并且容易造成程序中细微的错误。\n以下表格中，*$UMax_w$表示无符号数的最大值，$TMin_w$表示有符号数的最小值，$TMax_w$*表示有符号数的最大值\n数据比较 由于 C 语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但是对于像 \u0026lt; 和 \u0026gt; 这样的关系运算符来说，它会导致非直观的结果。考虑比较式 -1\u0026lt;0U。因为第二个运算数是无符号的，第一个运算数就会被隐式地转换为无符号数，因此表达式就等价于4294967295U\u0026lt;0U，这个答案显然是错的。\n","date":"2024-11-21T13:14:00+08:00","image":"https://Lyrical-wander.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/image_hu18132413772527675279.jpg","permalink":"https://Lyrical-wander.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/","title":"计算机系统中信息数据的处理"},{"content":"前言 首先，想要实现这个功能的小伙伴需要完成几个前置条件：\n有一个GitHub账号 安装了git，并可以通过git推送commit到GitHub上 完成第一篇文章的博客搭建 创建仓库 在GitHub上创建一个仓库，用来存放代码\n如果你不是GitHub重度使用者或高手，建议你的仓库名称就是你自己的用户名 + .github + .io。如图所示：\n这是因为，如果使用这个名字的话，那么在后续使用GitHub pages生成静态网站的域名就直接是你的仓库名，而不需要加其它后缀，可能会导致未知的bug\n仓库必须公有，只有公有仓库才能部署静态页面\n修改配置 还记得上一篇文章提到的，配置文件中有一个参数是讲url重定向到自己的GitHub仓库的吗，现在我们在创建自己的仓库之后，可以开始填写，修改hugo.yaml的`baseurl\n1 baseurl: https://Lyrical-wander.github.io # 这里是我的仓库名称，如果你按照上面的步骤走，输入：https://用户名.github.io 即可 上传代码 上传代码前，首先查看你的站点目录下有没有public目录\n这个public目录是生成的静态网站的代码，还记得我们上一个文章中使用的一条命令吗\n1 hugo server -D 这条命令会启动hugo程序，将源码进行“编译”（当然并不是真正意义上的编译），生成html，scss等前端代码，这些代码构成静态网站。\n如果没有生成public目录，那么就使用hugo server -D命令生成一下。\n值得注意的是，如果你习惯用VScode中的git插件，也许会方便很多。但第一次上传代码也需要手敲命令\n但幸运的是，当你第一次创建仓库，仓库中一无所有时，会提示你如何上传代码\n在站点目录下启用cmd命令，逐条输入命令：\n1 2 3 4 5 6 git init # 初始化git git add . # 通过git上传当前目录下所有的文件 git commit -m \u0026#34;这是我的博客第一次提交\u0026#34; # 这里是给这一次提交写一个记录，说明这个提交是做什么的 git branch -M main # 创建主分支 git remote add origin xxxxxxxxx # 你是什么就填什么，不做修改 git push -u origin main 如果这里出问题，push不到仓库中，不是hugo或者stack的问题，请检查git与GitHub是否正常运行，以下有几个排查的方向：\n网络问题，因为GitHub是全球服务器，因此国内访问可能会有些慢，有条件的同学开个代理 git并没有权限访问GitHub，看你是如何配置GitHub的，建议采用SSH，网上有许多git生成ssh密钥，GitHub绑定密钥的教程，建议跟着走一遍，如果采用HTTPS的话，应该是要登陆的，具体流程笔者很久没用了，也是建议上网搜索，网上教程很多 启用pages功能 如果你成功上传代码，现在可以打开GitHub上自动生成静态网页的pages功能，来帮你生成静态网页，等静态网页生成后，以后通过访问你的仓库域名，即可直接打开你的博客\n进入你的仓库 在仓库菜单栏中找到Settings功能 在侧边菜单栏中找到Pages 在分支Branch中选择主分支main 保存Save 做完以上操作，等待一段时间静态网站部署，可能几分钟，刷新一下出现⑥处，则说明生成成功，访问这个域名即可访问你的博客！\n值得注意的是，这里我是购买了自己的域名，然后解析到我的仓库，所以我的域名是www.lyrical-wander.cn，而不是www.lyrical-wander.github.io，而如果按照上面的步骤走的话，域名应该是：www.usename.github.io\n至此，你的博客已经部署好了！可以开始访问你自己的博客啦\n小结 还有需要注意的是：\n每一次写完博客，都需要重新使用hugo server -D命令，生成新的public目录，push上GitHub 每次生成新的public，都会有大量的文件被改动，push起来非常不方便 因此我们要通过GitHub的Action功能来实现自动化部署\n自动化部署 创建仓库 同样地，按照上面的步骤，我们重新创建一个仓库，这个仓库不会生成pages，且可以设置为私有仓库，因此随意命名，比如：hugo-main\n修改代码 创建.gitignore文件 我们添加一个小文件，来保持我们代码的干净整洁。\n因为每一次hugo server -D都会生成新的public和resources，而这个并不是我们编写的代码，因此这个可以忽略掉。\n在站点目录下增加一个新文件.gitignore\n填写以下内容：\n这个文件顾名思义，可以让git忽略掉它里面填写的这些文件，这些文件git不会再检查它们的修改，也不会让你提交它们。\n生成token并创建yaml配置文件 首先我们先生成一个token，获取该token，以免你以后每次上传代码都需要重新登录一遍\n进入Settings\n移动到最下方找到Developer settings\n然后选择Personal access tokens→Tokens(classic)→Generate new token→Generate new token(classic)\n生成token时可以将Expiration选择No expiration，即这个token永不过期。\n下面Select scopes（作用范围）选择repo与workflow\n后面就生成了token~\n注意！这个token只会出现一次，之后再也不会出现，在你关闭网页前先复制保存！\n回到你刚刚创建的 第二个仓库 上（我们称之为hugo主仓库吧），不是username.github.io那个仓库！\n在仓库中打开Settings→Secrets and Variables→New repository secret 来创建一个存储token的变量\n为什么要这么做呢，因为token这个东西比较重要，如果后续我们直接将它写到文件中，如果文件被窃取，那么token就会暴露，这样你的仓库就不安全了，尤其我们的token还选择了不过期。\n因此，我们将token保存在GitHub中，以变量的形式传给我们的文件，这样token的密封性就很好了\n回到我们的站点目录下，创建一个.github目录，在.github目录下创建一个workflows目录，在该目录下生成一个xxxxx.yaml文件，名字随便取\n在xxxx.yaml文件下写入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} # 刚刚在上面创建的变量名 EXTERNAL_REPOSITORY: 你的github名/你的仓库名 # 如果按照上面的步骤走，则是username/username.github.io第一个仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 上传代码 同样地，我们将站点代码再一次上传到这个仓库上，git操作一模一样，按照上面的上传代码部分来重新操作一遍即可。\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin xxxxxxxxxxx git push -u origin main 至此，你就实现了自动部署，现在，你撰写博文，然后直接push到第二个仓库，不需要本地生成public，就可以啦，第二个仓库会做一系列操作，并生成静态网站所需的资源和public，传到第一个仓库中，然后生成静态网站。\n","date":"2024-11-20T21:48:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BA%8C/stackImage_hu319509881166415343.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BA%8C/","title":"基于Hugo构建一个属于自己的博客（二）"},{"content":"前言 我想有一个地方，能够分享一些个人生活，记录一些技术知识，那么在茫茫大的网络世界中，有许多网站或者应用可以满足我的需求，比如CSDN，比如博客园，比如QQ空间（已经渐渐消失在时间的长河中了\u0026hellip;\u0026hellip;）。但，总感觉差了些什么，它们既不能满足我的个人世界的全部想象，又不够极客主义，谁在小时候没有幻想过拥有一间完全由自己建造的，不受地皮，户型限制的房子呢？\n因此，我决定开始搭建自己的个人博客，它将成为我在网络世界的一座小屋，它的风格，样式由我定义，它将随我漂流，我可以自由地为它添砖加瓦，也可以任性地删除任何我不满意的功能，也许在某天它将因为我的离开而荒废，但这里，有我在网络世界的一部分记忆，一部分独属于我的记忆\u0026hellip;\u0026hellip;\n笔者的个人博客，苏三有春的博客，采用了Hugo框架下的stack主题搭建，非常快速且简单（当然在搭建的过程当中笔者也踩了一些坑），因此写一篇博客来记录自己的搭建心得以及给有想法搭建个人博客的小伙伴们一些参考。\n参考视频：\n【雷】Hugo + Github免费搭建博客，并实现自动化部署_哔哩哔哩_bilibili\nHugo Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署，可以帮助用户快速构建高性能的静态网站，方便个人搭建博客，和个人网站等。Hugo在GitHub（ The world’s fastest framework for building websites.）上拥有超过75K stars，近千名贡献者，拥有活跃的社区，保证了Hugo成为当下最流行的静态网站生成器之一，正如其标题所说：“Hugo是世界上最快的构建网站的框架”。\nHugo下载 Hugo框架的下载有一些注意事项：\nHugo根据操作系统的不同有不同的下载方式\nMacOS\nbrew install hug\nLinux\nsudo snap install hugo\nWindows\nchoco install hugo-extended\n上面的下载方式是官方推荐的，笔者的主要工作环境是Windows，但并不采用上述的下载方式，因为choco是一个包管理器，本身也需要下载（笔者不喜欢因为一个功能而去下载另一个功能，导致整个环境特别臃肿），可以采用以下方法去下载：\n到Hugo的GitHub仓库中，找到Tags\n选择最新的版本（本文创作时最新版本是v0.138.0）\n一直往下滑，可以看到一堆Assets资源，找到Windows，且带有extended版本的，本文是根据Hugo框架下的stack主题来构建的，如果你查看过stack的官方文档，可以发现，其中也强调了是以哦那个extended（拓展）版本，才能完成该主题的全部功能搭建。\n下载完成后，你会得到一个Hugo静态网站生成器的exe执行文件，该执行文件可以帮助你生成一个静态网站的全部内容。此步骤可做可不做：将hugo所在的目录放在系统环境变量path中。笔者是做了这一步的，这一步的作用是，无论你在那个目录下，都能使用hugo命令。如不添加，则当你生成了一个静态网站资源，你需要将hugo.exe文件拖入静态网站资源的目录下，以便你日后在在目录内调用hugo命令。\n在控制台（如果没有添加环境变量，则需要在有hugo.exe的目录下执行）使用hugo version命令测试hugo是否安装成功，如果安装成功，则输出如下\n1 2 3 4 D:\\HugoBlog\\dev\u0026gt;hugo version hugo v0.136.5-46cccb021bc6425455f4eec093f5cc4a32f1d12c+extended windows/amd64 BuildDate=2024-10-24T12:26:27Z VendorInfo=gohugoio D:\\HugoBlog\\dev\u0026gt; 创建新的站点 在cmd中（如果没有配置全局路径，在hugo.exe目录下使用该命令）使用命令\n1 hugo new site yoursitename #yoursitename 是你的站点文件夹名称， 可以使用dev或自己起个名字 上面截图显示了创建新的站点成功，并且会给你一些提示，按照提示走就可以花很少的时间搭建出一个静态网站\nHugo会在这个D:\\HugoBlog目录下自动新建一个名为AHugoBlogSite的目录，如下图所示：\n进入AHugoBlogSite目录\n1 cd AHugoBlogSite 挑选主题 Hugo下载好后，就可以开始挑选自己喜欢的主题，可以在Hugo官网下挑选（Complete List | Hugo Themes），每个主题都可以点进去查看详细信息与下载地址，笔者这里使用了stack主题，特别适合用于搭建个人博客网站。可以通过Hugo Themes中选中stack主题，进去Download，也可以在GitHub上直接搜索CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers，仿照上面下载hugo的方法找到对应位置下载源码（source code）压缩包即可。\n如果有兴趣为该主题添砖加瓦的同学，也可以给这个主题作者提交Issues！\nStack 解压主题 将stack主题的源码解压到AHugoBlogSite\\themes目录下（接下来为了方便，AHugoBlogSite统称为站点目录）。\n将解压的目录名称中的版本号删除，改成像我一样hugo-theme-stack\n值得注意的是，如果你想换其它主题，或者你一开始便不打算下载stack主题，操作也是一样的，同样将版本号删除，并将yaml配置文件中的主题改成对应的主题目录名称即可（后面会提及）\n从主题文件中复制两个重要文件 在解压的目录（hugo-theme-stack）下，有一个样例目录名为：exampleSite，里面有两个非常重要的东西，一个是content目录，一个是hugo.yaml配置文件，将这两个文件复制出来\n放到站点目录下 将原本的默认配置文件hugo.toml删除，用我们复制过来的hugo.yaml做配置文件\n注意：在content\\post\\目录下，有一个rich-content的目录==删掉==，post目录下存放的就是你的博客内容，这个rich-content博客中做了一些引用Youtube的样例操作，可能会导致你运行失败，这些国外网站可能会导致你访问超时\n修改配置 打开刚才复制过来的hugo.yaml\n更换主题 可以看到，这里主题选择的是hugo-theme-stack，如果你想更换其它的主题，只需下载其它主题的源码到themes\\目录下，并将配置文件中的主题换掉即可\n以下笔者就不截图了，以代码段形式展现笔者修改了的部分:\n笔者将url的重定向到自己的GitHub仓库，下一篇讲部署到GitHub上时会提及\n1 baseurl: https://Lyrical-wander.github.io 修改了著作权，当然，这个著作权是指本博客的著作权，而非hugo也非该主题\n1 copyright: Lyrical Wander 将默认语言修改为中文\n1 DefaultContentLanguage: zh-cn 修改以下配置，据说可以更精确的计算读文章的时长\n1 hasCJKLanguage: true 这里修改的是博客左上方的标题，有中英两个版本，但笔者的博客全是中文博客，还没有做国际化的打算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 languages: en: languageName: English title: LyricalWander\u0026#39;s Blog weight: 1 params: sidebar: subtitle: We have a long life,but just own death and love zh-cn: languageName: 中文 title: 苏三有春的博客 weight: 2 params: sidebar: subtitle: 人生茫茫，唯死亡与爱而已 这个参数是指一页展示多少篇文章\n1 2 pagination: pagerSize: 5 你可以在static目录下存放你博客的图标，将名称改为favicon.ico 1 2 favicon: /favicon.ico # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) 以下参数是修改你的头像以及添加emoji（头像右下角的表情），首先将图片名称改为avatar.png，并添加到assets\\img\\目录下，如果没有img目录可自行创建，然后将参数修改：\n1 2 3 4 5 6 7 sidebar: emoji: 🧐 subtitle: Lorem ipsum dolor sit amet, consectetur adipiscing elit. avatar: enabled: true local: true src: img/avatar.png 修改下面的参数，可以添加或修改头像下面的快捷链接小图标，笔者增加了链接进入笔者B站主页和进入笔者CSDN主页的快捷链接，图标以SVG格式存放在assets\\icons\\目录下，值得注意的是，下面参数icon是图标的文件名去掉.svg，比如brand-bilibili.svg去掉.svg，如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 social: - identifier: github name: GitHub url: https://github.com/Lyrical-wander params: icon: brand-github - identifier: bilibili name: Bilibili url: https://space.bilibili.com/28788259 params: icon: brand-bilibili - identifier: csdn name: CSDN url: https://blog.csdn.net/whale_cat params: icon: brand-coinbase 现在我们创建我们的博客看看\n命令：\n1 hugo server -D 注意：\n必须是在站点目录下使用该命令。（上面我们通过cd AHugoBlogSite进入了目录） 必须是D而不是d 运行命令后会出现以下信息\n可以看见，通过访问http://localhost:1313即可访问博客\n开始编写文章 文章目录结构 首先看一下文章目录结构，文章都保存在content目录下：\n看看对应的网站结构：\n其实无论是page，categories，post，都可以看作一个一级目录，然后每一篇文章，每一个分类，亦或者每一个侧边栏的选项，都是二级目录，二级目录下才是真正的内容，比如，在categories目录下：\n有这么四个二级目录，分别代表了四个我已经创建并附带说明的分类\n值得注意的是，你看我的博客分类有许多，比如网络爬虫，操作系统等，都没有在categories目录下创建，但在分类中依然存在，这是因为，我将某篇文章归类为网络爬虫，但是还没有创建这个分类，因此Hugo自动地帮我创建一个默认分类，把带有网络爬虫的文章收录在一起，但是这分类没有初始图片，没有说明，如下图所示：\n这个分类中没有默认图片，也没有简介，技术杂谈这个分类就有，如下图所示\n如何写博文 我写博文采用的是markdown格式，这个格式我非常熟悉，写起来也特别舒服，使用Typora工具，写markdown手感特别好。\nmakrdown格式没什么好说的，学起来也很快，在写博文的时候需要注意的是开头携带的信息，如下图所示：\n这是文章开头的内容，这里我打开了typora的源码模式。如果是普通的编写模式，则是下面这个样子的：\n可以看到，Typore自动的把---这个识别成分割线，把源码中用---包起来的内容用分割线与下面内容隔开。\n在这里面，你需要注意的是：\ntitle：文章标题 description：副标题，简介 date：编写日期 image：文章最上方的图片 categories：分类 tags：标签 分类和标签的内容可以是中文，可以多个，但需要采用[\u0026ldquo;xx\u0026rdquo;,\u0026ldquo;xx\u0026rdquo;]的格式 :后需要加一个空格，再输入内容 后面的就按照正常markdown创作即可\n值得注意的是：\n博文采用markdown格式，命名规则为：index.语言.md，这里因为我的默认语言是中文，就不用携带语言，即：‘zh-cn’，因此只需要命名为index.md即可。\n总结 至此，你已经搭建了你的个人博客，并且可以开始写文章啦，更多关于stack主题的美化或修改可以看stack文档Stack | Card-style Hugo theme designed for bloggers\n同时，下面一篇文章会介绍如何将博客部署到GitHub上，可以通过GitHub的pages功能，创建一个可以在公网访问的博客网站，很感谢你读到这里，祝你变得更强！\n","date":"2024-11-19T21:47:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%80/stackImage_hu319509881166415343.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%80/","title":"基于Hugo构建一个属于自己的博客（一）"},{"content":"前言 前段时间，笔者因工作需要，尝试搭建了一个Wiki.js，将笔者的学习经历以及踩坑过程通过这篇文章分享给各位读者。\nWiki是一种允许多人共同编辑和管理内容的平台，可以让被授权过的用户在上面创建，修改和更新页面，实现协作和信息共享，广泛应用于教育，公司文档管理，项目合作等多个领域。\n笔者选择采用Wiki.js，一个开源且美观的Wiki程序，在网上照猫画虎地用了docker技术下载安装在Ubuntu22.04系统中，如果你采用的配置和我一样，那么可能会遇到我遇到的这些坑。\n参考文档：\nWiki.js\n【实用的开源项目】使用服务器部署Wiki.js，一个美观且强大的开源Wiki程序-腾讯云开发者社区-腾讯云\n华为开源镜像站_软件开发服务_华为云\nWarning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead (see apt-key(8))-CSDN博客\ndocker pull 报错Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for c-CSDN博客\n首先，笔者在本地虚拟机以及阿里云服务器（免费试用的）都尝试过部署Wiki.js。本地部署于云服务器部署都相同\n请注意，接下来的内容中，如果是笔者强调注意的地方（笔者踩过坑的地方），都会以下方式呈现，注意：\n这里是笔者踩过的坑：\u0026hellip;\u0026hellip;\n安装Docker 如果你需要在云服务器上部署，那么第一步是选择并购买服务器，现在在市面上的服务器有很多，笔者不做推荐。笔者使用的是阿里云的服务器，2核4G，Ubuntu22.04系统，预装LNMP应用。但是笔者看的看的笔记是腾讯云的，【实用的开源项目】使用服务器部署Wiki.js，一个美观且强大的开源Wiki程序-腾讯云开发者社区-腾讯云，但感觉大部分内容大差不差，在阿里云上业跑起来了，只不过没有做反向代理的那一步，因为自己使用，直接用IP:端口访问。\n1.更新apt-get 因为笔者采用的是阿里云的云服务器，系统没有预装docker，所以我们要自己下载并安装docker。\n首先更新一下包管理器，并安装必要的软件包curl\n1 2 apt-get -y update apt-get -y install curl 2.下载安装Docker-ce 接下来注意了：\n笔者曾在这里踩过坑：根据上面腾讯云的内容，笔者是无法直接安装并docker的，笔者怀疑是镜像源的问题，现在许多国内镜像源在pull的时候都会出现报错，因此，笔者做了以下修改：华为开源镜像站_软件开发服务_华为云\n笔者按照这篇文章下载的docker-ce\n==但是！！！！！！！！！！！==\n注意，笔者在服务器上下载完了几天后，开始写文章时重复操作，发现无法下载了！\n发现没有，在华为云的文章中，使用了apt-key命令来添加GPG密钥，但现在，apt-key命令被弃用了！！\n无法通过该命令来添加GPG密钥，因此笔者又上网冲浪了许久，在茫茫多的文章中终于找到了可以解决困境的办法\nDocker：如何解决安装 docker 时 ubuntu 中的公钥错误 - Stack Overflow\n【docker安装】由于没有公钥，无法验证下列签名： NO_PUBKEY 7EA0A9C3F273FCD8-CSDN博客\n以上文章笔者实测，是可以解决添加GPG密钥时出现的apt-key is deprecated的问题。\n具体命令是：\n1 2 3 4 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg sudo chmod a+r /usr/share/keyrings/docker-archive-keyring.gpg apt-get update apt-get install docker-ce 3.启动Docker 执行以下命令启动docker\n1 systemctl start docker 检查docker的运行状态\n1 systemctl status docker 设置为开机自启动docker\n1 systemctl enable docker 新版的docker自带了compose命令，即，你无需下载docker-compose，即可使用docker compose命令（注意中间是空格）\n部署Wiki.js 1.新建目录 新建Wiki.js的存放目录，且移动到目录下\n1 mkdir -p /opt/docker/wikijs \u0026amp;\u0026amp; cd /opt/docker/wikijs \u0026amp;\u0026amp; mkdir -p /opt/docker/docker_data/postgresql/data 这里新建了两个目录，一个是docker目录下的wikijs，一个是数据库的目录，数据库采用postgresql，具体数据库的差异笔者也需要去学习一下。\n2.新建docker-compose.yaml文件 docker-compose.yaml文件是用来等会自动化下载的，按照这个文件中的配置下载Wiki.js并配好数据库。我们这使用nano命令来配置，因为在新安装的系统中，没有vim命令，如果想使用vim命令需要apt-get install vim先下载。\n创建并编辑docker-compose.yaml文件\n1 nano docker-compose.yaml 输入以下配置内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --- version: \u0026#34;3\u0026#34; services: db: image: postgres:11-alpine environment: POSTGRES_DB: YourDatabaseName #设置一个自定义的数据库名以替换 smalljunwikijs 需与下方的 DB_NAME 一致！ POSTGRES_PASSWORD: YourDatabasePassword #设置一个自定义的数据库密码以替换 wikijssmalljunpw 需与下方的 DB_PASS 一致！ POSTGRES_USER: YourDatabaseUserName #设置一个自定义的数据库用户名以替换 smalljunwiki 需与下方的 DB_USER 一致！ logging: driver: none restart: unless-stopped volumes: - /opt/docker/docker_data/postgresql/data:/var/lib/postgresql/data wiki: image: ghcr.io/requarks/wiki:2 depends_on: - db environment: DB_TYPE: postgres DB_HOST: db DB_PORT: 5432 DB_USER: YourDatabaseUserName DB_PASS: YourDatabasePassword DB_NAME: YourDatabaseName restart: unless-stopped ports: - 2078:3000 可以看到，这里我们需要下载两个东西，一个是db即database，一个是wiki即Wiki.js，端口开放为2078，即如果你想访问Wiki.js，则需要通过IP地址:端口号（2078）的形式访问，如果不做方向代理的话\n编写完成后，按Ctrl + x退出，按y确认保存，按enter回车键退出\n3.更改镜像源 原本到这里，按照文章的内容应该是开始运行命令下载\n1 docker compose up -d 但是，因为没有使用国内镜像源，因此在下载的时候会：\n笔者踩过的坑：\n如果没有镜像源下载，那么将会出现：Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for c\n网上大多数的镜像源都无法解决这个问题，以下两篇文章是笔者实践过可以的\n彻底解决docker：docker: Get https://registry-1.docker.io/v2/: net/http: request canceled 报错-CSDN博客\ndocker pull 报错Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for c-CSDN博客\n笔者综合了一下他们的镜像源，以下是笔者采用的镜像源，实践可以下载：\n1 2 3 4 5 6 7 8 9 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.1panel.live\u0026#34;, \u0026#34;https://0dj0t5fb.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://6kx4zyno.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34; ] } https://docker.1panel.live是第二篇文章博主提供的，这个镜像源可以让我成功地下载yaml配置中的db，即下载数据库，后面的镜像源采用的是第一篇博主的。它无法正常下载db，会报出上面的错误，但是可以下载wiki。\n下载时间较长，根据笔者多次失败经历以及更换镜像源的经历，在下载过程中60s内没有爆出上述错误，且db于wiki的下载项都出现，即开始正常下载\n什么叫“db于wiki的下载项都出现呢”，当你运行docker compose up -d命令后，会先出现 db与wiki两项在转圈圈，但是这两项下有许多文件需要下载，需要全部文件都展示出并显示等待下载，才算是开始正常下载。\n访问Wiki.js 通过浏览器访问IP地址:2078即可访问你自己的Wiki.js。\n在访问过程中，笔者也遇到了一些坑，首先介绍一下笔者的环境：\n一台台式机，开着虚拟机运行Ubuntu环境下载了Wiki.js，想通过另一台计算机（笔记本）访问这个Wiki.js\n笔者在网上查阅了大量文章，发现很多文章都是用的是NAT模式，然后通过与虚拟机与宿主机协同暴露指定端口供外接访问，因为虚拟机与宿主机是同一IP地址，因此必须要两者配合，但是宿主机又是Windows系统，因此协调起来比较麻烦，所以笔者采用了桥接模式，虚拟机拥有自己的IP地址，虚拟机可以直接访问外部网络。\n获取IP地址 首先使用以下命令查看虚拟机的IP地址\n1 ip addr show 或者使用\n1 ifconfig 查看防火墙状态 使用以下命令查看防火墙状态，确保防火墙关闭\n如果使用的是ufw\n查看防火墙状态：\n1 ufw status 关闭防火墙\n1 ufw disable 小结 值得注意的是：\n笔者踩过的坑：\n通过这样的方式访问，需要虚拟机与访问虚拟机的机器在同一局域网下，否则的话是无法访问的，因为虚拟机并没有暴露在公网中\n总结 在本次搭建的过程中，笔者也学到了很多东西：\n安装Docker时出现大大小小各种错误，包括镜像源不行，下载过慢，GPG无法使用，apt-key命令被弃用等 在部署Wiki.js时，遇到的最重要的问题就是镜像源问题，虽然在最后笔者采用的镜像源帮助了笔者完整下载，但是在这之前，笔者浏览了许多文章（大多数都相似，使用阿里云的镜像源），都无法正常下载，真的很崩溃。 在最后写这篇文章时，笔者打算重新找回那些资料，发现自己浏览记录过多，许多资料和网站已经找不到了！这也是缺失之一，以后在解决某项问题的时候，希望保持良好习惯，点赞收藏，并及时开始写博客。 ","date":"2024-11-18T19:31:00+08:00","image":"https://Lyrical-wander.github.io/p/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84wiki%E7%9F%A5%E8%AF%86%E5%BA%93/WikijsAndDocker_hu12145976411144345130.png","permalink":"https://Lyrical-wander.github.io/p/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84wiki%E7%9F%A5%E8%AF%86%E5%BA%93/","title":"搭建自己的Wiki知识库"},{"content":"前言 今天来读一下《深入理解计算机系统》，在这篇文章中，笔者将这本书的内容做一些大概的总结与归纳，如果你希望学习：\n如何避免由计算机表示数字的方式导致的奇怪的数字错误 怎样通过一些小聪明小窍门来优化你的C代码，以充分利用现代处理器和存储器系统的设计 编译器是如何实现过程调用的 如何避免缓冲区溢出错误带来的安全漏洞 如何识别和避免链接时那些令人讨厌的错误 如何编写自己的Unix shell，自己的动态存储分配包，甚至是自己的Web服务器 了解并发带来的希望与陷阱 强烈推荐去看一下原书。本文只能是对书本中笔者认为重要或者难以理解与记忆的地方做总结与推导，甚至部分内容加入了笔者自己的理解，理解不一定正确，仅供大家参考。\n最后，再一次推荐大家去看一遍原书，我们要直接对原著围观，尽可能不围观他人的围观，这中间难免有信息的减损甚至误导。\n我们将通过跟踪hello程序的生命周期，来开始对系统的学习。\n1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello world!\u0026#34;); } 当然，首先我们要对要出现的关键概念，专业术语与组成部分做一下介绍。\n信息就是位+上下文 hello程序的生命周期是从一个源程序（源文件）开始的，源程序实际上就是一个值由0和1组成的位序列。大部分的现代系统都使用ASCII标准来表示文本。像hello.c这种只由ASCII字符构成的文件称为文本文件，其它的则称之为二进制文件，如：如经过汇编器后将汇编语言（文本）翻译成机器语言（二进制）后的可重定位目标程序。\n编译系统 GNU GNU（GNU\u0026rsquo;s Not Unix），是1984年由Richard Stallman发起的免税慈善项目，旨在开发一个完整的类Unix的系统，其源代码可不受限制地传播与修改。GNU已经开发出了一个包含出Unix所有的主要部件，出了内核（由Linux项目独立发展）。GCC便是其中一个有用的工具之一。\nGCC编译器可以编译包括C语言，C++，Objective-C，Python等多种语言。到现在也是Linux下非常重要的C语言编译工具。\n编译过程 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：\n1 gcc -o hello hello.c 这个编译系统由四个阶段组成：预处理器、编译器、汇编器、链接器。\n预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，比如hello程序中的#include\u0026lt;stdio.h\u0026gt;会告诉预处理器读取系统头文件stdio.h的内容，并直接插入到程序文本中，结果就得到了另一个C程序，通常以.i作为文件扩展名 编译阶段：编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。 汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。 ==从此时开始，文件内容格式便从ASCII字符文本转换成二进制== 链接阶段：hello 程序调用了 printf 函数，它是每个 C 编译器都会提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。 处理器读并解释存储在存储器中的指令 了解系统的硬件组成 总线：贯穿整个系统的是一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，在各个系统中的情况都不尽相同。现在的大多数机器字长有的是 4 个字节（32 位），有的是 8 个字节（64 位）。 I/O设备：输入 / 输出（I/O）设备是系统与外部世界的联系通道。 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引），这些地址是从零开始的。 处理器：中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个字长的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。 运行hello程序 初始时，外壳程序（shell）执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串“./hello”后，外壳程序将字符逐一读入寄存器，再把它存放到存储器中，如下图所示。 当我们在键盘上敲回车键时，外壳程序就知道我们已经结束了命令的输入。然后外壳执行一系列指令来加载可执行的 hello 文件，将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello, world\\n”。利用直接存储器存取（DMA）的技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如下图所示。 一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的main 程序中的机器语言指令。这些指令将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如下图 所示。 从这张图中可以看到，当CPU的工作需要使用到某些资源或数据时，从主存调取往往需要费一番周折，从主存出发，经过存储器总线，系统总线，总线接口，才堪堪到达寄存器，而这段时间CPU是无法进行下一步工作的，CPU的算力被白白浪费了。\n高速缓存 高速缓存就是CPU与主存（我们经常口头说的内存）之间的一个缓冲区，因为主存的读写速度要比CPU的运行速度低几个数量级，因此，每当CPU开始需要从主存中读写数据时，都需要停下来等待主存完成读写，这样CPU的算力被白白浪费了。因此高速缓存诞生了，它的存储空间没有主存大，但是运行速度比主存快，它的运行速度没有CPU内的寄存器快，但是存储空间比寄存器大，如下所示：\n存储空间 读写速度 寄存器 小 快 高速缓存 中 中 主存 大 慢 从数学的角度来讲，在寄存器与主存中间插入了以及高速缓存，使读写速度的曲线更为平稳光滑，虽然高速缓存的速度依然没有寄存器快，但是介于成本（毕竟运行速度与存储空间在当下的物理材料与技术特性中依然属于不可兼得的）与运行效率的考量，高速缓存是最具性价比的。\n首先了解什么叫局部性原理\n局部性原理的概念：\n局部性原理是计算机科学中的一个重要概念，它描述了一个现象：==在一段时间内，程序倾向于仅使用一部分代码或数据。==这种倾向性分为两类：时间局部性和空间局部性。时间局部性指的是如果某个数据项被访问，那么它不久后可能会被再次访问。空间局部性则是指如果访问了某个存储单元，那么其附近的存储单元也很可能不久后会被访问\n利用局部性原理，可能经常访问的数据提前调入高速缓存中，如此CPU在访问下一次访问时，大概率可以直接从高速缓存中进行访问，这样运行速度将大大提升。\n在编程实践中，理解局部性原理可以帮助开发者优化代码性能。例如，在处理数组或循环结构时，考虑数据的存储和访问模式可以显著影响程序的执行效率。数组通常在内存中顺序存储，因此按行访问数组元素通常比按列访问更高效，因为这符合空间局部性原理。\n存储设备的层次模型 这个模型比较熟悉了\n操作系统管理硬件 应用程序并不直接接触硬件，操作系统介于软件与硬件之间。\n操作系统为程序与硬件之间提供了一个虚拟接口，操作系统有两个基本功能：\n防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂又大相径庭的硬件设备 操作系统通过将复杂的硬件接口抽象成几个基本概念（进程，虚拟存储器，文件）供应用程序使用，以此来完成上面两个功能。\n​\t操作系统将I/O设备抽象成文件，将主存+I/O设备抽象成虚拟存储器，将处理器+主存+I/O设备抽象成进程。\n文件 文件就是字节序列，每一个I/O设备，磁盘，键盘，甚至是网络，都可以看作是一个文件，I/O设备的输入输出，其实就可以看作是对文件的读写操作。这样对程序员来说是方便的，你无需了解磁盘的各种技术，就可以使用磁盘的数据，因此，同一个程序可以在使用了不同磁盘技术的不同系统上运行。\n虚拟存储器 虚拟存储器是一个抽象概念，它为每一个进程提供了一种抽象，让进程以为自己独占内存，让每一个进程看到的是一致的内存，这对程序员是方便的，假设如果没有虚拟内存储器技术，程序员在编写程序时，需要提前对内存进行操作，因为你不知道你现在使用的内存地址是否被其它进程占用了。现在，对内存的操作交给了虚拟存储器，程序员只需编写相对地址，由操作系统自动分配实际的内存地址。以下是Linux进程的虚拟地址空间\n程序代码和数据：对于所有进程来说，代码是从同一固定地址开始的，然后是全局变量与相对的数据位置。代码和数据是按照可执行目标文件的内容开始初始化的，当然还用这里还有链接与加载的事。 堆：下一块是运行时堆，与代码与数据区不同，代码与数据区在进程一开始时就确定好了大小，而堆的空间会随着程序调用malloc或free等操作，而增大或缩小空间。 共享库：大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。 栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别是每次我们调用一个函数时，栈就会增长 ；从一个函数返回时，栈就会收缩。 内核虚拟存储器：内核总是驻留在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。 进程 当程序在操作系统上运行时，操作系统会提供一个假象，即系统上好像只有这一个程序在运行，它可以调用处理器，主存和I/O设备。\n进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在系统中，正在运行的进程往往是比CPU的个数还要多的，因此，无论是单核处理器还是多核处理器，都具备并发运行的能力。而并发运行是通过处理器在进程之间切换来实现的，操作系统实现这种交错机制称之为“上下文切换”。\n操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，它包括许多信息，例如 PC 和寄存器文件的当前值，以及主存的内容。\n当操作系统决定将处理器的控制权交给另外一个进程时，就会进行上下文切换，保存当前进程的上下文，恢复新进程的上下文，将处理器控制权交给新进程。\n值得注意的是，在Linux中，上下文切换的读写数据在内核空间发生，“内核空间”与“用户空间”是Linux类系统的重要概念。\n小结 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。\n处理器读取并解释存放在主存里的二进制指令。因为计算机把大量的时间用于存储器、I/O设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构—CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特开销也更高。层次结构中较高层次存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C 程序的性能。\n操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象 ：1）文件是对 I/O设备的抽象 ；2）虚拟存储器是对主存和磁盘的抽象 ；3）进程是对处理器、主存和 I/O 设备的抽象。\n","date":"2024-11-12T14:20:00+08:00","image":"https://Lyrical-wander.github.io/p/%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/image_hu1867866105620835933.jpg","permalink":"https://Lyrical-wander.github.io/p/%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/","title":"程序在系统中是如何运行的"},{"content":"前言 本文笔者吸取了第一次爬取微软翻译的经验，发现在对微软翻译进行请求的时候，URL会随着会话结束而重新生成，这一点是本文需要解决的内容，且除了URL中出现的IG和IID两个数据外，在请求的表单数据中，还有key和token两个数据也在动态变化。本文旨在追踪这几个数据在何时被发送，如何被获取。\n分析 首先，重新打开浏览器自带的开发者工具，随便翻译一词，让客户端发送一次翻译请求ttranslatev3，可以发现，这次URL与前一篇文章基于PyQt开发的脚本集合包（八）的又不一致\nhttps://cn.bing.com/ttranslatev3?isVertical=1\u0026\u0026IG=DFFF2F46AAE0482491F67EEEB26C249C\u0026IID=translator.5025\n笔者借助开发者工具自带的搜索框进行搜索，看看我们需要的数据在哪里出现过\n除了上一篇文章中提到的IG和IID两个数据外，我们还需要找到token和key两个数据，在ttranslatev3响应请求中，可以看到我们发送请求时，请求表单除了携带需要翻译的文本，翻译前的语种，翻译后的语种外，还需携带两个特殊的信息\n至于tryFetchingGenderDebiasedTranslations一直为true，因此直接填写即可\nIG 找到IG所在 首先看看IG在哪里出现过，将IG的数据DFFF2F46AAE0482491F67EEEB26C249C复制进搜索框查询，得到以下信息\n可以发现，搜索出来的大部分请求中，这一串数据都是出现在URL与path中的，也就是说，这些请求中，IG数据也是被使用的，并不是出自于这些请求，继续向下滑动，找到了一个translator的包\n如果你点击进去，就会发现，这其实就是访问该页面的第一个请求响应，它的html数据构建了整个页面\n现在我们查看IG数据在这个响应的哪里，点击刚刚搜索的地方，会自动跳转到response出现了相同信息的地方，如下图所示：\n因此，现在重新确认一下目标：目标从“找到IG数据的出处”变更为“获取IG数据”。\n请求获取IG数据 来观察一下这个请求响应，回顾一下上一篇文章，我们在请求时需要些什么数据：\nURL、User-Agent、表单数据\n那我们依次来找这个请求所需要的数据，首先看标头：\nURL\n这个URL携带的信息很好猜，https://cn.bing.com/translator是访问的主机，即微软搜索引擎bing的翻译页面，?表示后面携带了多个参数，ref=TThis这通常表示一个参考信息或来源标识符。可能是用来跟踪用户从哪个链接访问了翻译工具，text表示默认的翻译文本，from表示翻译前的语种，to表示目标语种。可以看到，这里后面携带的三个信息，正好是打开网页时的默认信息\n“输入文本”是背景，实际上并没有东西在这里。\n可以猜测，每次访问这个页面，URL大概率是不会发生变化的，没有携带什么特殊的信息。经过反复的刷新和测试，验证了这个猜想。\nUser-Agent\n为什么User-Agent会是一样的？需不需要担心它会不会变化？来看一下User-Agent的定义：\n在进行网页爬虫时，User-Agent 是一个非常重要的 HTTP 请求头字段，它的主要作用是向服务器提供有关请求者（通常是浏览器或爬虫）的一些信息。具体来说，它会告诉服务器，发出请求的客户端是什么类型的设备，操作系统，浏览器等。不同的服务器和网站可能根据 User-Agent 来决定如何响应请求，比如返回不同的内容、样式，或者限制对某些类型客户端的访问。\nUser-Agent 的作用总结： 识别客户端： User-Agent 向服务器表明请求是由哪个客户端发出的。对于不同的浏览器、操作系统或设备，User-Agent 会有所不同。例如，Chrome、Firefox、Safari、IE 等不同浏览器会有不同的 User-Agent 字符串。 避免被识别为爬虫： 网站可能会根据 User-Agent 来识别是否是爬虫程序。很多爬虫程序没有设置真实的 User-Agent，或者 User-Agent 字符串看起来像是一个自动化脚本（比如 Python 的 requests 库默认 User-Agent 是一个简单的字符串）。一些网站会使用这一点来检测并阻止爬虫请求。因此，为了模拟浏览器，爬虫通常会伪装成浏览器的 User-Agent，避免被网站识别为爬虫。 返回适配的内容： 根据 User-Agent，服务器可以返回特定格式的内容。比如，移动设备和桌面设备通常会看到不同版本的网页，甚至不同的图片大小和样式。通过查看 User-Agent，服务器可以判断请求来自于手机、平板、桌面或其他设备，并返回不同的页面样式或功能。 分辨设备和浏览器版本： User-Agent 可以帮助服务器确定访问者的设备类型、操作系统及浏览器版本，从而优化响应内容。比如，某些页面可能会针对不同的操作系统（如 Windows、macOS、Linux）或不同版本的浏览器提供特定的网页布局或 JavaScript 功能。 可以看出，一些服务器会根据User-Agent来判断访问请求是不是来自人类或自动化脚本，可做一些反爬虫操作。我们从浏览器获取的请求信息中包含的User-Agent，表明了这段请求时来自浏览器，而非自动化脚本，因此，我们可以回答上面的问题：1.User-Agent一样是因为我们今天与昨天用的都是同一个浏览器访问，它代表了“该请求来自Edge浏览器”。2.无需担心它会发生变化，除非浏览器更新会更改这项数据，而这大概率是不会发生的。\n代码实现 首先，先获取整个response的html数据，把它写在一个单独的文件里，（数据量太大，操作台无法查找相应的数据），有些导入的模块会在后面的代码中用到，这仅是完整代码的一部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 import requests import re from bs4 import BeautifulSoup from urllib import response import urllib.request import json url = \u0026#34;https://cn.bing.com/translator?ref=TThis\u0026amp;text=\u0026amp;from=zh-Hans\u0026amp;to=en\u0026#34; header = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} response = requests.get(url,headers=header,data={}) response.raise_for_status() html = response.text with open(\u0026#34;translator.html\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(html) 获取到相应的HTML，直接搜索IG\n现在，我们找到了这个数据，用正则表达式将数据获取，其中re.search方法是调用第三方库re\n1 ig = re.search(r\u0026#39;IG:\u0026#34;(\\w+)\u0026#34;\u0026#39;,html).group(1) # 使用正则表达式在html文件中查找IG数据并获取 IID 我们用同样地办法查找IID的所在地并获取它\n找到IID的所在 找到IID数据的所在，依然在translator请求响应中，这就好办了，因为该请求的完整相应已经被我们获取了，只要找到相应的位置即可。\n刚刚获取的HTML文件中，你可以找到多个带有data-iid属性的\u0026lt;div\u0026gt;，因此，我们需要更加详细的信息来确认其位置，比如利用前面的id=\u0026quot; tta_outGDCont\u0026quot;，\n代码实现 可以使用第三方库BeautifulSoup，获取html格式数据中特定的属性，比如data-iid\n1 2 3 4 soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) dev_element = soup.find(\u0026#34;div\u0026#34;, id = \u0026#34;tta_outGDCont\u0026#34;) data_iid = dev_element.attrs[\u0026#34;data-iid\u0026#34;] print(\u0026#34;data_iid:\u0026#34;+data_iid) 我们来解释一下soup = BeautifulSoup(html, \u0026quot;html.parser\u0026quot;)这一段代码\n1. BeautifulSoup BeautifulSoup 是一个 Python 库，主要用于从 HTML 或 XML 文档中提取数据。它提供了许多方法来帮助你遍历、搜索和修改 HTML/XML 文档的内容。\n2. html html 是传入 BeautifulSoup 构造函数的参数，通常是一个包含 HTML 内容的字符串。它代表了待解析的 HTML 文档。可以是从文件读取的内容，或者是通过网络请求获取的 HTML 页面。\n3. \u0026ldquo;html.parser\u0026rdquo; \u0026quot;html.parser\u0026quot; 是 BeautifulSoup 的一个解析器（parser）。它告诉 BeautifulSoup 使用 Python 内建的 HTML 解析器来解析传入的 HTML 文档。这个解析器是一个快速且有效的解析工具，但对于一些特殊的 HTML，可能处理得不如其他第三方解析器（如 lxml 或 html5lib）精准。\n\u0026quot;html.parser\u0026quot; 选项是 Python 默认的解析器，但如果你安装了 lxml 或 html5lib 等库，也可以指定其他解析器。例如：\n\u0026quot;lxml\u0026quot;：使用 lxml 库的 HTML 解析器。 \u0026quot;html5lib\u0026quot;：使用 html5lib 库，它更宽容于不规范的 HTML 代码。 4. 最终效果 这行代码的作用是：通过 BeautifulSoup 库，将传入的 HTML 字符串 html 解析成一个 BeautifulSoup 对象，并指定使用内建的 html.parser 解析器。解析后的 soup 对象可以用来方便地操作和提取 HTML 内容。\n剩下的代码看方法名称也很好理解它是做什么的\ntoken与key 找到token与key的所在 我们用相同的办法，通过搜索框查找token的所在地，发现，这个信息同样存在于translator请求响应中：\n如果你仔细一点，你会发现，token前面那串数字，就是我们下一个要找的key！真是得来全不费工夫，剩下的两个数据被我们一次性找到了，接下来就是获取它们。\n代码实现 1 2 3 4 pattern = r\u0026#39;var params_AbusePreventionHelper = \\[(\\d+),\u0026#34;([^\u0026#34;]+)\u0026#34;,\\d+\\];\u0026#39; token = re.findall(pattern, html) print(\u0026#34;key:\u0026#34;+token[0][0]) print(\u0026#34;token:\u0026#34;+token[0][1]) 同样地，我们使用正则表达式，查找var params_AbusePreventionHelper后面的两个数据，放在token列表中。\n小结 至此，我们找到了我们所需的全部数据，接下来只需要将IG与IID填进URL中，将token与key填进表单中，就可发送完整的请求，伪装成正常的浏览器请求了。\n请求与获取相应 代码实现 1 2 3 4 5 6 7 8 9 10 11 url = \u0026#34;https://cn.bing.com/ttranslatev3?isVertical=1\u0026amp;\u0026amp;IG=\u0026#34;+ig+\u0026#34;\u0026amp;IID=\u0026#34;+data_iid print(url) header = {\u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} data = {\u0026#34;fromLang\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;en\u0026#34;,\u0026#34;token\u0026#34;:token[0][1],\u0026#34;key\u0026#34;:token[0][0],\u0026#34;text\u0026#34;:\u0026#34;今天的天气\u0026#34;,\u0026#34;tryFetchingGenderDebiasedTranslations\u0026#34;:\u0026#34;true\u0026#34;} print(data) data = urllib.parse.urlencode(data).encode(\u0026#34;utf-8\u0026#34;) req = urllib.request.Request(url, data, headers=header) response = urllib.request.urlopen(req) html = response.read().decode(\u0026#34;utf-8\u0026#34;) target = json.loads(html) print(target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;]) 根据上一篇文章的经验，以及本文上述的分析：\nURL需要根据上文所获取的IG与IID进行动态变换 data数据，将我们上面获取的token与key分别放入字典中 对数据进行UTF-8编码转换格式 发送请求 获取响应并进行UTF-8解码 转换JSON格式 获取数据 如果将进行UTF-8解码后的数据完整打印出来，将会是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [ { \u0026#34;translations\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Today\u0026#39;s weather\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;en\u0026#34;, \u0026#34;sentLen\u0026#34;:{ \u0026#34;srcSentLen\u0026#34;:[ 5 ], \u0026#34;transSentLen\u0026#34;:[ 15 ] } } ], \u0026#34;detectedLanguage\u0026#34;:{ \u0026#34;language\u0026#34;:\u0026#34;zh-Hans\u0026#34; } }, { \u0026#34;inputTransliteration\u0026#34;:\u0026#34;jīntiān de tiānqì\u0026#34; } ] 我们要的就是translations列表下的第一个字典中text对应的value\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from csv import Error from email.policy import HTTP from tkinter import E from urllib.error import URLError import requests import re from bs4 import BeautifulSoup from urllib import response import urllib.request import json class Translation: def __init__(self,content): self.translating(content) def translating(content,lfrom,lto): if content == \u0026#34;\u0026#34;: return \u0026#34;请输入内容\u0026#34; langfrom = {\u0026#34;自动检测\u0026#34;:\u0026#34;auto-detect\u0026#34;,\u0026#34;中文\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;English\u0026#34;:\u0026#34;en\u0026#34;} langto = {\u0026#34;中文\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;English\u0026#34;:\u0026#34;en\u0026#34;} url = \u0026#34;https://cn.bing.com/translator?ref=TThis\u0026amp;text=\u0026amp;from=zh-Hans\u0026amp;to=en\u0026#34; header = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} try: response = requests.get(url,headers=header,data={},timeout=5) except Exception as e: print(f\u0026#34;There are something wrong with the network: {e}\u0026#34;) return \u0026#34;website is not reachable\u0026#34; html = response.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) dev_element = soup.find(\u0026#34;div\u0026#34;, id = \u0026#34;tta_outGDCont\u0026#34;) data_iid = dev_element.attrs[\u0026#34;data-iid\u0026#34;] print(\u0026#34;data_iid:\u0026#34;+data_iid) ig = re.search(r\u0026#39;IG:\u0026#34;(\\w+)\u0026#34;\u0026#39;,html).group(1) print(\u0026#34;IG:\u0026#34;+ig) pattern = r\u0026#39;var params_AbusePreventionHelper = \\[(\\d+),\u0026#34;([^\u0026#34;]+)\u0026#34;,\\d+\\];\u0026#39; token = re.findall(pattern, html) print(\u0026#34;key:\u0026#34;+token[0][0]) print(\u0026#34;token:\u0026#34;+token[0][1]) url = \u0026#34;https://cn.bing.com/ttranslatev3?isVertical=1\u0026amp;\u0026amp;IG=\u0026#34;+ig+\u0026#34;\u0026amp;IID=\u0026#34;+data_iid print(url) header = {\u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} data = {\u0026#34;fromLang\u0026#34;:langfrom[lfrom],\u0026#34;to\u0026#34;:langto[lto],\u0026#34;token\u0026#34;:token[0][1],\u0026#34;key\u0026#34;:token[0][0],\u0026#34;text\u0026#34;:content,\u0026#34;tryFetchingGenderDebiasedTranslations\u0026#34;:\u0026#34;true\u0026#34;} print(data) data = urllib.parse.urlencode(data).encode(\u0026#34;utf-8\u0026#34;) try: req = urllib.request.Request(url, data, headers=header) response = urllib.request.urlopen(req) html = response.read().decode(\u0026#34;utf-8\u0026#34;) target = json.loads(html) except Exception as e: print(f\u0026#39;There are something wrong with the network: {e}\u0026#39;) return \u0026#34;website is not reachable\u0026#34; try: print(\u0026#34;translations:\u0026#34;+target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;]) except KeyError: print(target) return \u0026#34;something was wrong\u0026#34; return target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;] 结语 这次，我们完成了对微软翻译的完整爬虫，且可以完美多次长时间地运行，这个脚本功能已经完善，只是还没有嵌入到GUI程序中，下一篇文章，我们将会把这个脚本整理一下，放到脚本工具包中供翻译器调用，且会加装一些网络状况的判断。\n如果你看到这里，说明你又变强了！希望你变得更强，感谢你的观看，共同进步！\n","date":"2024-11-08T12:02:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B9%9D/webspider_hu11857342585609557978.jpg","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B9%9D/","title":"基于PyQt开发的脚本集合包（九）"},{"content":"前言 本文虽然被归类于PyQt开发实战，但实际上并没有关于PyQt的相关知识，这篇文章着重基于上篇文章，讲述笔者在开发翻译器时如何做爬取微软翻译网站时的分析，如何获取到网站所需要的信息。这其中也是夹杂了许多笔者个人的猜想与运气才碰出来的，笔者对爬虫也没有做更深的学习，只有一些粗浅的理解，并结合这个项目一点一点摸出来的，可能有更专业的工具与更成体系的知识架构，笔者也要去学习，希望这篇文章对读者能起到一些帮助和启发。\n本文从笔者第一次爬取开始讲起，第一次失败了，总结了失败的经验，第二次才爬取成功。\n第一次爬取微软翻译 分析 在笔者进行爬虫的时候，首先先打开了浏览器自带的开发者工具查看网络数据，看看在翻译时客户端与服务器之间做了哪些交流\n在排查的过程中，发现有一个名称叫做ttranslate...的包引起了笔者的注意，点进去发现这其中确实携带了笔者要翻译的信息\n从上图中可以看到，包的负载中的表单数据中有一项Text，携带的数据刚好是我们输入的翻译内容你好。\n打开预览可以看到更详细的信息\n在这里可以发现：\n这里有我们翻译之前的语种，即：zh-Hans，简体中文 翻译后的文本，保存在一个名为translations的数据中，text:Hello，这个数据就是我们要获取的数据，其实这就是对于翻译请求的响应，打开响应界面也是这一串信息 响应界面如下：\n所以，本质上，笔者就是想要获得对于这个请求的响应，因此笔者的方法是模仿这个包的请求，读取它的响应，从而获得对应的翻译数据。\n实践 因此根据爬虫的流程，笔者先获取了ttranslate的请求URL，即：\nhttps://cn.bing.com/ttranslatev3?isVertical=1\u0026\u0026IG=94BF74DDDBA34ECB8B2CFB8D7960E4F9\u0026IID=translator.5025\n再获取了请求标头中的User-Agent，即：\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0\n如下图所示：\n获取URL是为了获取请求的目的地，获取User-Agent是为了让服务器认为我们是一个人，而不是脚本在自动操作（虽然真的是一个脚本），现在这两者已经获取，我们这段信息就有了身份。（虽然请求标头中还有许多其它的信息，但笔者也没搞懂有什么作用，索性也就没管）\n接下来这既然是一个请求，那么我们就需要携带需要请求的消息，消息的格式是什么呢？在负载中可以找到，负载就是请求的内容，如下图所示：\n显而易见的是，表单数据中携带了我们待翻译内容的语种，翻译结果的语种，以及翻译的数据。我们需要将这些信息放进我们的请求中。\n信息收集完毕，开始编写代码（下面展示代码主题，读者需要注意这其中还调用了第三方关于爬虫的库，如报错，请pip install 响应的第三方库）\n1 2 3 4 5 6 7 8 9 url = \u0026#34;https://cn.bing.com/ttranslatev3?isVertical=1\u0026amp;\u0026amp;IG=94BF74DDDBA34ECB8B2CFB8D7960E4F9\u0026amp;IID=translator.5025\u0026#34; header = {\u0026#34;user-agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0\u0026#34;} data = {\u0026#34;fromLang\u0026#34;:\u0026#34;zh-Hans\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;en\u0026#34;,\u0026#34;text\u0026#34;:text} data = urllib.parse.urlencode(data).encode(\u0026#34;utf-8\u0026#34;) req = urllib.request.Request(url, data, headers=header) response = urllib.request.urlopen(req) html = response.read().decode(\u0026#34;utf-8\u0026#34;) target = json.loads(html) print(target[0][\u0026#39;translations\u0026#39;][0][\u0026#39;text\u0026#39;]) 以下，我们来逐行分析代码：\n将刚刚得到的URL存放起来 将user-agent也存放起来，存放在header字典中 将我们请求的数据：翻译前的语种，翻译后的语种，文本也存放起来，存放在data字典中 将data进行utf-8加密，转换成响应的url请求格式 使用Request方法发送请求，参数为url,data,header 使用urlopen方法获取响应 将响应解码 将JSON格式的字符串解析成python对象，比如字典，列表等 获取这个target中关于translation列表下的字典的text对应的值 总结 以上，是笔者的第一次爬虫，一开始爬取的时候使用正常，可以正常的使用，但没过多久，翻译器无法使用，无故闪退，笔者开始debug，发现已经无法通过这个url发送请求了。\n笔者开始整理，经过多次请求尝试和实验，发现url存在一些端倪：\nhttps://cn.bing.com/ttranslatev3?isVertical=1\u0026\u0026IG=94BF74DDDBA34ECB8B2CFB8D7960E4F9\u0026IID=translator.5025\n我们再来看一下这个URL，可以发现，这URL本身就携带了一些信息，IG与IID，这两个数据在每次会话结束后，都会发生变化，也就是说，当一个会话结束后，笔者所记录的IG与IID就失效了，无法访问，因此，这一次爬虫并不成功，还需要继续改进，获取每次访问微软翻译时的IG和IID数据。\n结语 总的来说，本文只是笔者在爬虫方向上的一次探索与学习，这是一次失败的尝试，不过可以看出，笔者在学习上的思路，笔者在学习时，喜欢在实践中发现问题并解决问题，因为理论与实践总是存在一定的差距，现实世界总是复杂且多变的。在实践中，你总会发现一些与理论有偏差或者相悖的地方，让你陷入迷茫，但是在实践中，你不会没有一点头绪，相反，在实践中，你有太多太多的方向去验证问题的本质，有时候往往是方向太多，你无法确定哪条路才能通向正确，你害怕做了无用功，害怕走错了方向，因此迟迟不敢动手，才导致了自己的踌躇不前。在现实世界中抽丝剥茧，也是一种学习，虽然笔者在这里也走错了路，离成功还有一段距离，但是走到这里，让笔者学会了如何看网络包，分析请求和响应，学会调用request库，以及最重要的找到了正确的道路，即：接下来，我们要想办法找到每一次IG和IID这两个数据如何变，在哪里变，如何获取到那个存放这两个数据的包。致敬技术，希望你变得更强！\n","date":"2024-11-07T19:16:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AB/webspider_hu11857342585609557978.jpg","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AB/","title":"基于PyQt开发的脚本集合包（八）"},{"content":"前言 上期文章我们讲了如何去实现一个UTF-8编码的转换器的构造以及代码实现。本期我们实现脚本集合包的第二个脚本（功能）：翻译器。目前，该翻译一起支持中译英，英译中，或自动检测翻译。翻译功能的实现本质上是通过爬虫技术去爬取网页实现的翻译功能，因此翻译功能需要联网才可进行。因此，在设计之初需要注意的是（虽然笔者并不是在设计之初就意识到会有这么多问题）：如何爬取一个网站，如何将需要翻译的内容上传给网站，是否需要判断当前状态是否联网，如何判断是否联网。如果处于断网状态如何处理\u0026hellip;\u0026hellip;接下来两到三篇文章会详细讲述这些问题如何解决。\n翻译器的UI布局 首先先看翻译器的UI布局\n可以看到这个翻译器的主要框架分为上中下三个部分，垂直分布，因此，主布局是一个垂直布局，三个部分分别是：翻译语言选择，翻译文本框，快速翻译三个部分。\n翻译语言选择：该部分由从左到右三个部分组成，水平布局，第一个下拉列表可选取待翻译语言的语种，包括：自动检测、中文、English三种，中间的组件是一个带有图标的按钮，可以转换左右下拉列表的语种，右边的下拉列表可选取翻译后的语种，包括：English、中文。 翻译文本框：该部分由从左到右三个部分组成，水平布局，第一个文本框是可读写文本框，可输入待翻译的内容，中间是一个按钮，点击按钮则开始翻译，右边文本框是一个只读文本框，在点击翻译按钮后，若翻译成功则会在该文本框中显示翻译后的内容。 快速翻译：快速翻译一个ListView，列表组件，其中存储了一个字典，显示对应的key，点击后会自动访问对应key的value，将value显示出来，无需联网，用于快速反应一些常用常翻译的内容。 代码解释 创建布局对象 根据上述UI的设计，我们可以创建对应的layout对象，并将子布局一次添加进主布局，主布局设置为widget的布局\n1 2 3 4 5 6 7 8 9 # create a horizontal layout layout = QVBoxLayout() # 主布局 langlayout = QHBoxLayout() # 翻译语言选择的布局 hlayout = QHBoxLayout() # 翻译文本框的布局 listlayout = QVBoxLayout() # 快速翻译列表的布局 layout.addLayout(langlayout) # 将三个子布局添加进主布局 layout.addLayout(hlayout) # 将三个子布局添加进主布局 layout.addLayout(listlayout) # 将三个子布局添加进主布局 self.setLayout(layout) # 将layout设置为该翻译器widget的布局 翻译语言的选择与切换UI设计 该部分由两个comboBox（下拉列表）和一个PushButton（按钮）组成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # lang layout self.langfromcb = QComboBox(self) # 创建输入语言的下拉列表 self.langfromcb.addItem(\u0026#34;自动检测\u0026#34;) # 往下拉列表中添加元素 self.langfromcb.addItem(\u0026#34;中文\u0026#34;) self.langfromcb.addItem(\u0026#34;English\u0026#34;) self.langfromcb.setCurrentIndex(1) # 将下拉列表中的第二个元素（0为第一个）设置为默认选项 self.langtocb = QComboBox(self) # 创建输出语言的下拉列表 self.langtocb.addItems([\u0026#39;中文\u0026#39;,\u0026#39;English\u0026#39;]) # 往下拉列表中添加元素 self.langtocb.setCurrentIndex(1) # 将下拉列表中的第二个元素设置为默认选项 self.exchangebtn = QPushButton(self) # 创建交换语种的按钮 pixmap = QPixmap(\u0026#34;_internal/res/img/exchange.ico\u0026#34;) # 将图标添加进变量 self.exchangebtn.setIcon(QIcon(pixmap)) # 为按钮设置图标 self.exchangebtn.setIconSize(self.exchangebtn.sizeHint()) # 设置图标为自适应按钮大小 self.exchangebtn.setToolTip(\u0026#34;交换语言\u0026#34;) # 为按钮设置提示泡泡 self.exchangebtn.clicked.connect(self.tranasexchange) # 给按钮点击状态连接事件方法，该方法将调转输入与输出语种 langlayout.addWidget(self.langfromcb) # 将三个组件都加入到第一个子布局中 langlayout.addWidget(self.exchangebtn) langlayout.addWidget(self.langtocb) 在这一段代码值得注意的是：\n这段代码展示了之前文章未出现的组件，即下拉列表（ComboBox）。\n下拉列表有两种添加元素的方法，addItem()与addItems()，一个参数为单个元素，一个参数为list，可同时输入多个元素。\nsetCurrentIndex()方法可设置下拉列表的首选项，比如：下拉列表的顺序为：自动检测，中文，English，我想让中文成为默认选项，则可使用setCurrentIndex(1)来使得中文成为默认选项，因为python是从0开始算起的。\n按钮可以添加图标，这个图标的地址开头是__internal，为什么使用这个作为最高级目录，请看往期内容基于PyQt开发的脚本集合包（三）第三节初始化应用程序部分，在窗口标签部分讲过相关内容。\n按键的提示泡泡长这样，当鼠标放在按钮上，会弹出一个小框描述该按键的功能。\n翻译文本框的UI设计 该部分是由两个文本框与一个按键组成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # input editor self.editor = QTextEdit(self) # 创建输入文本框 self.editor.setPlaceholderText(\u0026#34;翻译内容\u0026#34;) # 设置文本框的背景内容 hlayout.addWidget(self.editor) # 将输入文本框添加到子布局中 TextEditStyle(self.editor) # 修改文本框的样式，作者创建的方法，非第三方库调用 # translation button self.button = QPushButton(\u0026#34;翻译\u0026#34;,self) # 创建翻译按钮 btnReleaseStyleA(self.button) # 修改按钮的样式，作者创建的方法，非第三方库调用 self.button.clicked.connect(self.translating) # 按钮点击状态连接到translating事件方法 hlayout.addWidget(self.button) # 将按钮添加到子布局中 # output edit self.textedit = QTextEdit(self) # 创建输出文本框 self.textedit.setPlaceholderText(\u0026#34;翻译结果\u0026#34;) # 设置文本框的背景内容 self.textedit.setReadOnly(True) # 设置文本框为只读 hlayout.addWidget(self.textedit) # 将文本框添加到子布局中 TextEditStyle(self.textedit) # 修改文本框的样式，作者创建的方法，非第三方库调用 这段代码并没有什么需要特殊注意的地方，在之前的文章中我们已经用过多次了\n快速翻译列表UI设计 1 2 3 4 5 6 7 8 9 10 11 12 # list layout self.workdist = {\u0026#39;快进\u0026#39;:\u0026#39;forward\u0026#39;,\u0026#39;后退\u0026#39;:\u0026#39;backward\u0026#39;,\u0026#39;暂停\u0026#39;:\u0026#39;pause\u0026#39;,\u0026#39;停止\u0026#39;:\u0026#39;stop\u0026#39;, \u0026#39;播放\u0026#39;:\u0026#39;play\u0026#39;} self.model = QStandardItemModel(0, 1) # 创建一个模型类，0行1列，即没有元素 self.view = QListView(self) # 设置一个ListView对象 self.view.setModel(self.model) # 设置ListView对象的模型为上面创建的模型 for i in self.workdist.keys(): # 做一个for循环，循环从workdist中读取key item = QStandardItem(i) # 按顺序，将key设置为模型元素对象 self.model.appendRow(item) # 将对象添加到模型中 ListViewStyle(self.view) # 修改ListView的样式，作者创建的方法，非第三方库调用 listlayout.addWidget(self.view) # 将ListView对象添加到子布局中 self.view.clicked.connect(self.modelselected) # 将listview的点击状态连接到事件方法modelselected 这里新知识比较多，尤其是出现了一个陌生的控件QListView与一个模型类QStandardItemModel\nQStandardItemModel的定义\n在 PyQt 中，QStandardItemModel 是一个常用的模型类，它提供了一种标准的方式来存储和管理数据，尤其是用于与视图类（如 QListView、QTreeView 和 QTableView）配合使用。QStandardItemModel 是一种基于项（Item）模型的数据结构，它通过 QStandardItem 类来表示每个数据项。\nQStandardItemModel 主要特点：\n基于项的模型：它使用 QStandardItem 来表示数据的每一项，QStandardItem 是存储数据和管理项状态的对象。 支持树形和表格数据：通过 QStandardItemModel 可以管理数据，支持表格和树形结构。它可以通过层次结构来组织数据。 与视图（View）绑定：QStandardItemModel 与 PyQt 中的视图类（如 QListView、QTreeView、QTableView）一起使用，模型控制数据，而视图负责数据的显示和交互。 QListView控件与QComboBox功能相似，但是用途，行为和样式差别较大，直接问大模型会给你长长的一条差别，但在这里，使用QListView的原因是它好看，可自定义样式，且不会收束成一个单个元素，而是完整地展示所有元素。\n布局代码解释完了，接下来我们看一下实现交互功能的代码：\ntranasexchange 1 2 3 4 5 6 7 def tranasexchange(self): cba = self.langfromcb.currentText() cbb = self.langtocb.currentText() if cba == \u0026#34;自动检测\u0026#34;: cba = \u0026#34;English\u0026#34; self.langfromcb.setCurrentText(cbb) self.langtocb.setCurrentText(cba) 这个代码逻辑很简单实际上就是一个获取两个QComboBox的当前选择内容，然后交换它，因为langto并没有自动检测这一选项，所以当langfrom选择的是自动检测，则切换成English。\ntranslating 1 2 3 4 5 6 7 8 def translating(self): print(self.langfromcb.currentText(),\u0026#34; to \u0026#34;,self.langtocb.currentText()) text = self.editor.toPlainText() tran = Translation.translating(text,self.langfromcb.currentText(),self.langtocb.currentText()) if tran == \u0026#34;website is not reachable\u0026#34;: MsgClass().show_HTTP_error(\u0026#34;Website is not reachable\u0026#34;) else: self.textedit.setText(tran) 首先将从什么语种翻译到什么语种打印到log面板上 text变量获取当前输入文本框中的文本内容 将text中的文本内容，当前选择的两个语种，一共3个参数传入Translation对象的translating方法中，该方法才是真正实现翻译功能的方法，该方法会返回一个字符串，tran获取这个字符串 该if的其实就是回应我们开头提出的问题：“需不需要判断网络问题”以及“如果网络异常该怎么办”，在一开始，笔者并没有处理这个异常，直到有一次笔者挂了clash访问GitHub时，无法访问翻译网站，结果导致程序闪退，所以，必须要判断网络问题，才做了这个if判断来抛出异常，使脚本在遇到网络问题时依然能够正常运行。 MsgClass是笔者写的一个消息处理类，主要功能是获取文本，制作一个弹窗，弹窗内容就是获取到的文本，在这里是Website is not reachable 如果网络没有问题，则不会将获取的文本输出到输出文本框中 当然这个网络异常逻辑设计并不完美，因为有可能翻译的内容恰恰是website is not reachable，这样也会导致UI这一部分误以为是网络异常，从而弹窗警告。更优解时返回两个变量，一个变量是翻译内容，一个变量是网站访问情况。if检测网站访问情况，如果非200，如404，则抛出弹窗警告。 modelselected 1 2 3 4 def modelselected(self): print(self.view.currentIndex().data(),\u0026#39;to\u0026#39;,self.workdist[self.view.currentIndex().data()]) self.editor.setText(self.view.currentIndex().data()) self.textedit.setText(self.workdist[self.view.currentIndex().data()]) 如果是点击快速翻译中的某一项，则无需点击翻译按钮，直接完成翻译\n在log面板上打印当前选择的元素以及元素所对应的value（元素为字典中的key） 将元素设置为输入文本框的内容 将元素对应的value设置为输出文本框的内容 本文要点 翻译器的主要UI布局其实是模仿目前市面上大多数的翻译器设计的，主要是模仿微软翻译，即：搜索 Microsoft Translator - 从英语翻译到中文 (简体)。其实，该翻译器的实现，主要也是爬取了微软翻译，翻译器模仿成用户，向微软翻译发送翻译文本，并获取返回的response，拿到翻译后的结果。之所以不爬取有道翻译，是因为有道翻译对爬虫限制很高，现在甚至无法打开开发者工具（如果在有道翻译页面强行打开开发者工具，会导致闪退该页面）。 在这个页面的UI设计中，我们加入了许多新玩意儿，比如ListView，模型类QStandardItemModel，QComboBox，等等有趣的东西，想使用但却没有实际例子模仿的小伙伴可以借鉴参考。 在本文中我们回答了开头的五个问题中的两个，“是否需要判断当前状态是否联网”答案是：需要判断当前状态是否联网，如果不加以判断，当处于断网时，爬虫无法正常爬取网页，会抛出Error或Exception，如果处理，则会导致程序闪退。 “如果处于断网状态如何处理”，答案是，当判断出断网状态时，会抛出弹窗警告，弹窗警告的设计是笔者自做，后续系列更新会介绍。 ","date":"2024-11-07T15:33:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%83/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%83/","title":"基于PyQt开发的脚本集合包（七）"},{"content":"方法在工程中的位置 这一小节需要结合前面的基于PyQt开发的脚本集合包（二）内容来看，在那一篇文章中，我们讲到，我们讲主界面，功能UI界面，以及实现功能本身的方法分别放在了不同的地方以方便我们维护，此方法属于功能的实现，因此与其它脚本功能一同放在了tools目录下，如果要调用该功能，则需要使用import导入模块。\n代码解释 convertor模块中并没有类，只有一个方法，即convertor方法，它接受一个字符串参数，并将字符串进行编码，处理成UTF-8格式，输出十六进制数以及十六进制数的个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def convertor(s): res = \u0026#39;\u0026#39; # 将字符串s编码为UTF-8格式的字节串 strlen = len(s) for i in range(strlen): # 将字节串转换为十六进制表示，同时移除b\u0026#39;\u0026#39;标记并替换\\\\x为0x hexstr = \u0026#39;\u0026#39;.join(f\u0026#39;{byte:02x}\u0026#39; for byte in s[i].encode(\u0026#34;UTF-8\u0026#34;)) hexstr = hexstr.upper() # 可选：转换为大写 # 添加空格使得输出更易于阅读 hexstr_space = \u0026#39;, 0x\u0026#39;.join(hexstr[i:i + 2] for i in range(0, len(hexstr), 2)) hexstr_space = \u0026#39;0x\u0026#39;+hexstr_space res = res + hexstr_space + \u0026#39;, \u0026#39; res = res[:-2] print(res) return res,res.count(\u0026#39;0x\u0026#39;) 以下逐行解释代码：\n初始化res字符串变量， 获取传入的参数s字符串的长度，并传给strlen for循环遍历字符串中的每一个字符 s[i].encode(\u0026quot;UTF-8\u0026quot;)将字符编码为UTF-8字节串 for byte in ...是一个生成器表达式，它遍历编码后的字节串，每个byte表示UTF-8编码中的每一个字节 f'{byte:02x}'将每个字节转换为两位的十六进制字符串，0表示如果十六进制不足两位，则以0补足，2表示宽度位两位，x表示以十六进制格式输出，比如：如果byte的值为255，则会生成\u0026rsquo;ff\u0026rsquo;，如果byte的值为7，则会生成'07' ''.join(...)，join方法将生成器表达式的所有结果连成一个字符串，即格式化操作，例如：一个字符编码为b'\\xe4\\xb8\\xad'，经过格式化后将变成'e4b8ad' upper方法将输出的字符串中所有小写转换成大写 又一个join方法，将hexstr一个字符一个字符拆开，每个两个字符中间便加入, 0x，经过上一个join方法，这次经过格式化操作后，e4b8ad将会变成E4, 0xB8, 0xAD, 0x 在字符串最前面加上0x，变成：0xE4, 0xB8, 0xAD, 0x 删除最后3个字符（-1是最后一个，-2是倒数第二个，但是[]读内容的规则：前面读，后面不读，也就是虽然是最后一位是倒数第二，但实际上倒数第二不读，只读到倒数第三） 打印res结果 返回结果以及0x的计数（通过计算0x来计算有多少个十六进制数） 本文要点 本文中展示了，方法在工程中的位置，以及如何在工作区UI对象中导入该模块 详细解释了convertor方法如何实现字符串转UTF-8格式 其中有许多用法值得我们详细学习，比如join方法的使用，f'{byte:02x}'将每个字节转换成十六进制数，upper方法的使用，[]的读取范围的规则等 ","date":"2024-11-04T21:36:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AD/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%85%AD/","title":"基于PyQt开发的脚本集合包（六）"},{"content":"UTF-8编码器 UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无需或只进行少部分修改后，便可继续使用。\n比如：在蓝牙领域中，主机与从机自身携带的一些信息如蓝牙名称等，就是由UTF-8编码成十六进制字符串后进行传输，在进行蓝牙开发时，就会经常用到UTF-8编码，因此作者也是自做了一个UTF-8编码器集成到自己的脚本工具包中方便使用。\nUI设计 首先看成品，这个UTF-8编码器的工作区一共有几个部分组成：\n编码内容：是读写文本框，在此文本框中，可输入数字，符号，中文，英文等各种可被UTF-8编码的字符串，该文本框为默认形式，即可读可写。 编码结果：是只读文本框，在此文本框中，会显示编码完成后的结果，即十六进制数字组，例如：PyQt5编码后，编码结果会显示0x50, 0x79, 0x51, 0x74, 0x35，此文本框只允许读，复制等操作，不允许改写其中的内容。 字符数：也是只读文本框，在此文本框中，会显示编码结果的字符数，例如：PyQt5编码后，编码结果为5个十六进制数，字符数就为5，值得注意的是，字符数并不是与编码内容的字符串的长度一定相等，如果你的编码内容中含有中文，1个中文则会有3个十六进制数表示。 按钮：按钮连接了一个方法，在按钮被点击时触发方法，读取编码内容中的字符串，进行处理，然后再将结果输出再编码结果与字符数中。 功能UI的存放目录 在PyQt的第二篇文章（基于PyQt开发的脚本集合包（二））中我们讲到，实现不同功能的UI类是存放在一个相同的目录下，这样方便我们维护，也正是因为功能区的UI放在一个名为Classes的目录下，PrimeWindow不在该目录下。\n因此PrimeWindow想要调用，实现UTF-8编码器的UI界面，需要使用import。\n这表示：导入Classes目录下的ConvertorClass模块，并重命名为ConvertorClass。\n可以回到第四篇文章基于PyQt开发的脚本集合包（四）查看PrimeWindow如何使用这个模块的（在create_stack方法中）。\n代码解释 def __init__ 先看初始化代码，也是这个UTF-8对象的入口（这个UTF-8编码器是写在另一个目录下的一个类，上一篇文章中讲到的PrimeWindow就是调用了这个UTF-8编码器类，创建了一个编码器对象，这个类继承于Qwidget，因此这个编码器对象可以被看作是一个Qwidget来使用。）\nPS：如果对Qwidget这个概念有些模糊的话请看这里（如果熟悉了PyQt的基本知识请继续往下看），Qwidget本质上是一个组件，和按钮，文本框一样，只不过这个组件中可以放其它的组件，你可以把Qwidget想象成一个容器，这个容器装了许多东西，打包起来，然后再放到另一个容器中，像套娃一样。我们这里就是将上面说的三个文本框与按钮排列好放在一个名为Convertor的Qwidget容器中，然后打包成一个类，可供其它更大的Qwidget（比如PrimeWindow）调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def __init__(self): super().__init__() self.layout = QVBoxLayout() # 设置编码器的主布局为垂直布局VBox self.inputlayout = QHBoxLayout() # 设置水平的输入布局，即编码内容（由“编码内容”这四个字的标签与文本框水平布局构成） self.outputlayout = QHBoxLayout() # 设置水平的输出布局，即编码结果 self.countlayout = QHBoxLayout() # 设置水平的计数布局，即字符数 self.layout.addLayout(self.inputlayout) # 将三个布局以此添加进主布局中 self.layout.addLayout(self.outputlayout) # 依次添加会按顺序从上往下排列 self.layout.addLayout(self.countlayout) # 总的来说是三个小布局垂直分布，每个小布局中的两个组件水平分布 self.inputlable = QLabel(\u0026#34;编码内容\u0026#34;,self) # 创建“编码内容”这个四个字的标签 self.inputlayout.addWidget(self.inputlable) # 加入到输入布局中，从左到右排列 self.inputedior = QTextEdit(\u0026#34;输入文本\u0026#34;,self) # 创建输入文本框 TextEditStyle(self.inputedior) # 设置文本框的样式，该方法为作者自写，非第三方库调用 self.inputlayout.addWidget(self.inputedior) # 将文本框添加到输入布局中 convertbtn = QPushButton(\u0026#34;UTF-8编码\u0026#34;,self) # 创建按钮，按钮上的文字为“UTF-8编码” btnReleaseStyleA(convertbtn) # 设置按钮弹起状态的样式，该方法为作者自写，非第三方库调用 convertbtn.clicked.connect(self.converting) # 将按钮的点击状态连接到converting方法上，一旦检测到按钮被点击，则调用该方法 convertbtn.clicked.connect(self.counting) # 同理，将按钮的点击状态连接到counting方法上，一旦检查测到按钮被点击，则调用该方法 self.layout.addWidget(convertbtn) # 将按钮添加到主布局中，因为上面已经添加了三个小布局，因此按钮在布局最下方 self.outputlable = QLabel(\u0026#34;编码结果\u0026#34;,self) # 创建“编码结果”这四个字的标签 self.outputlayout.addWidget(self.outputlable) # 添加到输出布局中 self.outputedit = QTextEdit(\u0026#34;输出文本\u0026#34;,self) # 创建输出文本框 self.outputedit.setReadOnly(True) # 将文本框设置为只读模式 TextEditStyle(self.outputedit) # 设置文本框的样式，作者自写，非第三方库嗲用 self.outputlayout.addWidget(self.outputedit) # 将文本框添加到输出布局中 self.countlable = QLabel(\u0026#34;字符数：\u0026#34;,self) # 与上相同 self.countlayout.addWidget(self.countlable) self.countedit = QTextEdit(\u0026#34;字符数\u0026#34;,self) self.countedit.setReadOnly(True) TextEditStyle(self.countedit) self.countlayout.addWidget(self.countedit) # ********************** 已删，不好看 ********************** # 删除edit边框 # self.countedit.setFrameShape(QFrame.NoFrame) # # 删除edit背景 # self.countedit.setStyleSheet(\u0026#34;background-color: transparent;\u0026#34;) # ********************** 已删，不好看 ********************** self.setLayout(self.layout) # 将主布局设置为Qwidget的布局 def converting converting方法是主要实现UTF-8编码的方法的入口，它并不直接完成该任务，而是获取输入文本框的数据，然后传参给真正的编码方法。\n1 2 3 4 def converting(self): self.text = self.inputedior.toPlainText() self.res,self.count = convertor(self.text) self.outputedit.setText(self.res) 下面逐行解释代码：\n从输入文本框中获取文本内容，在PyQt中，toPlainText是QTextRdit控件的一个方法，用于获取文本框中的所有内容，并返回一个字符串，这与toHtml()不同，后者返回的是HTML格式的文本。 调用convertor这个外部方法，传入的参数就是文本框的内容（字符串），并获取返回结果（两个参数，一个是结果，一个是字符串数）。 将结果设置为输出框的文本。 值得注意的是，这里count变量被形容为self，这也就是说，在同一实例（对象）中，实例中的各个方法（被传入self），都可以调用这个count变量。\ndef counting counting方法的作用就是将上面得到的count设置为计数文本框中的内容。\n1 2 def counting(self): self.countedit.setText(str(self.count)) 为什么要舍近求远做这样一个操作呢，是为了提醒我：\n一个按钮的某一状态连接多个事件是可行的。 使用setText方法对某一文本框填入数据时，参数必须为字符串，如果非字符串的参数，必须使用str()方法转为字符串。 更深入了解self，可支持某一变量在其它方法间共用。 本文要点 本文中展示了，之前文章中铺垫的，功能区的用法。本质上就是功能区是PrimeWindow这个大的容器（Qwidget）专门空出来的一块地方，可以用来放其它的小的容器（Qwidget），其它的小的容器以对象（实例）的方式被创建，然后存放在抽屉（stack）中，这样我们在切换抽屉时，就是在切换小的容器，实现了大容器不变的情况下，大容器中的某一块区域可以灵活变化。 __init__方法是这个对象的入口（创建时被首先调用的函数），当对象被创建时，则会自动地进行初始化，完成整个编译器UI的创建和布局。初始化方法的代码解释写在了代码块中，因为代码较长，如果写出来的话篇幅太大，但是不写的话在CSDN和个人博客中都比较难阅读（无法自动换行），因此建议大家复制下来，贴在VScode中或自己的Typora中看，这样方便一点。 按钮连接的方法是使用xxxbtn.clicked.connect(xxxfunction)，该方法旨在某按键被click（点击）时，调用xxxfunction方法，且可以连接多个方法。 converting方法实际上是一个处理API的方法，负责传参与接收结果，convertor方法在下一篇文章中会介绍。 counting方法可以被整合到converting方法中，不过整个项目是作者的一个学习过程与心得，这样写是为了方便展示一些特性。 如果本文对你有所帮助，请记得给作者的CSDN点赞收藏QAQ，多多逛逛和订阅作者的个人博客，有什么问题或错误请联系作者的CSDN或发送到邮件中，祝大家生活愉快，变得更强！ ","date":"2024-11-04T19:29:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%94/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%94/","title":"基于PyQt开发的脚本集合包（五）"},{"content":"前言 作者的编程环境为VScode，工作时常使用VScode打开整个工程文件夹。如果先打开VScode再从VScode中选择文件夹打开效率太慢，作者一般使用的方式是右键文件夹，直接选择\u0026quot;通过code打开文件夹\u0026quot;，但某天，作者同往常一样工作时发现快捷键不起效，桌面的快捷方式也变成了无法使用的状态。\n通过设置索引回快捷方式的目标和起始位置，发现找不到对应的code.exe文件。这说明可能有以下几种情况：\nVScode在我不知情的情况下被卸载了 VScode中code.exe执行文件被删了 VScode出于某种情况（可能是更新），将执行文件改了名字或移动了位置 更新VScode快捷方式 通过查找VScode的目录，发现code.exe文件从原本的Microsoft VS Code目录下移动到Microsoft VS Code\\_目录下，多了一级目录，暂不清楚什么原因，因此桌面快捷方式不起作用，只需要将快捷方式的目标和起始位置做一下修改，桌面的快捷方式就可以重新使用了。\n右键使用VScode打开文件夹 重装软件 重装软件确实是一个简单且有效的方法，如果你的VScode比较干净的话。但如果你安装了许多插件且配置了多个Python的虚拟环境（那可是一个大工程），那么放弃现在的VScode对你来说可能是一个噩梦。如果你是此类人，我推荐你使用下面的方法。\n修改注册表 使用win + R打开运行，输入regedit打开注册表。\n配置：右键使用vscode打开文件 你可以直接在左侧目录树下找到HKEY_CLASSES_ROOT\\*\\shell，也可以在上方地址栏中输入，索引到相应的目录中\n在此目录下，shell目录下，执行以下操作：\n右键目录新建VisualCode项（根据知乎大神的操作，但是我看原本VScode自动配置时是生成VSCode项，名字似乎无关紧要，重点是其中的数据。如果你本身就有VSCode项，可以尝试直接对VSCode项做修改，而不新建VisualCode项）\n配置操作描述：VisualCode项中有一个名称为(默认)的数据，双击进去填写数值数据用VScode打开这个数据是你右键文件时出现的操作描述\n这个描述可自定义，你改成用用全世界最好用的VScode打开也可以\n配置图标：右键刚才新建的VisualCode项，在VisualCode中新建一个可扩充字符串值，双击该数据，将数值名称改为Icon，将数值数据修改为：Code.exe执行文件的地址，如我的地址为：\nC:\\Users\\86153\\AppData\\Local\\Programs\\Microsoft VS Code_\\Code.exe\n配置命令：右键刚才新建的VisualCode项，在VisualCode项中新建一个项，命名为command，这个项中也会有一个默认值，双击默认，修改数值数据为：\u0026quot;your\\path\\Code.exe\u0026quot; \u0026quot;%1\u0026quot;，注意：要有\u0026quot;\u0026quot;引号，%1为要打开的文件参数\n配置：右键使用vscode打开文件夹 找到HKEY_CLASSES_ROOT\\Directory\\shell目录。\n除了更改目录，其它操作与上面的完全一样\n配置：右键空白处使用vscode打开文件夹 找到HKEY_CLASSES_ROOT\\Directory\\Background\\shell目录。 把command中的数值数据中的%1改成%V 其它操作与上面完全一样 效果 现在，你就可以使用右键文件夹，使用vscode打开该文件夹\n参考文章：右键菜单加入用VSCode打开文件和文件夹 - 知乎\n","date":"2024-11-04T09:45:00+08:00","image":"https://Lyrical-wander.github.io/p/vscode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%8F%B3%E9%94%AE%E7%94%A8vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/VScodeShortCutLogo_hu9814141210490913990.png","permalink":"https://Lyrical-wander.github.io/p/vscode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%8F%B3%E9%94%AE%E7%94%A8vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"VSCode无法使用右键“用VScode打开文件夹”解决办法"},{"content":"PyQt主窗口框架设计(QWidget) PrimeWindow.py的主要作用是绘制主窗口，在主窗口中：\n最左边是各种功能组件的入口，比如：翻译器，UTF-8转换，图像处理等。 按下左边的按键，则会切换功能区，切换功能并非重新开一个窗口，而是切换中间部分，这里主要是采用stack的原理 最右边是日志打印区，通过重定向的方法，把打印在操作台的内容打印到这个窗口上，这样方便开发人员debug 4.1 import部分 1 2 3 4 5 6 7 8 import Classes.TranslatorClass as TranslatorClass import Classes.ConvertorClass as ConvertorClass import Classes.AudioProcessClass as AudioProcessClass import Classes.AudiocodecClass as AudiocodecClass import Classes.AudioPlayerClass as AudioPlayerClass import Classes.ImgProcessClass as ImgProcessClass from component.btnStyle import * from component.editStyle import * 这些引用均来自作者自己的代码，分别保存在Classes目录下和component目录下，从这些目录下import不同的类或方法供PrimeWindow调用。\nClasses中的各种类，如TranslatorClass，保存着翻译功能的功能区UI结构：翻译按钮，翻译内容输入框以及翻译结果展示框等，以及各组件的摆放位置。\ncomponent中的各种方法，如btnStyle，该文件中有按钮按下的样式，按钮抬起的样式等，只需在点击按钮时调用该方法即可改变按钮样式。\n4.2 重定向操作台输出 重定向操作台输出需要调用一些系统方法\n1 2 3 4 5 6 7 current_directory = os.getcwd() # 获取当前工作目录，并将其存储在current_directory中。 self.original_stdout = sys.stdout # 将当前的标准输出（操作台）保存到self.original_stdout中，这样可以在将来恢复标准输出 self.output_stream = io.StringIO() # 创建一个StringIO对象，这个对象像一个文件，可以在内存中操作字符串，之后的标准输入输出将写入这个对象 sys.stdout = self.output_stream # 将标准输出重定向到刚才创建的StringIO对象self.output_stream。这样，所有通过print语句输出的信息都将储存在output_stream中，而不是打印到操作台 self.timer = QTimer() # 创建一个定时器对象，用于定期触发某些事件 self.timer.timeout.connect(self.updateOutput) # 将定时器的信号连接到self.updateOutput方法上，当定时器达到超时时间时则会调用该方法 self.timer.start(1000) # 设置定时器的超时时间为1000ms即1s 以上实现的是：重定向操作台的输出，开启定时器，每1s后，将原本pirnt方法打印到操作台的字符串储存起来，并调用updateOutput方法\n以下是代码逐行分析：\n获取当前工作目录，并将其存储在current_directory中 将当前的标准输出（操作台）保存到self.original_stdout中，这样可以在将来恢复标准输出 创建一个StringIO对象，这个对象像一个文件，可以在内存中操作字符串，之后的标准输入输出将写入这个对象 将标准输出重定向到刚才创建的StringIO对象self.output_stream。这样，所有通过print语句输出的信息都将储存在output_stream中，而不是打印到操作台 创建一个定时器对象，用于定期触发某些事件 将定时器的信号连接到self.updateOutput方法上，当定时器达到超时时间时则会调用该方法 设置定时器的超时时间为1000ms即1s updateOutput方法：\n1 2 3 4 5 6 7 8 9 def updateOutput(self): output = self.output_stream.getvalue() # 从output_stream中获取字符串 if output: # 如果其中有字符串的话 cursor = self.consoleedit.textCursor() # 获取日志打印文本编辑控件的当前光标，方便在特定的位置插入文本 cursor.movePosition(QTextCursor.End) # 将光标移动至结尾，以便现有文本插入新的输出内容 cursor.insertText(output) # 将内容添加到日志打印文本编辑控件中 self.consoleedit.setTextCursor(cursor) # 更新光标位置为刚刚移动的光标，这确保了后续的输入或操作将从正确的位置开始 self.consoleedit.ensureCursorVisible() # 确保光标在文本编辑器中可见，特别是光标在底部时，防止用户无法看到最新的插入内容，尤其是文本框不够大时 self.output_stream.truncate(0) # 清空output_stream中的内容，将其内容截断为0，使得下一轮输出时不会将之前的内容重复添加 通过这个方法，即可将打印的内容输出到日志打印区中。并每1秒就检查一次是否有新的内容需要输出\n因为是利用定时器每1秒检查一次是否有新的输出内容，所以输出并不是实时进行的，如你需要更精确的日志打印，则调小定时器的超时时间，但请注意，定时器的超时时间越短，定时器就会越频繁地调用updateOutput方法，即使什么新内容也没有。如果你需要做一些复杂且精密的操作，则可能需要考虑时间与空间开销的问题。 以下是代码逐行分析：\n从output_stream中获取字符串 如果其中有字符串的话 获取日志打印文本编辑控件的当前光标，方便在特定的位置插入文本 将光标移动至结尾，以便现有文本插入新的输出内容 将内容添加到日志打印文本编辑控件中 更新光标位置为刚刚移动的光标，这确保了后续的输入或操作将从正确的位置开始 确保光标在文本编辑器中可见，特别是光标在底部时，防止用户无法看到最新的插入内容，尤其是文本框不够大时 清空output_stream中的内容，将其内容截断为0，使得下一轮输出时不会将之前的内容重复添加 4.3 stackLayout 切换功能 在PyQt中，QStackLayout是用于在同一位置上堆叠多个小组件的布局管理器，允许根据需要在它们之间进行切换，这对实现标签页或动态内容展示非常有用\n1 2 3 4 5 6 def create_stack(self): # create a stack layout self.stacklayout = QStackedLayout() convertor = ConvertorClass.Wconvertor() self.stacklayout.addWidget(convertor) 创建stacklayout 把功能UI实现的对象添加在stacklayout中 1 2 3 4 5 6 7 # set the convertor buttons self.UTF8ConvertorBtn = QPushButton(\u0026#34;UTF-8 转换\u0026#34;) # 创建按钮对象 btnReleaseStyleA(self.UTF8ConvertorBtn) # 修改按钮样式，该方法为作者创建，并非第三方库调用 self.UTF8ConvertorBtn.clicked.connect(self.Cbtn_press_clicked) # 为按钮连接触发事件，该事件会切换stack # add the buttons to the layout self.btnlayout.addWidget(self.UTF8ConvertorBtn) # 将按钮添加到功能按钮区布局 updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，并非第三方库调用 UTF8ConvertorBtn按钮连接上了Cbtn_press_clicked方法，表示当该按钮被按下时，则调用Cbtn_press_clicked方法。同时我对按钮的样式做了修改，使用方法btnReleaseStyleA，因为要对按钮做批量相同的修改，因此集成到一个方法中去调用是常见的编程思想。\n1 2 3 def Cbtn_press_clicked(self): updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，非第三方库调用 self.stacklayout.setCurrentIndex(0) # 将当前stack布局设置为第一个抽屉 setCurrentIndex方法的意思是，stacklayout所占据的这一片区域，可以随意切换成被它add了的widget，它就像一个抽屉一样，抽屉的大小固定，但是这个固定的大小所展示的内容是由你抽出第几层决定。就比如参数为0，则抽出的是第1个抽屉，这个抽屉是一个widget，这个widget可以套一个layout，其中放各种各样的组件。同理，参数为1,则表示抽出第2个抽屉，则stacklayout所占据的这一片区域就会切换成第2个抽屉的样子。\n4.4 UI初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def initUI(self): #---------------- create Layout we needed ---------------------------- self.Mainlayout = QHBoxLayout() # 主窗口 self.Primarylayout = QVBoxLayout() # 功能区布局 self.btnlayout = QVBoxLayout() # 功能按钮区布局 #---------------- create Layout we needed ---------------------------- #---------------- there has more btn but unshowing ------------------- # set the convertor buttons self.UTF8ConvertorBtn = QPushButton(\u0026#34;UTF-8 转换\u0026#34;) # 创建按钮对象 btnReleaseStyleA(self.UTF8ConvertorBtn) # 修改按钮样式，该方法为作者创建，并非第三方库调用 self.UTF8ConvertorBtn.clicked.connect(self.Cbtn_press_clicked) # 为按钮连接触发事件，该事件会切换stack # add the buttons to the layout self.btnlayout.addWidget(self.UTF8ConvertorBtn) # 将按钮添加到功能按钮区布局 updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，并非第三方库调用 #---------------- there has more btn but unshowing ------------------- self.btnlayout.setAlignment(Qt.AlignTop) # 调整按钮区的各组件对齐方式为向上对齐，而非均匀分布 #----------------- put the stack in function area -------------------- widget = QWidget() # 创建一个widget，用于存放stack布局 widget.setLayout(self.stacklayout) # 将stack布局放到widget中 self.Primarylayout.addWidget(widget) # 将widget放到功能区布局中，至此stack在功能区中进行切换 #----------------- put the stack in function area -------------------- #---------------------- create log area ------------------------------ self.Consolelayout = QVBoxLayout() # 创建日志区布局 self.consoleedit = QTextEdit() # 创建日志编辑文本框 self.consoleedit.setReadOnly(True) # 文本框设置为只读 TextEditStyle(self.consoleedit) # 修改文本框样式， 该方法为作者创建，并非第三方库调用 self.consoleedit.verticalScrollBar().setPageStep(100) # 修改滚动条步长 self.Consolelayout.addWidget(self.consoleedit) # 添加文本框到日志区布局中 #---------------------- create log area ------------------------------ #------------------ put the layouts in main layout ------------------- self.Mainlayout.addLayout(self.btnlayout,stretch=1) # 将按钮布局添加到主布局中 self.Vline = QFrame(self) # 添加细线 将按钮区与功能区分隔开 self.Vline.setFrameShape(QFrame.VLine) # 优化细线 self.Vline.setFrameShadow(QFrame.Raised) # 使细线具有凸起的立体感 self.Vline.setLineWidth(3) # 设置细线外部粗细 self.Vline.setMidLineWidth(1) # 设置细线内部粗细 self.Mainlayout.addWidget(self.Vline) # 将细线添加至主布局 self.Mainlayout.addLayout(self.Primarylayout,stretch=4) # 将功能区添加至主布局中 self.Mainlayout.addLayout(self.Consolelayout,stretch=2) # 将日志区添加至主布局中 # add the layout to the window self.setLayout(self.Mainlayout) # 将主窗口的布局设置为主布局 #------------------ put the layouts in main layout ------------------- 4.5 结语 到目前为止，我们脚本工具集合包已经具备了初步的大致框架，三大区块已经被划分出来了，接下来的工作将重点放在要开发哪些功能，如何实现这些功能，以及这些功能的UI页面布局。这个系列将会==持续更新==，动手能力强的小伙伴可以根据路线自己实操一遍，后续我也会将完整代码开源带GitHub上（等系类差不多结束的时候），同时系列文章也会同步更新到我的CSDN博客中，如果本系列真的帮助到你，请关注本频道，并给我的CSDN==点赞收藏==QAQ，感激不尽！\n如有任何疑问，欢迎私信我的CSDN或发邮件到707973090@qq.com，在我看到时会第一时间回复！\n","date":"2024-11-01T10:43:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%9B%9B/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%9B%9B/","title":"基于PyQt开发的脚本集合包（四）"},{"content":"PyQt程序入口（QMainWindow） main.py是程序的入口，程序最开始运行的文件，在这个文件中，需要完成以下几件事：\n创建一个MainWindow（主窗口） 设置主窗口的标题，图标 设置窗口的主体（centralWidget） 设置窗口的状态栏 创建workspaces目录 运行窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import sys import os from PyQt5.QtWidgets import * from PyQt5.QtGui import * from PyQt5.QtCore import * import PrimeWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;Script Tools\u0026#34;) self.setWindowIcon(QIcon(\u0026#34;_internal/res/icon/icon.ico\u0026#34;)) centralWidget = PrimeWindow.PrimeWindow() self.setCentralWidget(centralWidget) self.addStatusBar() def addStatusBar(self): self.statusBar = QStatusBar() self.statusWidget = QWidget() self.statusLayout = QHBoxLayout() self.copyrightlable = QLabel(\u0026#34;© Author: LyricalRover. All rights reserved.\u0026#34;) self.versionlable = QLabel(\u0026#34;Last updated: 2024-10-18. Version: 1.3.1\u0026#34;) self.statusLayout.addWidget(self.copyrightlable) self.statusLayout.addStretch() self.statusLayout.addWidget(self.versionlable) self.statusWidget.setLayout(self.statusLayout) self.statusBar.addWidget(self.statusWidget) self.setStatusBar(self.statusBar) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) w = MainWindow() if not os.path.exists(\u0026#34;workspaces\u0026#34;): os.makedirs(\u0026#34;workspaces\u0026#34;) w.show() app.exec() 最开始进入的地方是：if__name__ == \u0026ldquo;_main_\u0026rdquo;:\napp = QApplication(sys.argv)初始化应用程序对象\n1. QApplication 类 QApplication 是 Qt 应用程序的主类，负责管理应用程序的控制流和主要设置。 它处理应用程序的主事件循环，并为 GUI 元素提供必要的支持。 每个使用 Qt 的应用程序通常需要一个 QApplication 实例。 2. sys.argv 的作用 sys.argv 是一个列表，包含命令行参数。这些参数是在运行 Python 脚本时传递的。 QApplication 可以使用这些参数来配置应用程序的行为，例如窗口大小、样式等。 3. 初始化应用程序 通过 app = QApplication(sys.argv)，你完成了以下几个步骤：\n创建应用程序对象：这行代码创建了一个 QApplication 的实例，并将命令行参数传递给它。 设置事件循环：这个实例负责管理 GUI 的事件循环，使得应用程序能够响应用户输入和事件（例如鼠标点击、键盘输入等）。 为应用程序提供上下文：QApplication 提供了关于应用程序的信息，例如样式、主题、字体等。 创建MainWindow对象，即运行上面的class中的代码\ndef __init__中，设置窗口的标题，设置窗口的图标，在这里可以看到，设置图标的路径是：_internal/res/icon/icon.ico，但我们并没有创建这个__internal的目录，回顾环境配置中pyinstaller部分的讲解：“pyinstaller在v6.0版本以后，数据将被移动到__internal目录下”，也就是说，如果我们打包程序形成exe文件后，想要文件能够正确找到icon的地址，则必须在你写的地址前加上__internal目录，配合上打包时的参数,-add-data \u0026quot;icon.ico;__internal/res/icon/icon.ico\u0026quot;，就可以在打包后显示正常的图标。\n1 centralWidget = PrimeWindow.PrimeWindow() 上面的代码是创建一个UI主体，该主体是PrimeWindow对象，这个类在PrimeWindow.py中，这个主体内具体是怎样的后面会讲到。\naddStatusBar的结构如下图所示：\n左右分别是两个label的Widget，分别装了两条信息，中间用addStretch弹簧将两个label分压向两侧。\n理想很丰满，现实很骨感，实际上并没有呈现出这样一个操作，我猜测应该是有另一个东西阻碍了StatusBar，并没有完整占据整个窗口的下方，也就是说，StatusBar本身被压缩了，导致versionlabel并没有被压向窗口主体的右侧。但具体原因尚不明朗。\n还有一点值得注意的是：\n我在引入第三方库的时候因为偷懒使用了“*”，即：from PyQt5.QtWidgets import *等。\n建议使用了什么就引入import什么，而不是为了图方便而直接使用“*”，理由如下：\npython模块的导入实际上是通过import来进行导入的，一个模块一旦被导入，后续的导入操作则直接从缓存中读出，而不会重复导入，这就说明，在初次操作时，需要加载导入内容，如果使用“*”，初次导入的时间开销会更多一些，但后续的性能差别并不明显。 由于import *会导入所有的公共成员，因此它可能会占用更多的内存，因此空间开销会更大。 使用更明确的导入方式，会有助于代码的可读性，避免不必要的模块加载，减少潜在的时间和空间开销，同时较少命名冲突的风险，这种情况在大型项目中更为明显。 ","date":"2024-11-01T10:40:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%89/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%89/","title":"基于PyQt开发的脚本集合包（三）"},{"content":"布局 2.1 UI页面布局 整体框架分为分为三个部分，垂直分布。\n第一个部分为功能选择按钮（如UTF-8转换，翻译器等）\n第二部分为功能区，即对应功能输入，输出展示区\n第三部分为后台区，显示对应的后台信息（本质上是将终端输出的print重定向至这块区域，方便调试以及使用）\n除此之外，整体的下方状态信息栏中有版本信息\n整体布局如下图所示：\ntips：\n这个界面是直接在vscode中运行时所展示的，因此图标以及部分按钮并未完全列装（不保证debug与打包一致的原因较为复杂，与pyinstaller的版本有关，后续内容会解释），图标列装后如下所示：\n2.2 工程布局 在创作自己的程序前（如果是较大的程序），最好需要规划一下自己的工程结构，用多个不同的目录保存不同的资源，如图像，文本，代码等，而代码中，实现不同功能的subprograms（子程序）也可以再细分在不同的目录中，尤其是可以多个subprogram（子程序）反复调用的subprograms（子程序）或scripts（脚本）。\n我的工程布局意识也是在这个项目中不断完善的，还有一些不足和错误的地方也在不断更新中。\n一级目录 MyScriptTools目录是包目录，为了方便管理我们需要用到的各种包文件，需要在项目开始时便创建好该项目python运行的虚拟环境（虚拟环境具体的创建流程看前文）。创建完成后，使用pip包管理器下载的所有包都会保存在这个包目录中。（因为我的虚拟环境名字叫MyScriptTools，因此包目录的名字也叫MyScriptTools） src是存放代码的位置，所有的代码都存放在这个目录下 workspaces目录是运行时创建的保存文件目录，因为我的项目中，有一些功能或脚本会产生新的文件，我希望它们被保存在一个统一的空间，看起来不会太过混乱，因此专门设计了这一个功能：在程序运行时，创建一个workspaces目录，以后若产生新的文件，统一保存在workspaces目录下 BingTranslator.py与test.py是两个测试脚本，目前已经失去了作用 src目录 Classes：该目录下存放着各种功能的功能区UI类，error类等，如TranslatorClass.py为翻译功能的UI设计，包括按钮，文本框的布局等 component：该目录下存放着修改组件样式的方法，如editStyle.py文件中存放着修改QLineEdit样式的方法以及修改QTextEdit样式的方法。这样如果有多个QLineEdit组件需要修改样式时，只需要调用其中的方法即可。 dist：该目录是使用pyinstaller将程序打包成exe可执行文件时生成的，exe可执行文件存放在其中 res：该目录下存放着需要使用的图片，图标等资源文件 tools：该目录下存放着脚本以及功能的实现，如：实现翻译的功能方法存放在tools目录下的translation.py文件中，Classes目录下的TranslatorClass.py文件中会调用translation.py文件来实现功能 xxx.spec：该文件是如果打包时使用了\u0026ndash;onefile参数，即打包生成一个单独的exe文件，则会产生该文件，该文件记录了一些打包时需要关注的信息 icon.ico：图标文件，可要可不要，如果不要，在打包时想要生成exe文件的图标时需要指定图标的路径，我懒得指定路径，只想填个名字，就把图标放在与main.py同一目录下 main.py：该文件时程序的入口，与C程序的main相同。打包时需要指定程序入口，即该文件 PrimeWindow.py：主UI框架，即主窗口，上面Classes中的UI仅为功能区UI，属于主窗口的三部分之一 2.3 布局思想 我的布局思想是在不断碰壁的过程中自己摸索出来的，在开发这个程序之初并没有想把它做成一个完整的具有UI界面的功能集合包，因此一开始并没有工程布局的概念，需要做什么便在src下新建一个文件开始编码，这种习惯的弊端在随着程序愈发庞大而变得愈发清晰，使程序越来越难管理且开发难度增大。之后抽时间将程序整理了一遍，便形成了这种布局。个人观念，仅供参考。\n我的工程布局思想主要遵循两个原则：\n归类 相同属性或相同功能或本质相同的文件放在一个目录下，如：图片，文本等文件属于输入文件，只可被调用，因此放在同一目录res下，当然，res下可再做区分，img，icon，txt等。不同的功能区UI可放在同一目录下，这样可以将primeWindow与功能UI区分开来，且方便primeWindow调用功能UI，来实现功能的切换。功能的实现放在tools目录下，classes可以调用tools下相应的功能。tools目录下，部分功能过于复杂无法用一个文件完成也可以再建立子目录。\n重复调用 如果遇到需要反复调用的功能，可集成出来单独形成一个方法单独存放，方便不同文件的调用，而不需要重复实现，如文本框，单行文本框，按钮等样式，实现选择文件等功能\n","date":"2024-11-01T10:36:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%8C/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%8C/","title":"基于PyQt开发的脚本集合包（二）"},{"content":"前言 作者因为工作需要，用python写了一些脚本用于数据处理，UTF-8转换，以及一些我的工作专属脚本，又因为想要偷懒，用爬虫爬取了微软翻译的页面做了一个自己的翻译器，近来突发奇想，想要把各种python写的脚本整合到一起，并写一个GUI应用程序，因此PyQt进入了我的视野。想着用业余时间一点一点摸索，到目前为止算是做的有模有样，现写博客记录下来。\n这个GUI程序会分成一个系列更新，把我的UI框架，布局，工程整理，功能编写等等都写出来，包括：利用爬虫爬取微软翻译来做自己的翻译器，图像处理等。\n本脚本工具包还在持续更新（部分功能我也还没有完成），目前还没有做完的功能有：做音频数据处理（抓取BLE音频数据包，自动去包头去CRC校验，获取raw data的功能），音频编解码（利用市面上常见开源编解码器对音频数据进行编码或解码，ADPCM，SBC等），后续根据需要和精力，看能不能做音频数据的时域频域转换器等等。都是美好幻想，敬请期待！\n因为程序还在不断地完善更新，所以到系列结束时，代码应该就已经更新完成了，到时候我会将代码开源到我的GitHub仓库上，有兴趣的小伙伴可以下载使用或交流学习。本系列文章也会同步更新到我的CSDN博客中，如果小伙伴们觉得本系列对你有帮助，麻烦点个赞与收藏，感激不敬！\n环境配置 1.1 Python环境 python下载 python下载网上有许多教程，这里不赘述了，我的编程环境是vscode，创建虚拟环境，\n创建虚拟环境 1 python -m venv myPyQt #创建虚拟环境，命名为myPyQt 可以在终端查看包列表\n1 2 pip list # 看列表中是否有PyQt5相关的包 1.2 PyQt5安装 创建好虚拟环境后先进入虚拟环境，然后在该虚拟环境中下载PyQt5\n1 pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple # -i + 地址 为从国内镜像网站下载，提升下载速度 下载好qt后可以测试一下是否安装成功\n1 2 3 from PyQt5.QtCore import * print(QT_VERSION_STR) # 如果没有报错，则说明安装成功 1.3 Pyinstaller 打包命令：\n1 pyinstaller -n yourProgramName -i icon/path/icon.ico --add-data \u0026#34;path/xxx.png;.\u0026#34; --add-data \u0026#34;CanAddLotData.ico;path/in/__interval\u0026#34; -w main.py -n：你程序的名字\n-i：你应用的图标，如果与程序入口（main）不在同一目录下，则需要给出相应的路径\n\u0026ndash;add-data：链接外部资源，比如图片，图标等资源，该参数分为两个部分，使用“:”（Linux）或“;”（Windows）隔开，前面是打包前该文件的路径，后面是打包后该文件要保存的路径，下面是重点\n值得注意的是，pyinstaller在v6.0版本以后，如果没有加入--onefile参数，那么打包后会生成一个附带的目录__internal，打包后你的文件会保存在该目录下，比如：--add-data \u0026quot;res/xx.icon;res/xx.icon\u0026quot;，那么pyinstaller会在与main.py相同的目录下寻找一个res目录下的xx.icon文件，将其作为外部资源链接到程序中，并在__internal目录下创建一个res目录，存放一个xx.icon文件。如果你使用了--onefile参数，那么将不会创建__internal目录，res目录将会创建在与exe文件相同的目录下。GitHub上有对该问题的解释：Regression: datas moved to _internal in pyinstaller 6.1.0. pyinstaller 5.13.1 puts datas in correct directory · Issue #8075 · pyinstaller/pyinstaller\n切记切记这一点，因为这影响到你程序中调用资源文件时该如何填写路径，如果还没弄懂没有关系，后面会在代码中详细解释\n-w：此参数用于创建不显示命令行窗口的GUI程序，即：避免应用程序运行时弹出命令行窗口\nmain.py：程序入口\n如果你在使用 -i 命令时遇到来了以下报错：\n1 Received icon image \u0026#39;D:\\python\\MyScriptTools\\src\\icon.ico\u0026#39; which exists but is not in the correct format. On this platform, only (\u0026#39;exe\u0026#39;, \u0026#39;ico\u0026#39;) images may be used as icons. If Pillow is installed, automatic conversion will be attempted. Please install Pillow or convert your \u0026#39;ico\u0026#39; file to one of (\u0026#39;exe\u0026#39;, \u0026#39;ico\u0026#39;) and try again. 说明你使用的图标文件格式不正确，只有exe或ico格式的图像才可以用作图标。如果系统无法识别你的ico或你只有jpg或png等格式的图标，可以安装pillow，它会为你解决一切\n1 pip install pillow 那么到此为止，你做好了开发PyQt的前置工作\n","date":"2024-11-01T10:30:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%80/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%80/","title":"基于PyQt开发的脚本集合包（一）"}]