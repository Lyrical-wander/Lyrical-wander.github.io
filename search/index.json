[{"content":"前言 作者的编程环境为VScode，工作时常使用VScode打开整个工程文件夹。如果先打开VScode再从VScode中选择文件夹打开效率太慢，作者一般使用的方式是右键文件夹，直接选择\u0026quot;通过code打开文件夹\u0026quot;，但某天，作者同往常一样工作时发现快捷键不起效，桌面的快捷方式也变成了无法使用的状态。\n通过设置索引回快捷方式的目标和起始位置，发现找不到对应的code.exe文件。这说明可能有以下几种情况：\nVScode在我不知情的情况下被卸载了 VScode中code.exe执行文件被删了 VScode出于某种情况（可能是更新），将执行文件改了名字或移动了位置 更新VScode快捷方式 通过查找VScode的目录，发现code.exe文件从原本的Microsoft VS Code目录下移动到Microsoft VS Code\\_目录下，多了一级目录，暂不清楚什么原因，因此桌面快捷方式不起作用，只需要将快捷方式的目标和起始位置做一下修改，桌面的快捷方式就可以重新使用了。\n右键使用VScode打开文件夹 重装软件 重装软件确实是一个简单且有效的方法，如果你的VScode比较干净的话。但如果你安装了许多插件且配置了多个Python的虚拟环境（那可是一个大工程），那么放弃现在的VScode对你来说可能是一个噩梦。如果你是此类人，我推荐你使用下面的方法。\n修改注册表 使用win + R打开运行，输入regedit打开注册表。\n配置：右键使用vscode打开文件 你可以直接在左侧目录树下找到HKEY_CLASSES_ROOT\\*\\shell，也可以在上方地址栏中输入，索引到相应的目录中\n在此目录下，shell目录下，执行以下操作：\n右键目录新建VisualCode项（根据知乎大神的操作，但是我看原本VScode自动配置时是生成VSCode项，名字似乎无关紧要，重点是其中的数据。如果你本身就有VSCode项，可以尝试直接对VSCode项做修改，而不新建VisualCode项）\n配置操作描述：VisualCode项中有一个名称为(默认)的数据，双击进去填写数值数据用VScode打开这个数据是你右键文件时出现的操作描述\n这个描述可自定义，你改成用用全世界最好用的VScode打开也可以\n配置图标：右键刚才新建的VisualCode项，在VisualCode中新建一个可扩充字符串值，双击该数据，将数值名称改为Icon，将数值数据修改为：Code.exe执行文件的地址，如我的地址为：\nC:\\Users\\86153\\AppData\\Local\\Programs\\Microsoft VS Code_\\Code.exe\n配置命令：右键刚才新建的VisualCode项，在VisualCode项中新建一个项，命名为command，这个项中也会有一个默认值，双击默认，修改数值数据为：\u0026quot;your\\path\\Code.exe\u0026quot; \u0026quot;%1\u0026quot;，注意：要有\u0026quot;\u0026quot;引号，%1为要打开的文件参数\n配置：右键使用vscode打开文件夹 找到HKEY_CLASSES_ROOT\\Directory\\shell目录。\n除了更改目录，其它操作与上面的完全一样\n配置：右键空白处使用vscode打开文件夹 找到HKEY_CLASSES_ROOT\\Directory\\Background\\shell目录。 把command中的数值数据中的%1改成%V 其它操作与上面完全一样 效果 现在，你就可以使用右键文件夹，使用vscode打开该文件夹\n参考文章：右键菜单加入用VSCode打开文件和文件夹 - 知乎\n","date":"2024-11-04T09:45:00+08:00","image":"https://Lyrical-wander.github.io/p/vscode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%8F%B3%E9%94%AE%E7%94%A8vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/VScodeShortCutLogo_hu9814141210490913990.png","permalink":"https://Lyrical-wander.github.io/p/vscode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%8F%B3%E9%94%AE%E7%94%A8vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"VSCode无法使用右键“用VScode打开文件夹”解决办法"},{"content":"PyQt主窗口框架设计(QWidget) PrimeWindow.py的主要作用是绘制主窗口，在主窗口中：\n最左边是各种功能组件的入口，比如：翻译器，UTF-8转换，图像处理等。 按下左边的按键，则会切换功能区，切换功能并非重新开一个窗口，而是切换中间部分，这里主要是采用stack的原理 最右边是日志打印区，通过重定向的方法，把打印在操作台的内容打印到这个窗口上，这样方便开发人员debug 4.1 import部分 1 2 3 4 5 6 7 8 import Classes.TranslatorClass as TranslatorClass import Classes.ConvertorClass as ConvertorClass import Classes.AudioProcessClass as AudioProcessClass import Classes.AudiocodecClass as AudiocodecClass import Classes.AudioPlayerClass as AudioPlayerClass import Classes.ImgProcessClass as ImgProcessClass from component.btnStyle import * from component.editStyle import * 这些引用均来自作者自己的代码，分别保存在Classes目录下和component目录下，从这些目录下import不同的类或方法供PrimeWindow调用。\nClasses中的各种类，如TranslatorClass，保存着翻译功能的功能区UI结构：翻译按钮，翻译内容输入框以及翻译结果展示框等，以及各组件的摆放位置。\ncomponent中的各种方法，如btnStyle，该文件中有按钮按下的样式，按钮抬起的样式等，只需在点击按钮时调用该方法即可改变按钮样式。\n4.2 重定向操作台输出 重定向操作台输出需要调用一些系统方法\n1 2 3 4 5 6 7 current_directory = os.getcwd() # 获取当前工作目录，并将其存储在current_directory中。 self.original_stdout = sys.stdout # 将当前的标准输出（操作台）保存到self.original_stdout中，这样可以在将来恢复标准输出 self.output_stream = io.StringIO() # 创建一个StringIO对象，这个对象像一个文件，可以在内存中操作字符串，之后的标准输入输出将写入这个对象 sys.stdout = self.output_stream # 将标准输出重定向到刚才创建的StringIO对象self.output_stream。这样，所有通过print语句输出的信息都将储存在output_stream中，而不是打印到操作台 self.timer = QTimer() # 创建一个定时器对象，用于定期触发某些事件 self.timer.timeout.connect(self.updateOutput) # 将定时器的信号连接到self.updateOutput方法上，当定时器达到超时时间时则会调用该方法 self.timer.start(1000) # 设置定时器的超时时间为1000ms即1s 以上实现的是：重定向操作台的输出，开启定时器，每1s后，将原本pirnt方法打印到操作台的字符串储存起来，并调用updateOutput方法\n以下是代码逐行分析：\n获取当前工作目录，并将其存储在current_directory中 将当前的标准输出（操作台）保存到self.original_stdout中，这样可以在将来恢复标准输出 创建一个StringIO对象，这个对象像一个文件，可以在内存中操作字符串，之后的标准输入输出将写入这个对象 将标准输出重定向到刚才创建的StringIO对象self.output_stream。这样，所有通过print语句输出的信息都将储存在output_stream中，而不是打印到操作台 创建一个定时器对象，用于定期触发某些事件 将定时器的信号连接到self.updateOutput方法上，当定时器达到超时时间时则会调用该方法 设置定时器的超时时间为1000ms即1s updateOutput方法：\n1 2 3 4 5 6 7 8 9 def updateOutput(self): output = self.output_stream.getvalue() # 从output_stream中获取字符串 if output: # 如果其中有字符串的话 cursor = self.consoleedit.textCursor() # 获取日志打印文本编辑控件的当前光标，方便在特定的位置插入文本 cursor.movePosition(QTextCursor.End) # 将光标移动至结尾，以便现有文本插入新的输出内容 cursor.insertText(output) # 将内容添加到日志打印文本编辑控件中 self.consoleedit.setTextCursor(cursor) # 更新光标位置为刚刚移动的光标，这确保了后续的输入或操作将从正确的位置开始 self.consoleedit.ensureCursorVisible() # 确保光标在文本编辑器中可见，特别是光标在底部时，防止用户无法看到最新的插入内容，尤其是文本框不够大时 self.output_stream.truncate(0) # 清空output_stream中的内容，将其内容截断为0，使得下一轮输出时不会将之前的内容重复添加 通过这个方法，即可将打印的内容输出到日志打印区中。并每1秒就检查一次是否有新的内容需要输出\n因为是利用定时器每1秒检查一次是否有新的输出内容，所以输出并不是实时进行的，如你需要更精确的日志打印，则调小定时器的超时时间，但请注意，定时器的超时时间越短，定时器就会越频繁地调用updateOutput方法，即使什么新内容也没有。如果你需要做一些复杂且精密的操作，则可能需要考虑时间与空间开销的问题。 以下是代码逐行分析：\n从output_stream中获取字符串 如果其中有字符串的话 获取日志打印文本编辑控件的当前光标，方便在特定的位置插入文本 将光标移动至结尾，以便现有文本插入新的输出内容 将内容添加到日志打印文本编辑控件中 更新光标位置为刚刚移动的光标，这确保了后续的输入或操作将从正确的位置开始 确保光标在文本编辑器中可见，特别是光标在底部时，防止用户无法看到最新的插入内容，尤其是文本框不够大时 清空output_stream中的内容，将其内容截断为0，使得下一轮输出时不会将之前的内容重复添加 4.3 stackLayout 切换功能 在PyQt中，QStackLayout是用于在同一位置上堆叠多个小组件的布局管理器，允许根据需要在它们之间进行切换，这对实现标签页或动态内容展示非常有用\n1 2 3 4 5 6 def create_stack(self): # create a stack layout self.stacklayout = QStackedLayout() convertor = ConvertorClass.Wconvertor() self.stacklayout.addWidget(convertor) 创建stacklayout 把功能UI实现的对象添加在stacklayout中 1 2 3 4 5 6 7 # set the convertor buttons self.UTF8ConvertorBtn = QPushButton(\u0026#34;UTF-8 转换\u0026#34;) # 创建按钮对象 btnReleaseStyleA(self.UTF8ConvertorBtn) # 修改按钮样式，该方法为作者创建，并非第三方库调用 self.UTF8ConvertorBtn.clicked.connect(self.Cbtn_press_clicked) # 为按钮连接触发事件，该事件会切换stack # add the buttons to the layout self.btnlayout.addWidget(self.UTF8ConvertorBtn) # 将按钮添加到功能按钮区布局 updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，并非第三方库调用 UTF8ConvertorBtn按钮连接上了Cbtn_press_clicked方法，表示当该按钮被按下时，则调用Cbtn_press_clicked方法。同时我对按钮的样式做了修改，使用方法btnReleaseStyleA，因为要对按钮做批量相同的修改，因此集成到一个方法中去调用是常见的编程思想。\n1 2 3 def Cbtn_press_clicked(self): updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，非第三方库调用 self.stacklayout.setCurrentIndex(0) # 将当前stack布局设置为第一个抽屉 setCurrentIndex方法的意思是，stacklayout所占据的这一片区域，可以随意切换成被它add了的widget，它就像一个抽屉一样，抽屉的大小固定，但是这个固定的大小所展示的内容是由你抽出第几层决定。就比如参数为0，则抽出的是第1个抽屉，这个抽屉是一个widget，这个widget可以套一个layout，其中放各种各样的组件。同理，参数为1,则表示抽出第2个抽屉，则stacklayout所占据的这一片区域就会切换成第2个抽屉的样子。\n4.4 UI初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def initUI(self): #---------------- create Layout we needed ---------------------------- self.Mainlayout = QHBoxLayout() # 主窗口 self.Primarylayout = QVBoxLayout() # 功能区布局 self.btnlayout = QVBoxLayout() # 功能按钮区布局 #---------------- create Layout we needed ---------------------------- #---------------- there has more btn but unshowing ------------------- # set the convertor buttons self.UTF8ConvertorBtn = QPushButton(\u0026#34;UTF-8 转换\u0026#34;) # 创建按钮对象 btnReleaseStyleA(self.UTF8ConvertorBtn) # 修改按钮样式，该方法为作者创建，并非第三方库调用 self.UTF8ConvertorBtn.clicked.connect(self.Cbtn_press_clicked) # 为按钮连接触发事件，该事件会切换stack # add the buttons to the layout self.btnlayout.addWidget(self.UTF8ConvertorBtn) # 将按钮添加到功能按钮区布局 updateButtonStyle(self,self.UTF8ConvertorBtn) # 更新按钮样式，该方法为作者创建，并非第三方库调用 #---------------- there has more btn but unshowing ------------------- self.btnlayout.setAlignment(Qt.AlignTop) # 调整按钮区的各组件对齐方式为向上对齐，而非均匀分布 #----------------- put the stack in function area -------------------- widget = QWidget() # 创建一个widget，用于存放stack布局 widget.setLayout(self.stacklayout) # 将stack布局放到widget中 self.Primarylayout.addWidget(widget) # 将widget放到功能区布局中，至此stack在功能区中进行切换 #----------------- put the stack in function area -------------------- #---------------------- create log area ------------------------------ self.Consolelayout = QVBoxLayout() # 创建日志区布局 self.consoleedit = QTextEdit() # 创建日志编辑文本框 self.consoleedit.setReadOnly(True) # 文本框设置为只读 TextEditStyle(self.consoleedit) # 修改文本框样式， 该方法为作者创建，并非第三方库调用 self.consoleedit.verticalScrollBar().setPageStep(100) # 修改滚动条步长 self.Consolelayout.addWidget(self.consoleedit) # 添加文本框到日志区布局中 #---------------------- create log area ------------------------------ #------------------ put the layouts in main layout ------------------- self.Mainlayout.addLayout(self.btnlayout,stretch=1) # 将按钮布局添加到主布局中 self.Vline = QFrame(self) # 添加细线 将按钮区与功能区分隔开 self.Vline.setFrameShape(QFrame.VLine) # 优化细线 self.Vline.setFrameShadow(QFrame.Raised) # 使细线具有凸起的立体感 self.Vline.setLineWidth(3) # 设置细线外部粗细 self.Vline.setMidLineWidth(1) # 设置细线内部粗细 self.Mainlayout.addWidget(self.Vline) # 将细线添加至主布局 self.Mainlayout.addLayout(self.Primarylayout,stretch=4) # 将功能区添加至主布局中 self.Mainlayout.addLayout(self.Consolelayout,stretch=2) # 将日志区添加至主布局中 # add the layout to the window self.setLayout(self.Mainlayout) # 将主窗口的布局设置为主布局 #------------------ put the layouts in main layout ------------------- 4.5 结语 到目前为止，我们脚本工具集合包已经具备了初步的大致框架，三大区块已经被划分出来了，接下来的工作将重点放在要开发哪些功能，如何实现这些功能，以及这些功能的UI页面布局。这个系列将会==持续更新==，动手能力强的小伙伴可以根据路线自己实操一遍，后续我也会将完整代码开源带GitHub上（等系类差不多结束的时候），同时系列文章也会同步更新到我的CSDN博客中，如果本系列真的帮助到你，请关注本频道，并给我的CSDN==点赞收藏==QAQ，感激不尽！\n如有任何疑问，欢迎私信我的CSDN或发邮件到707973090@qq.com，在我看到时会第一时间回复！\n","date":"2024-11-01T10:43:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%9B%9B/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E5%9B%9B/","title":"基于PyQt开发的脚本集合包（四）"},{"content":"PyQt程序入口（QMainWindow） main.py是程序的入口，程序最开始运行的文件，在这个文件中，需要完成以下几件事：\n创建一个MainWindow（主窗口） 设置主窗口的标题，图标 设置窗口的主体（centralWidget） 设置窗口的状态栏 创建workspaces目录 运行窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import sys import os from PyQt5.QtWidgets import * from PyQt5.QtGui import * from PyQt5.QtCore import * import PrimeWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;Script Tools\u0026#34;) self.setWindowIcon(QIcon(\u0026#34;_internal/res/icon/icon.ico\u0026#34;)) centralWidget = PrimeWindow.PrimeWindow() self.setCentralWidget(centralWidget) self.addStatusBar() def addStatusBar(self): self.statusBar = QStatusBar() self.statusWidget = QWidget() self.statusLayout = QHBoxLayout() self.copyrightlable = QLabel(\u0026#34;© Author: LyricalRover. All rights reserved.\u0026#34;) self.versionlable = QLabel(\u0026#34;Last updated: 2024-10-18. Version: 1.3.1\u0026#34;) self.statusLayout.addWidget(self.copyrightlable) self.statusLayout.addStretch() self.statusLayout.addWidget(self.versionlable) self.statusWidget.setLayout(self.statusLayout) self.statusBar.addWidget(self.statusWidget) self.setStatusBar(self.statusBar) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) w = MainWindow() if not os.path.exists(\u0026#34;workspaces\u0026#34;): os.makedirs(\u0026#34;workspaces\u0026#34;) w.show() app.exec() 最开始进入的地方是：if__name__ == \u0026ldquo;_main_\u0026rdquo;:\napp = QApplication(sys.argv)初始化应用程序对象\n1. QApplication 类 QApplication 是 Qt 应用程序的主类，负责管理应用程序的控制流和主要设置。 它处理应用程序的主事件循环，并为 GUI 元素提供必要的支持。 每个使用 Qt 的应用程序通常需要一个 QApplication 实例。 2. sys.argv 的作用 sys.argv 是一个列表，包含命令行参数。这些参数是在运行 Python 脚本时传递的。 QApplication 可以使用这些参数来配置应用程序的行为，例如窗口大小、样式等。 3. 初始化应用程序 通过 app = QApplication(sys.argv)，你完成了以下几个步骤：\n创建应用程序对象：这行代码创建了一个 QApplication 的实例，并将命令行参数传递给它。 设置事件循环：这个实例负责管理 GUI 的事件循环，使得应用程序能够响应用户输入和事件（例如鼠标点击、键盘输入等）。 为应用程序提供上下文：QApplication 提供了关于应用程序的信息，例如样式、主题、字体等。 创建MainWindow对象，即运行上面的class中的代码\ndef __init__中，设置窗口的标题，设置窗口的图标，在这里可以看到，设置图标的路径是：_internal/res/icon/icon.ico，但我们并没有创建这个__internal的目录，回顾环境配置中pyinstaller部分的讲解：“pyinstaller在v6.0版本以后，数据将被移动到__internal目录下”，也就是说，如果我们打包程序形成exe文件后，想要文件能够正确找到icon的地址，则必须在你写的地址前加上__internal目录，配合上打包时的参数,-add-data \u0026quot;icon.ico;__internal/res/icon/icon.ico\u0026quot;，就可以在打包后显示正常的图标。\n1 centralWidget = PrimeWindow.PrimeWindow() 上面的代码是创建一个UI主体，该主体是PrimeWindow对象，这个类在PrimeWindow.py中，这个主体内具体是怎样的后面会讲到。\naddStatusBar的结构如下图所示：\n左右分别是两个label的Widget，分别装了两条信息，中间用addStretch弹簧将两个label分压向两侧。\n理想很丰满，现实很骨感，实际上并没有呈现出这样一个操作，我猜测应该是有另一个东西阻碍了StatusBar，并没有完整占据整个窗口的下方，也就是说，StatusBar本身被压缩了，导致versionlabel并没有被压向窗口主体的右侧。但具体原因尚不明朗。\n还有一点值得注意的是：\n我在引入第三方库的时候因为偷懒使用了“*”，即：from PyQt5.QtWidgets import *等。\n建议使用了什么就引入import什么，而不是为了图方便而直接使用“*”，理由如下：\npython模块的导入实际上是通过import来进行导入的，一个模块一旦被导入，后续的导入操作则直接从缓存中读出，而不会重复导入，这就说明，在初次操作时，需要加载导入内容，如果使用“*”，初次导入的时间开销会更多一些，但后续的性能差别并不明显。 由于import *会导入所有的公共成员，因此它可能会占用更多的内存，因此空间开销会更大。 使用更明确的导入方式，会有助于代码的可读性，避免不必要的模块加载，减少潜在的时间和空间开销，同时较少命名冲突的风险，这种情况在大型项目中更为明显。 ","date":"2024-11-01T10:40:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%89/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%89/","title":"基于PyQt开发的脚本集合包（三）"},{"content":"布局 2.1 UI页面布局 整体框架分为分为三个部分，垂直分布。\n第一个部分为功能选择按钮（如UTF-8转换，翻译器等）\n第二部分为功能区，即对应功能输入，输出展示区\n第三部分为后台区，显示对应的后台信息（本质上是将终端输出的print重定向至这块区域，方便调试以及使用）\n除此之外，整体的下方状态信息栏中有版本信息\n整体布局如下图所示：\ntips：\n这个界面是直接在vscode中运行时所展示的，因此图标以及部分按钮并未完全列装（不保证debug与打包一致的原因较为复杂，与pyinstaller的版本有关，后续内容会解释），图标列装后如下所示：\n2.2 工程布局 在创作自己的程序前（如果是较大的程序），最好需要规划一下自己的工程结构，用多个不同的目录保存不同的资源，如图像，文本，代码等，而代码中，实现不同功能的subprograms（子程序）也可以再细分在不同的目录中，尤其是可以多个subprogram（子程序）反复调用的subprograms（子程序）或scripts（脚本）。\n我的工程布局意识也是在这个项目中不断完善的，还有一些不足和错误的地方也在不断更新中。\n一级目录 MyScriptTools目录是包目录，为了方便管理我们需要用到的各种包文件，需要在项目开始时便创建好该项目python运行的虚拟环境（虚拟环境具体的创建流程看前文）。创建完成后，使用pip包管理器下载的所有包都会保存在这个包目录中。（因为我的虚拟环境名字叫MyScriptTools，因此包目录的名字也叫MyScriptTools） src是存放代码的位置，所有的代码都存放在这个目录下 workspaces目录是运行时创建的保存文件目录，因为我的项目中，有一些功能或脚本会产生新的文件，我希望它们被保存在一个统一的空间，看起来不会太过混乱，因此专门设计了这一个功能：在程序运行时，创建一个workspaces目录，以后若产生新的文件，统一保存在workspaces目录下 BingTranslator.py与test.py是两个测试脚本，目前已经失去了作用 src目录 Classes：该目录下存放着各种功能的功能区UI类，error类等，如TranslatorClass.py为翻译功能的UI设计，包括按钮，文本框的布局等 component：该目录下存放着修改组件样式的方法，如editStyle.py文件中存放着修改QLineEdit样式的方法以及修改QTextEdit样式的方法。这样如果有多个QLineEdit组件需要修改样式时，只需要调用其中的方法即可。 dist：该目录是使用pyinstaller将程序打包成exe可执行文件时生成的，exe可执行文件存放在其中 res：该目录下存放着需要使用的图片，图标等资源文件 tools：该目录下存放着脚本以及功能的实现，如：实现翻译的功能方法存放在tools目录下的translation.py文件中，Classes目录下的TranslatorClass.py文件中会调用translation.py文件来实现功能 xxx.spec：该文件是如果打包时使用了\u0026ndash;onefile参数，即打包生成一个单独的exe文件，则会产生该文件，该文件记录了一些打包时需要关注的信息 icon.ico：图标文件，可要可不要，如果不要，在打包时想要生成exe文件的图标时需要指定图标的路径，我懒得指定路径，只想填个名字，就把图标放在与main.py同一目录下 main.py：该文件时程序的入口，与C程序的main相同。打包时需要指定程序入口，即该文件 PrimeWindow.py：主UI框架，即主窗口，上面Classes中的UI仅为功能区UI，属于主窗口的三部分之一 2.3 布局思想 我的布局思想是在不断碰壁的过程中自己摸索出来的，在开发这个程序之初并没有想把它做成一个完整的具有UI界面的功能集合包，因此一开始并没有工程布局的概念，需要做什么便在src下新建一个文件开始编码，这种习惯的弊端在随着程序愈发庞大而变得愈发清晰，使程序越来越难管理且开发难度增大。之后抽时间将程序整理了一遍，便形成了这种布局。个人观念，仅供参考。\n我的工程布局思想主要遵循两个原则：\n归类 相同属性或相同功能或本质相同的文件放在一个目录下，如：图片，文本等文件属于输入文件，只可被调用，因此放在同一目录res下，当然，res下可再做区分，img，icon，txt等。不同的功能区UI可放在同一目录下，这样可以将primeWindow与功能UI区分开来，且方便primeWindow调用功能UI，来实现功能的切换。功能的实现放在tools目录下，classes可以调用tools下相应的功能。tools目录下，部分功能过于复杂无法用一个文件完成也可以再建立子目录。\n重复调用 如果遇到需要反复调用的功能，可集成出来单独形成一个方法单独存放，方便不同文件的调用，而不需要重复实现，如文本框，单行文本框，按钮等样式，实现选择文件等功能\n","date":"2024-11-01T10:36:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%8C/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%BA%8C/","title":"基于PyQt开发的脚本集合包（二）"},{"content":"前言 作者因为工作需要，用python写了一些脚本用于数据处理，UTF-8转换，以及一些我的工作专属脚本，又因为想要偷懒，用爬虫爬取了微软翻译的页面做了一个自己的翻译器，近来突发奇想，想要把各种python写的脚本整合到一起，并写一个GUI应用程序，因此PyQt进入了我的视野。想着用业余时间一点一点摸索，到目前为止算是做的有模有样，现写博客记录下来。\n这个GUI程序会分成一个系列更新，把我的UI框架，布局，工程整理，功能编写等等都写出来，包括：利用爬虫爬取微软翻译来做自己的翻译器，图像处理等。\n本脚本工具包还在持续更新（部分功能我也还没有完成），目前还没有做完的功能有：做音频数据处理（抓取BLE音频数据包，自动去包头去CRC校验，获取raw data的功能），音频编解码（利用市面上常见开源编解码器对音频数据进行编码或解码，ADPCM，SBC等），后续根据需要和精力，看能不能做音频数据的时域频域转换器等等。都是美好幻想，敬请期待！\n因为程序还在不断地完善更新，所以到系列结束时，代码应该就已经更新完成了，到时候我会将代码开源到我的GitHub仓库上，有兴趣的小伙伴可以下载使用或交流学习。本系列文章也会同步更新到我的CSDN博客中，如果小伙伴们觉得本系列对你有帮助，麻烦点个赞与收藏，感激不敬！\n环境配置 1.1 Python环境 python下载 python下载网上有许多教程，这里不赘述了，我的编程环境是vscode，创建虚拟环境，\n创建虚拟环境 1 python -m venv myPyQt #创建虚拟环境，命名为myPyQt 可以在终端查看包列表\n1 2 pip list # 看列表中是否有PyQt5相关的包 1.2 PyQt5安装 创建好虚拟环境后先进入虚拟环境，然后在该虚拟环境中下载PyQt5\n1 pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple # -i + 地址 为从国内镜像网站下载，提升下载速度 下载好qt后可以测试一下是否安装成功\n1 2 3 from PyQt5.QtCore import * print(QT_VERSION_STR) # 如果没有报错，则说明安装成功 1.3 Pyinstaller 打包命令：\n1 pyinstaller -n yourProgramName -i icon/path/icon.ico --add-data \u0026#34;path/xxx.png;.\u0026#34; --add-data \u0026#34;CanAddLotData.ico;path/in/__interval\u0026#34; -w main.py -n：你程序的名字\n-i：你应用的图标，如果与程序入口（main）不在同一目录下，则需要给出相应的路径\n\u0026ndash;add-data：链接外部资源，比如图片，图标等资源，该参数分为两个部分，使用“:”（Linux）或“;”（Windows）隔开，前面是打包前该文件的路径，后面是打包后该文件要保存的路径，下面是重点\n值得注意的是，pyinstaller在v6.0版本以后，如果没有加入--onefile参数，那么打包后会生成一个附带的目录__internal，打包后你的文件会保存在该目录下，比如：--add-data \u0026quot;res/xx.icon;res/xx.icon\u0026quot;，那么pyinstaller会在与main.py相同的目录下寻找一个res目录下的xx.icon文件，将其作为外部资源链接到程序中，并在__internal目录下创建一个res目录，存放一个xx.icon文件。如果你使用了--onefile参数，那么将不会创建__internal目录，res目录将会创建在与exe文件相同的目录下。GitHub上有对该问题的解释：Regression: datas moved to _internal in pyinstaller 6.1.0. pyinstaller 5.13.1 puts datas in correct directory · Issue #8075 · pyinstaller/pyinstaller\n切记切记这一点，因为这影响到你程序中调用资源文件时该如何填写路径，如果还没弄懂没有关系，后面会在代码中详细解释\n-w：此参数用于创建不显示命令行窗口的GUI程序，即：避免应用程序运行时弹出命令行窗口\nmain.py：程序入口\n如果你在使用 -i 命令时遇到来了以下报错：\n1 Received icon image \u0026#39;D:\\python\\MyScriptTools\\src\\icon.ico\u0026#39; which exists but is not in the correct format. On this platform, only (\u0026#39;exe\u0026#39;, \u0026#39;ico\u0026#39;) images may be used as icons. If Pillow is installed, automatic conversion will be attempted. Please install Pillow or convert your \u0026#39;ico\u0026#39; file to one of (\u0026#39;exe\u0026#39;, \u0026#39;ico\u0026#39;) and try again. 说明你使用的图标文件格式不正确，只有exe或ico格式的图像才可以用作图标。如果系统无法识别你的ico或你只有jpg或png等格式的图标，可以安装pillow，它会为你解决一切\n1 pip install pillow 那么到此为止，你做好了开发PyQt的前置工作\n","date":"2024-11-01T10:30:00+08:00","image":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%80/PythonForQt_hu4428717925490777624.png","permalink":"https://Lyrical-wander.github.io/p/%E5%9F%BA%E4%BA%8Epyqt%E5%BC%80%E5%8F%91%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%E5%8C%85%E4%B8%80/","title":"基于PyQt开发的脚本集合包（一）"}]